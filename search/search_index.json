{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Source code: https://github.com/trisongz/kvdb-py</p> <p>Documentation and examples: https://trisongz.github.io/kvdb-py</p>"},{"location":"#kvdb-py","title":"kvdb-py","text":"<p>Key-Value DB Python Client Abstraction built on top of Redis</p>"},{"location":"#overview","title":"Overview","text":"<p>This library builds upon the experience of my previous library, aiokeydb-py and the learnings and take-aways from maintaining it and using it in production. While <code>aiokeydb</code> supports <code>redispy</code> &lt; 5.0, this library only supports <code>redispy</code> &gt;= 5.0. </p> <p>Supports:</p> <ul> <li>[x] Redis</li> <li>[x] KeyDB</li> <li>[x] Dragonfly</li> <li>[ ] Memcached</li> <li>[ ] DynamoDB</li> <li>[ ] tikv</li> </ul> <p>The goals of this library are:</p> <ul> <li> <p>Provide a simple abstraction over the Redis client that allows both async and sync code, and adding minor tweaks in underlying implementation to make it more performant, and dynamic.</p> </li> <li> <p>Provide a unified interface for interacting with various Key-Value DBs, such as Redis, Memcached, etc. Inspired by gokv</p> </li> <li> <p>Enable interacting with multiple Key-Value DBs at the same time, with the same API</p> </li> <li> <p>Enable usage of Key-Value DBs in the same manner as a native Python dictionary</p> </li> <li> <p>Provide a task queue implementation that can be used to distribute work across multiple workers.</p> </li> <li> <p>Capability to customize and override the underlying classes easily without requiring to manually patch objects.</p> </li> </ul>"},{"location":"#why-not-use-redispy-directly","title":"Why not use <code>redispy</code> directly?","text":"<p><code>Redispy</code> is a great library, and this library itself is built on top of it. However, <code>redispy</code> lacks certain quality of life features that make it ready to use out of the box without having to extend the library to support these features. </p> <p><code>kvdb</code> also provides a powerful in-flight serialization and deserialization mechanism that allows you to store almost any type of object in the Key-Value DB without having to worry about serializing and deserializing the data prior to storing it. This is done by storing the object's type and any additional metadata required to reconstruct the object. You can read more about this in the Serialization section.</p> <p>Additionally, <code>kvdb</code> provides a unified async and sync interface for interacting with the Key-Value DB, rather than having to use two separate clients and instantiate two separate connections, defined as a <code>KVDBSession</code>. Each underlying <code>session</code> can share the same connection pool, so long as the <code>ConnectionPool</code> configuration is the same, meaning spawning multiple sessions will not saturate the connection pool.</p> <p><code>kvdb</code> utilizes singleton objects that manage instances of objects, such as <code>KVDBSession</code> and <code>Cachify</code>. This helps ensure performance and reduce memory usage by preventing the creation of multiple instances of the same object.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install kvdb-py\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Check out the examples directory for examples on how to use this library.</p>"},{"location":"#performance-features","title":"Performance Features","text":"<p><code>kvdb-py</code> includes several advanced performance optimizations:</p> <ul> <li>Optimized Connection Pooling: Uses <code>OptimizedAsyncConnectionPool</code> by default for async connections. This pool implements a \"hybrid blocking\" strategy\u2014using a low-contention fast path for available connections and efficiently waiting (blocking) when the pool is exhausted, preventing connection errors under high load.</li> <li><code>uvloop</code> Support: Automatically detects and uses <code>uvloop</code> if installed, significantly boosting async I/O performance.</li> <li>PersistentDict Optimization: The <code>PersistentDict</code> implementation uses custom Lua scripts for atomic operations (<code>HGET</code>, <code>HSET</code>, <code>HDEL</code>). This minimizes network round-trips, making the organized <code>HSET</code> storage method as performant as raw Key-Value access.</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from kvdb import KVDBClient\nfrom pydantic import BaseModel\n\n# Explicitly define the config. Otherwise it will use the defaults, which are determined via environment variables.\n\n# session = KVDBClient.get_session(name=\"default\", url=os.environ.get(\"REDIS_URL|KVDB_URL|KEYDB_URL|MEMCACHED_URL\"))\n\nsession = KVDBClient.get_session(name=\"default\", url=\"redis://localhost:6379/0\", serializer='json')\n\nclass MyModel(BaseModel):\n    name: str\n    age: int\n\n# This demonstrates how the pydantic model is automatically serialized and deserialized\nnew_model = MyModel(name='John', age=30)\nsession.set(new_model.name, new_model)\nsrc_model = session.get('John')\n\nassert src_model == new_model\n\n# Without explicitly defining the serailizer, the same would fail.\n\nsession2 = KVDBClient.get_session(name=\"test-1\")\n# This will fail because the serializer is not defined\nsession2.set(new_model.name, new_model)\n</code></pre>"},{"location":"#task-queues","title":"Task Queues","text":"<p>This is a client-side example of how to use kvdb-py tasks.</p> <p>By Default, <code>tasks</code> will use <code>db_id=3</code> for the task queue to prevent collisions with other data. You can change this by passing <code>db_id</code> to the <code>register</code> decorator or <code>create_context</code> function. If you do, ensure that the queue you are using also uses the same <code>db_id</code>.</p> <p>This will be able to remotely execute the tasks from <code>examples/queue/dummy_tasks.py</code></p> <p>To run this example, you will need to run the following commands:</p> <p>Terminal 1:</p> <pre><code># cwd: examples/queue\n$ kvdb-task -i \"dummy_tasks.initializer\" -n 1 -q \"test\" -q \"global\"\n\n# Output:\n- [Worker ID]: 63f0e517-e3bd-4d6c-xxx-xxxx [Worker Name]: global-local-0 [Node Name]: computer.local \n- [Concurrency]: 150/jobs, 50/broadcasts\n- [Queues]:\n- [test]      @ redis://localhost:6379/3 DB: 3, 1 functions, 0 cron jobs\n        [Functions]: `['my_task']`\n- [global]    @ redis://localhost:6379/3 DB: 3, 2 functions, 0 cron jobs\n        [Functions]: `['TestWorker.task1', 'TestWorker.task2']\n</code></pre> <p>Terminal 2:</p> <pre><code># cwd: examples/queue\n$ python client_side.py\n</code></pre>"},{"location":"#the-server-side-example","title":"The Server Side Example:","text":"<pre><code># dummy_task.py\n\n\nimport abc\nfrom kvdb import tasks\nfrom kvdb.utils.logs import logger\n\n# Create a new task context that will be used to register the tasks\n# Any params passed to create_context will be used as partials for the register decorator\n# that can subsequently be overriden by the kwargs passed to the register decorator\n\n# Since no `queue_name` is passed, it will default to `global`\ntask_context = tasks.create_context(disable_patch = False)\n\n# This will be registered to the `test` queue\n@tasks.register(queue_name='test')\nasync def my_task(*args, **kwargs):\n    logger.info(f'Hello Worlddddddd {args} {kwargs}')\n    return None\n\n\n# This will be registered to the `global` queue\n# This decorator is required when using an object and\n# registering the object's methods as tasks\n# so that the object can be patched with initializers\n# to add the registered functions to the task context\n@task_context.register_object()\nclass TestWorker(abc.ABC):\n\n    def __init__(self, *args, **kwargs):\n        logger.info(f'initializing {args} {kwargs}')\n\n    # Both of these should work\n    # @tasks.register(queue_name='global')\n    @task_context.register()\n    async def task1(self, ctx, *args, **kwargs):\n        # This function will be passed the task context as the first argument\n        # since it has `ctx` as the first argument\n        # The task context is a singleton object that is shared across all tasks\n        # that contains `Job`, `TaskWorker`\n        # and any contexts that are initialized.\n        logger.info(f'task 1 hello {ctx} {args} {kwargs} {self}')\n        return 'hello_1'\n\n    @task_context.register()\n    async def task2(self, *args, **kwargs):\n        logger.info(f'task 2 hello {args} {kwargs} {self}')\n        return 'hello_2'\n\n# Since we pass -i \"dummy_tasks.initializer\" to the kvdb-task command\n# it will run this function to initialize the task context. If the \n# object is not initialized, then the functions will not be registered\ndef initializer():\n    x = TestWorker()\n</code></pre>"},{"location":"#the-client-side-example","title":"The Client Side Example:","text":"<pre><code># client_side.py\n\nimport sys\nimport asyncio\nfrom pathlib import Path\nsys.path.append(str(Path(__file__).parent))\n\nimport dummy_tasks\nfrom kvdb import tasks\n\nasync def entrypoint():\n    # Initialize and register the tasks\n    x = dummy_tasks.TestWorker()\n\n    q1 = tasks.get_task_queue(queue_name = 'global', debug_enabled = True)\n    q2 = tasks.get_task_queue(queue_name = 'test', debug_enabled = True)\n\n    # We can spawn tasks one of two ways. Either by calling the function directly\n    # since we have it patched with a decorator\n    # or by calling the task queue's enqueue method\n\n    # Task 1 requires ctx, so it can only be called via the task queue\n    await q1.enqueue('TestWorker.task1')\n    # await x.task1(blocking = False)\n\n    await q1.enqueue('TestWorker.task2')\n\n    # You can also enqueue a function directly by passing the function\n    await q2.enqueue(dummy_tasks.my_task)\n\n    # Additionally, since the underlying function is patched with the register decorator\n    # you can also call the function directly and it will be executed as a task\n    await dummy_tasks.my_task(blocking = False)\n    await x.task2(blocking = False)\n    await q1(x.task1, blocking = False)\n\n    # If `blocking` is set to `True`, then the task will be executed and will wait for the result\n\n    # If `blocking` is set to `False`, then the task will be executed and will not wait for the result, but instead return a `Job` object\n\n    result_1 = await x.task2(blocking = True)\n    result_2 = await q1(x.task1, blocking = True)\n\n    logger.info(f'result_1: {result_1}')\n    logger.info(f'result_2: {result_2}')\n    assert result_1 == 'hello_2'\n    assert result_2 == 'hello_1'\n\n\nif __name__ == '__main__':\n    asyncio.run(entrypoint())\n</code></pre>"},{"location":"#caching","title":"Caching","text":"<p>Below are two examples of how to use the caching functionality of <code>kvdb-py</code>. The first example demonstrates how to use the caching functionality with any functions, and the second example demonstrates how to use the caching functionality with an object.</p> <p>See the following files for more examples:</p> <ul> <li> <p>examples/caching/basic.py for an example of how to use caching with functions</p> </li> <li> <p>examples/caching/objects.py for an example of how to use caching with an object</p> </li> <li> <p>examples/caching/context.py for an example of how to use caching with a pre-defined context</p> </li> </ul> <pre><code>import time\nimport abc\nimport asyncio\nfrom lazyops.utils.times import Timer\nfrom kvdb.io import cachify\nfrom kvdb.utils.logs import logger\n\nDEBUG_ENABLED = False\n\n@cachify.register(ttl = 10, verbosity = 2 if DEBUG_ENABLED else None, cache_max_size = 15)\nasync def async_fibonacci(number: int):\n    if number == 0: return 0\n    elif number == 1: return 1\n    return await async_fibonacci(number - 1) + await async_fibonacci(number - 2)\n\n@cachify.register(ttl = 10, verbosity = 2 if DEBUG_ENABLED else None)\ndef fibonacci(number: int):\n    if number == 0: return 0\n    elif number == 1: return 1\n    return fibonacci(number - 1) + fibonacci(number - 2)\n\n# No Cache Versions\nasync def async_fibonacci_nc(number: int):\n    if number == 0: return 0\n    elif number == 1: return 1\n    return await async_fibonacci_nc(number - 1) + await async_fibonacci_nc(number - 2)\n\ndef fibonacci_nc(number: int):\n    if number == 0: return 0\n    elif number == 1: return 1\n    return fibonacci_nc(number - 1) + fibonacci_nc(number - 2)\n\n## Object Caching\n@cachify.register_object()\nclass TestObject(abc.ABC):\n\n    def __init__(self, *args, **kwargs):\n        logger.info('running init')\n\n    @cachify.register(ttl = 10, verbosity = 2 if DEBUG_ENABLED else None, cache_max_size = 15)\n    async def async_fibonacci(self, number: int):\n        if number == 0: return 0\n        elif number == 1: return 1\n        return await self.async_fibonacci(number - 1) + await self.async_fibonacci(number - 2)\n\n    @cachify.register(ttl = 10, verbosity = 2 if DEBUG_ENABLED else None)\n    def fibonacci(self, number: int):\n        if number == 0: return 0\n        elif number == 1: return 1\n        return self.fibonacci(number - 1) + self.fibonacci(number - 2)\n\n    # No Cache Versions\n    async def async_fibonacci_nc(self, number: int):\n        if number == 0: return 0\n        elif number == 1: return 1\n        return await self.async_fibonacci_nc(number - 1) + await self.async_fibonacci_nc(number - 2)\n\n    def fibonacci_nc(self, number: int):\n        if number == 0: return 0\n        elif number == 1: return 1\n        return self.fibonacci_nc(number - 1) + self.fibonacci_nc(number - 2)\n</code></pre>"},{"location":"#persistence","title":"Persistence","text":"<p>An additional feature of <code>kvdb-py</code> is the ability to access a <code>Dict</code>-like object that is persisted to the Key-Value DB. This is useful for storing data that needs to be accessed by multiple processes or machines. This is powered by the underlying <code>PersistentDict</code> from <code>lazyops</code>, with <code>kvdb-py</code> providing the backend to the Key-Value DB.</p> <pre><code>import random\nfrom pydantic import BaseModel, Field\nfrom kvdb import KVDBClient\n\nclass NewObject(BaseModel):\n    x: int = Field(default_factory = lambda: random.randint(0, 100))\n\n\ntest_1 = NewObject()\ntest_2 = NewObject(x = 1)\n\n# Create a new Session that does not use a Serializer\n# and uses the default connection pool\ns = KVDBClient.get_session(\n    name = 'default',\n    persistence_base_key = 'test',\n    persistence_serializer = 'json',\n)\n\n# You can set the attributes directly\n# or call the underlying `persistence` object\ns['test_1'] = test_1\ns['test_2'] = test_2\n\n# s.persistence['test_1'] = test_1\n# s.persistence['test_2'] = test_2\n\nresult_1 = s['test_1']\nresult_2 = s['test_2']\n# result_1 = s.persistence['test_1']\n# result_2 = s.persistence['test_2']\n\nprint(result_1, 'type', type(result_1))\nprint(result_2, 'type', type(result_2))\n\n\n# Create a new Session that uses the JSON Serializer\n# natively within the connection pool\ns_json = KVDBClient.get_session(\n    name = 's_json',\n    serializer = 'json',\n    persistence_base_key = 'test_json',\n)\n\ns_json['test_1'] = test_1\ns_json['test_2'] = test_2\n# s_json.persistence['test_1'] = test_1\n# s_json.persistence['test_2'] = test_2\n\njson_result_1 = s_json['test_1']\njson_result_2 = s_json['test_2']\n# json_result_1 = s_json.persistence['test_1']\n# json_result_2 = s_json.persistence['test_2']\n\nprint(json_result_1, 'type', type(json_result_1))\nprint(json_result_2, 'type', type(json_result_2))\n\n# Test assertions\nassert result_1 == json_result_1\nassert result_2 == json_result_2\n\n# Delete the keys\ndel s['test_1']\ndel s['test_2']\n# s.delitem('test_1')\n# s.delitem('test_2')\n# s.persistence.pop('test_1')\n# s.persistence.pop('test_2')\n\ndel s_json['test_1']\ndel s_json['test_2']\n# s_json.persistence.pop('test_1')\n# s_json.persistence.pop('test_2')\n\n## Additionally, you can initialize a new persistence object directly\np = s_json.get_persistence(\n    name = 'p',\n    base_key = 'test_pickle',\n    serializer = 'pickle',\n)\n\np['test_1'] = test_1\np['test_2'] = test_2\n</code></pre>"},{"location":"#customization","title":"Customization","text":"<p>Since no objects/settings are initialized until they are first directly called, you can easily customize and define configurations for the underlying objects. For example, if you want to use a different serializer, you can do the following:</p> <pre><code>from kvdb.io.serializers import set_default_serializer, set_default_serializer_lib, register_serializer\n\n# Set the default serializer to use\n# If `propogate=True` This will set the default serializer to pickle for all modules, such as cache, tasks, etc. Otherwise, it will only affect instances where `serializer=None`.\n\nset_default_serializer('pickle', propagate = True) \n\n# Set the default serializer library to use\nset_default_serializer_lib('cloudpickle')\n\n# You can also register a custom serializer\nregister_serializer('custom-serializer', MySerializerClass, set_as_default = True, propogate = True)\n\n\n# Alternatively, you can selectively modify the default serializer for certain modules\nfrom kvdb.configs import set_default_serializer_for, set_default_kvdb_url\n\nset_default_kvdb_url('redis://remote.redis.com:6379/0')\nset_default_serializer_for('custom-serializer', 'session', 'task')\n\nfrom kvdb import KVDBClient\n\nsession = KVDBClient.get_session()\n\nclass MyModel(BaseModel):\n    name: str\n    age: int\n\n# This demonstrates how the pydantic model is automatically serialized and deserialized\nnew_model = MyModel(name='John', age=30)\nsession.set(new_model.name, new_model)\nsrc_model = session.get('John')\n\n# The session will use the custom serializer for the session\nassert src_model == new_model\n</code></pre>"},{"location":"multidb/","title":"Multi-Database (Active-Active) Support","text":"<p>Starting with redis-py 7.0, kvdb-py supports Active-Active database configurations through the <code>KVDBMultiDBClient</code>. This feature is designed for production environments using Redis Enterprise with Active-Active geo-distributed databases.</p>"},{"location":"multidb/#overview","title":"Overview","text":"<p>The multi-database client provides:</p> <ul> <li>Automatic Failover: Seamlessly switches to backup databases when the active database becomes unhealthy</li> <li>Circuit Breakers: Prevents cascading failures by temporarily stopping requests to unhealthy databases</li> <li>Health Monitoring: Continuously checks database health with configurable intervals and policies</li> <li>Weighted Selection: Prioritizes databases by weight for intelligent failover decisions</li> <li>Command Retries: Automatically retries failed commands with exponential backoff</li> <li>Auto-Fallback: Returns to higher-priority databases when they recover</li> </ul>"},{"location":"multidb/#requirements","title":"Requirements","text":"<pre><code>pip install 'redis&gt;=7.0' pybreaker\n</code></pre> <p>The multidb features require: - redis-py &gt;= 7.0 - pybreaker (for circuit breaker functionality) - Redis Enterprise with Active-Active databases or multiple Redis instances</p>"},{"location":"multidb/#basic-usage","title":"Basic Usage","text":""},{"location":"multidb/#simple-configuration","title":"Simple Configuration","text":"<pre><code>from kvdb.components.multidb import KVDBMultiDBClient\n\n# Create client from URLs with weights\nclient = KVDBMultiDBClient.from_urls(\n    urls=[\n        \"redis://primary.example.com:6379/0\",\n        \"redis://secondary.example.com:6379/0\",\n    ],\n    weights=[1.0, 0.5],  # Primary has higher weight\n)\n\n# Initialize (performs health checks and sets up monitoring)\nclient.initialize()\n\n# Use like a normal Redis client\nclient.set(\"key\", \"value\")\nvalue = client.get(\"key\")\n</code></pre>"},{"location":"multidb/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code>from kvdb.components.multidb import (\n    KVDBMultiDBClient,\n    MultiDbConfig,\n    DatabaseConfig,\n)\n\nconfig = MultiDbConfig(\n    databases_config=[\n        DatabaseConfig(\n            from_url=\"redis://db1.example.com:6379/0\",\n            weight=1.0,\n            health_check_url=\"redis://db1.example.com:6379/0\",\n            grace_period=30.0,  # Circuit breaker grace period\n        ),\n        DatabaseConfig(\n            from_url=\"redis://db2.example.com:6379/0\",\n            weight=0.8,\n            health_check_url=\"redis://db2.example.com:6379/0\",\n        ),\n        DatabaseConfig(\n            from_url=\"redis://db3.example.com:6379/0\",\n            weight=0.5,\n            health_check_url=\"redis://db3.example.com:6379/0\",\n        ),\n    ],\n    # Health check configuration\n    health_check_interval=10.0,      # Check every 10 seconds\n    health_check_probes=3,           # Number of probes for health determination\n    health_check_probes_delay=1.0,   # Delay between probes\n\n    # Failover configuration\n    failover_attempts=3,             # Number of failover attempts\n    failover_delay=1.0,              # Delay between attempts\n    auto_fallback_interval=120.0,    # Auto-fallback to primary after 2 minutes\n\n    # Failure detection\n    min_num_failures=5,              # Minimum failures before triggering failover\n    failure_rate_threshold=0.5,      # 50% failure rate threshold\n    failures_detection_window=60.0,  # Track failures in 60-second window\n)\n\nclient = KVDBMultiDBClient(config)\nclient.initialize()\n</code></pre>"},{"location":"multidb/#using-connection-pools","title":"Using Connection Pools","text":"<pre><code>from redis import ConnectionPool\nfrom kvdb.components.multidb import MultiDbConfig, DatabaseConfig, KVDBMultiDBClient\n\n# Create connection pools for better connection management\npool1 = ConnectionPool.from_url(\"redis://db1.example.com:6379/0\", max_connections=50)\npool2 = ConnectionPool.from_url(\"redis://db2.example.com:6379/0\", max_connections=50)\n\nconfig = MultiDbConfig(\n    databases_config=[\n        DatabaseConfig(from_pool=pool1, weight=1.0),\n        DatabaseConfig(from_pool=pool2, weight=0.5),\n    ]\n)\n\nclient = KVDBMultiDBClient(config)\nclient.initialize()\n</code></pre>"},{"location":"multidb/#using-with-redis-cluster","title":"Using with Redis Cluster","text":"<pre><code>from redis import RedisCluster\nfrom kvdb.components.multidb import KVDBMultiDBClient\n\nclient = KVDBMultiDBClient.from_urls(\n    urls=[\n        \"redis://cluster1.example.com:6379/0\",\n        \"redis://cluster2.example.com:6379/0\",\n    ],\n    weights=[1.0, 0.5],\n    client_class=RedisCluster,  # Use Redis Cluster\n)\n\nclient.initialize()\n</code></pre>"},{"location":"multidb/#key-concepts","title":"Key Concepts","text":""},{"location":"multidb/#database-weights","title":"Database Weights","text":"<p>Weights determine database priority for active selection: - Higher weight = higher priority for becoming active - Used during failover to select the next best database - Typical pattern: Primary (1.0), Secondary (0.5-0.8), Tertiary (0.3-0.5)</p>"},{"location":"multidb/#circuit-breakers","title":"Circuit Breakers","text":"<p>Circuit breakers prevent cascading failures: - CLOSED: Database is healthy, requests flow normally - OPEN: Database is unhealthy, requests are blocked - HALF_OPEN: Testing if database has recovered</p> <p>The <code>grace_period</code> defines how long to wait before testing recovery.</p>"},{"location":"multidb/#health-checks","title":"Health Checks","text":"<p>Continuous health monitoring with configurable policies: - Probes: Number of health check attempts - Delay: Time between probe attempts - Policy: Logic for determining overall health from probe results</p>"},{"location":"multidb/#failover-strategy","title":"Failover Strategy","text":"<p>When active database fails: 1. Circuit breaker opens for the failed database 2. Failure detector triggers failover 3. Next highest-weighted healthy database becomes active 4. Commands are retried on new active database 5. Original database is monitored for recovery</p>"},{"location":"multidb/#auto-fallback","title":"Auto-Fallback","text":"<p>After a configured interval, the system checks if higher-weighted databases have recovered and automatically fails back to them.</p>"},{"location":"multidb/#manual-database-management","title":"Manual Database Management","text":"<pre><code># Get all databases\ndatabases = client.get_databases()\n\n# Manually set active database\nfor db, weight in databases:\n    if weight == 1.0:  # Highest weighted\n        client.set_active_database(db)\n        break\n\n# Add a new database dynamically\nfrom kvdb.components.multidb import Database\nfrom redis import Redis\n\nnew_db = Database(\n    client=Redis.from_url(\"redis://new-db.example.com:6379/0\"),\n    circuit=...,  # Circuit breaker instance\n    weight=0.6,\n)\nclient.add_database(new_db)\n</code></pre>"},{"location":"multidb/#event-handling","title":"Event Handling","text":"<p>The multidb client dispatches events for monitoring:</p> <pre><code>from redis.event import EventDispatcher\n\ndef on_database_failover(event):\n    print(f\"Failover occurred: {event}\")\n\ndispatcher = EventDispatcher()\n# Register event handlers as needed\n\nconfig = MultiDbConfig(\n    databases_config=[...],\n    event_dispatcher=dispatcher,\n)\n</code></pre>"},{"location":"multidb/#best-practices","title":"Best Practices","text":"<ol> <li>Use Health Check URLs: For Redis Enterprise, use the FQDN endpoint for accurate health checks</li> <li>Set Appropriate Weights: Reflect geographic or infrastructure preferences</li> <li>Configure Timeouts: Set reasonable socket timeouts to detect failures quickly</li> <li>Monitor Events: Track failover events for operational awareness</li> <li>Test Failover: Regularly test failover scenarios in staging</li> <li>Connection Pools: Use connection pools for better resource management</li> </ol>"},{"location":"multidb/#troubleshooting","title":"Troubleshooting","text":""},{"location":"multidb/#import-error-no-module-named-pybreaker","title":"Import Error: No module named 'pybreaker'","text":"<pre><code>pip install pybreaker\n</code></pre>"},{"location":"multidb/#import-error-cannot-import-multidbclient","title":"Import Error: Cannot import MultiDBClient","text":"<p>Upgrade redis-py: <pre><code>pip install --upgrade 'redis&gt;=7.0'\n</code></pre></p>"},{"location":"multidb/#novaliddatabaseexception-on-initialize","title":"NoValidDatabaseException on Initialize","text":"<ul> <li>Ensure at least one Redis instance is running and accessible</li> <li>Check connection URLs are correct</li> <li>Verify network connectivity to Redis instances</li> <li>Check Redis authentication credentials if using password</li> </ul>"},{"location":"multidb/#failover-not-working","title":"Failover Not Working","text":"<ul> <li>Verify health check URLs are configured correctly</li> <li>Check failure detection thresholds are appropriate</li> <li>Ensure health check interval is reasonable for your use case</li> <li>Monitor circuit breaker states</li> </ul>"},{"location":"multidb/#limitations","title":"Limitations","text":"<ul> <li>The multidb client is marked as experimental in redis-py</li> <li>Not all Redis commands may work identically across databases</li> <li>Active-Active configurations have eventual consistency characteristics</li> <li>Transaction support may be limited across failovers</li> </ul>"},{"location":"multidb/#see-also","title":"See Also","text":"<ul> <li>redis-py Multi-Database Documentation</li> <li>Redis Enterprise Active-Active</li> <li>Circuit Breaker Pattern</li> </ul>"},{"location":"api/cachify/api/","title":"Cachify API","text":"<p>Cachify is a simple caching class that provides a context manager interface for caching objects, functions with flexibility in how you encode, decode, serialize, and compress your data.</p> <ul> <li>Context Manager</li> <li>Cachify Context</li> <li>Cachify Object</li> </ul>"},{"location":"api/cachify/api/#api-reference","title":"API Reference","text":"MODULE DESCRIPTION <code>base</code> <code>cache</code> <code>helpers</code> <p>Helper Functions to Apply to the <code>cachify</code> Module</p> <code>main</code> FUNCTION DESCRIPTION <code>create_context</code> <p>Creates a CachifyContext for registering functions and objects</p> <code>register</code> <p>Registers a function for caching</p> <code>register_object</code> <p>Registers an object for caching</p> <code>register_object_method</code> <p>Registers an object method for caching</p>"},{"location":"api/cachify/api/#kvdb.io.cachify.create_context","title":"create_context","text":"<pre><code>create_context(\n    cache_name: typing.Optional[str] = None,\n    cachify_class: typing.Optional[\n        typing.Type[\"Cachify\"]\n    ] = None,\n    cachify_context_class: typing.Optional[\n        typing.Type[\"CachifyContext\"]\n    ] = None,\n    session: typing.Optional[\"KVDBSession\"] = None,\n    session_name: typing.Optional[str] = None,\n    partial_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    **kwargs\n) -&gt; \"CachifyContext\"\n</code></pre> <pre><code>create_context(\n    cache_name: typing.Optional[str] = None, **kwargs\n) -&gt; \"CachifyContext\"\n</code></pre> <p>Creates a CachifyContext for registering functions and objects</p> Source code in <code>kvdb/io/cachify/__init__.py</code> <pre><code>def create_context(\n    cache_name: Optional[str] = None,\n    **kwargs,\n) -&gt; 'CachifyContext':\n    \"\"\"\n    Creates a CachifyContext for registering functions and objects\n    \"\"\"\n    from .main import CachifyManager\n    return CachifyManager.create_cachify_context(\n        cache_name = cache_name,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/cachify/api/#kvdb.io.cachify.register","title":"register","text":"<pre><code>register(\n    function: typing.Optional[\n        kvdb.io.cachify.base.FunctionT\n    ] = None,\n    cache_name: typing.Optional[str] = None,\n    ttl: typing.Optional[int] = 60 * 10,\n    ttl_kws: typing.Optional[typing.List[str]] = [\n        \"cache_ttl\"\n    ],\n    keybuilder: typing.Optional[typing.Callable] = None,\n    name: typing.Optional[\n        typing.Union[str, typing.Callable]\n    ] = None,\n    typed: typing.Optional[bool] = True,\n    exclude_keys: typing.Optional[typing.List[str]] = None,\n    exclude_null: typing.Optional[bool] = True,\n    exclude_exceptions: typing.Optional[\n        typing.Union[bool, typing.List[Exception]]\n    ] = True,\n    prefix: typing.Optional[str] = \"_kvc_\",\n    exclude_null_values_in_hash: typing.Optional[\n        bool\n    ] = None,\n    exclude_default_values_in_hash: typing.Optional[\n        bool\n    ] = None,\n    exclude_if: typing.Optional[typing.Callable] = None,\n    disabled: typing.Optional[\n        typing.Union[bool, typing.Callable]\n    ] = None,\n    disabled_kws: typing.Optional[typing.List[str]] = [\n        \"cache_disable\"\n    ],\n    invalidate_after: typing.Optional[\n        typing.Union[int, typing.Callable]\n    ] = None,\n    invalidate_if: typing.Optional[typing.Callable] = None,\n    invalidate_kws: typing.Optional[typing.List[str]] = [\n        \"cache_invalidate\"\n    ],\n    overwrite_if: typing.Optional[typing.Callable] = None,\n    overwrite_kws: typing.Optional[typing.List[str]] = [\n        \"cache_overwrite\"\n    ],\n    retry_enabled: typing.Optional[bool] = False,\n    retry_max_attempts: typing.Optional[int] = 3,\n    retry_giveup_callable: typing.Optional[\n        typing.Callable[..., bool]\n    ] = None,\n    timeout: typing.Optional[float] = 5.0,\n    verbosity: typing.Optional[int] = None,\n    raise_exceptions: typing.Optional[bool] = True,\n    encoder: typing.Optional[\n        typing.Union[str, typing.Callable]\n    ] = None,\n    decoder: typing.Optional[\n        typing.Union[str, typing.Callable]\n    ] = None,\n    hit_setter: typing.Optional[typing.Callable] = None,\n    hit_getter: typing.Optional[typing.Callable] = None,\n    cache_max_size: typing.Optional[int] = None,\n    cache_max_size_policy: typing.Optional[\n        typing.Union[str, kvdb.types.common.CachePolicy]\n    ] = kvdb.types.common.CachePolicy.LFU,\n    post_init_hook: typing.Optional[\n        typing.Union[str, typing.Callable]\n    ] = None,\n    post_call_hook: typing.Optional[\n        typing.Union[str, typing.Callable]\n    ] = None,\n    hset_enabled: typing.Optional[bool] = True,\n    silenced_stages: typing.Optional[\n        typing.List[str]\n    ] = None,\n    session: typing.Optional[\"KVDBSession\"] = None,\n    session_name: typing.Optional[str] = None,\n    session_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    **kwargs\n) -&gt; typing.Callable[\n    [kvdb.io.cachify.base.FunctionT],\n    kvdb.io.cachify.base.FunctionT,\n]\n</code></pre> <pre><code>register(\n    cache_name: typing.Optional[str] = None,\n    function: typing.Optional[\n        kvdb.io.cachify.base.FunctionT\n    ] = None,\n    **kwargs\n) -&gt; typing.Union[\n    typing.Callable[\n        [kvdb.io.cachify.base.FunctionT],\n        kvdb.io.cachify.base.FunctionT,\n    ],\n    kvdb.io.cachify.base.FunctionT,\n]\n</code></pre> <p>Registers a function for caching</p> <p>:param cache_name: The name of the cache :param function: The function to register</p> Source code in <code>kvdb/io/cachify/__init__.py</code> <pre><code>def register(\n    cache_name: Optional[str] = None,\n    function: Optional[FunctionT] = None,\n    **kwargs,\n) -&gt; Union[Callable[[FunctionT], FunctionT], FunctionT]:\n    \"\"\"\n    Registers a function for caching\n\n    :param cache_name: The name of the cache\n    :param function: The function to register\n    \"\"\"\n    from .main import CachifyManager\n    return CachifyManager.register(cache_name = cache_name, function = function, **kwargs)\n</code></pre>"},{"location":"api/cachify/api/#kvdb.io.cachify.register_object","title":"register_object","text":"<pre><code>register_object(\n    cache_name: typing.Optional[str] = None, **kwargs\n) -&gt; object\n</code></pre> <pre><code>register_object(\n    cache_name: typing.Optional[str] = None, **kwargs\n) -&gt; object\n</code></pre> <p>Registers an object for caching</p> PARAMETER DESCRIPTION <code>cache_name</code> <p>The name of the cache. Defaults to None.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>kvdb/io/cachify/__init__.py</code> <pre><code>def register_object(\n    cache_name: Optional[str] = None, \n    **kwargs,\n) -&gt; object:\n    \"\"\"\n    Registers an object for caching\n\n    Args:\n        cache_name (Optional[str], optional): The name of the cache. Defaults to None.\n\n    \"\"\"\n    from .main import CachifyManager\n    return CachifyManager.register_object(cache_name = cache_name, **kwargs)\n</code></pre>"},{"location":"api/cachify/api/#kvdb.io.cachify.register_object_method","title":"register_object_method","text":"<pre><code>register_object_method(\n    cache_name: typing.Optional[str] = None, **kwargs\n) -&gt; typing.Callable[\n    [kvdb.io.cachify.base.FunctionT],\n    kvdb.io.cachify.base.FunctionT,\n]\n</code></pre> <p>Registers an object method for caching</p> PARAMETER DESCRIPTION <code>cache_name</code> <p>The name of the cache. Defaults to None.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>kvdb/io/cachify/__init__.py</code> <pre><code>def register_object_method(\n    cache_name: Optional[str] = None, \n    **kwargs\n) -&gt; Callable[[FunctionT], FunctionT]:\n    \"\"\"\n    Registers an object method for caching\n\n    Args:\n        cache_name (Optional[str], optional): The name of the cache. Defaults to None.\n\n    \"\"\"\n    from .main import CachifyManager\n    return CachifyManager.register_object_method(cache_name = cache_name, **kwargs)\n</code></pre>"},{"location":"api/cachify/context-manager/","title":"<code>Context Manager</code>","text":"<p>The cachify context manager registers and manages all caching operations.</p> <p>The following example demonstrates usage of the <code>Cachify</code> class as a context manager.</p> context.py<pre><code>\"\"\"\nA Very basic demonstration of how to use cachify with objects using a context\n\nSimiliar to registering tasks, a context can be created to register objects or functions, where\nthe passed parameters will be used as the default parameters for all registered functions.\n\nRun this example:\n\n    # cwd: examples/caching\n    $ python context.py\n\"\"\"\n\nimport time\nimport abc\nimport asyncio\nfrom lazyops.utils.times import Timer\nfrom kvdb.io import cachify\nfrom kvdb.utils.logs import logger\n\nDEBUG_ENABLED = False\n\ncache_context = cachify.create_context(\n    cache_name='test', # Unique name for the cache. This is used to identify the cache in the cache registry\n    prefix = '_kvtest_', # Prefix for the cache key\n    ttl = 10,\n    verbosity = 2 if DEBUG_ENABLED else None,\n    cache_max_size = 15,\n)\n\n@cache_context.register_object()\nclass TestObject(abc.ABC):\n\n    def __init__(self, *args, **kwargs):\n        logger.info('running init')\n\n    @cache_context.register()\n    async def async_fibonacci(self, number: int):\n        if number == 0: return 0\n        elif number == 1: return 1\n        return await self.async_fibonacci(number - 1) + await self.async_fibonacci(number - 2)\n\n    @cache_context.register()\n    def fibonacci(self, number: int):\n        if number == 0: return 0\n        elif number == 1: return 1\n        return self.fibonacci(number - 1) + self.fibonacci(number - 2)\n\n    # No Cache Versions\n    async def async_fibonacci_nc(self, number: int):\n        if number == 0: return 0\n        elif number == 1: return 1\n        return await self.async_fibonacci_nc(number - 1) + await self.async_fibonacci_nc(number - 2)\n\n    def fibonacci_nc(self, number: int):\n        if number == 0: return 0\n        elif number == 1: return 1\n        return self.fibonacci_nc(number - 1) + self.fibonacci_nc(number - 2)\n\n\nasync def run_tests(\n    start_n: int = 1,\n    runs: int = 10,\n    print_every: int = 5,\n):\n\n    \"\"\"\n    Test that both results are the same.\n    \"\"\"\n\n    t = Timer(format_ms=True)\n    o = TestObject()\n\n    # Test Sync\n    st = Timer(format_ms=True)\n    for i in range(runs):\n        r = o.fibonacci(start_n+i)\n        d = st.duration_s\n        if i % print_every == 0:\n            logger.info(f'[Sync - {i}/{runs}] Result: {r} | Time: {d}')\n    logger.info(f'[Sync] Cache Average Time: {st.total_average_s(runs)} | Total Time: {st.total_s}')\n    logger.info(o.fibonacci.cache_info(), prefix = '[Sync] Cache Info')\n\n    # Test Async\n    at = Timer(format_ms=True)\n    for i in range(runs):\n        r = await o.async_fibonacci(start_n+i)\n        d = at.duration_s\n        if i % print_every == 0:\n            logger.info(f'[Async - {i}/{runs}] Result: {r} | Time: {d}')\n    logger.info(f'[Async] Cache Average Time: {at.total_average_s(runs)} | Total Time: {at.total_s}')\n    logger.info(await o.async_fibonacci.cache_info(), prefix = '[Async] Cache Info')\n    logger.info(t.total_s, prefix = 'Total Time')\n\n    # Clear the Cache\n    o.fibonacci.clear()\n    logger.info(o.fibonacci.cache_info(), prefix = '[Sync] Cache Info')\n\n    await o.async_fibonacci.clear()\n    logger.info(await o.async_fibonacci.cache_info(), prefix = '[Async] Cache Info')\n\n    logger.info('Testing Non-Cached Functions')\n    t = Timer(format_ms=True)\n\n    # Test Sync\n    st = Timer(format_ms=True)\n    for i in range(runs):\n        r = o.fibonacci_nc(start_n+i)\n        d = st.duration_s\n        if i % print_every == 0:\n            logger.info(f'[Sync - {i}/{runs}] Result: {r} | Time: {d}')\n    logger.info(f'[Sync] Cache Average Time: {st.total_average_s(runs)} | Total Time: {st.total_s}')\n\n    # Test Async\n    at = Timer(format_ms=True)\n    for i in range(runs):\n        r = await o.async_fibonacci_nc(start_n+i)\n        d = at.duration_s\n        if i % print_every == 0:\n            logger.info(f'[Async - {i}/{runs}] Result: {r} | Time: {d}')\n    logger.info(f'[Async] Cache Average Time: {at.total_average_s(runs)} | Total Time: {at.total_s}')\n    logger.info(t.total_s, prefix = 'Total Time')\n\n\n\nif __name__ == '__main__':\n    asyncio.run(run_tests(\n        start_n = 5,\n        runs = 40,\n        print_every = 5,\n    ))\n</code></pre>"},{"location":"api/cachify/context-manager/#api-reference","title":"API Reference","text":"<p>               Bases: <code>abc.ABC</code></p> <p>The CachifyManager handles management of the Cachify component</p> <p>Initializes the CachifyManager</p> METHOD DESCRIPTION <code>configure_classes</code> <p>Configures the classes</p> <code>create_cachify_context</code> <p>Creates a CachifyContext</p> <code>get_cachify_context</code> <p>Gets a CachifyContext</p> <code>register</code> <p>Registers a function with the CachifyManager</p> <code>register_object</code> <p>Register the underlying object</p> <code>register_object_method</code> <p>Register the underlying object</p> Source code in <code>kvdb/io/cachify/main.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"\n    Initializes the CachifyManager\n    \"\"\"\n    from kvdb.configs import settings\n    self.settings: 'KVDBSettings' = settings\n\n    self.cachify_context_class: Type[CachifyContext] = CachifyContext\n    self.cachify_contexts: Dict[str, CachifyContext] = {}\n\n    self.cachify_class: Type[Cachify] = Cachify\n    self.logger = self.settings.logger\n    self.autologger = self.settings.autologger\n</code></pre>"},{"location":"api/cachify/context-manager/#kvdb.io.cachify.main.CachifyContextManager.configure_classes","title":"configure_classes","text":"<pre><code>configure_classes(\n    cachify_context_class: typing.Optional[\n        typing.Type[kvdb.io.cachify.cache.CachifyContext]\n    ] = None,\n    cachify_class: typing.Optional[\n        typing.Type[kvdb.io.cachify.base.Cachify]\n    ] = None,\n) -&gt; None\n</code></pre> <p>Configures the classes</p> Source code in <code>kvdb/io/cachify/main.py</code> <pre><code>def configure_classes(\n    self,\n    cachify_context_class: Optional[Type[CachifyContext]] = None,\n    cachify_class: Optional[Type[Cachify]] = None,\n) -&gt; None:\n    \"\"\"\n    Configures the classes\n    \"\"\"\n    if cachify_context_class and isinstance(cachify_context_class, str):\n        cachify_context_class = lazy_import(cachify_context_class)\n    if cachify_context_class is not None:\n        self.cachify_context_class = cachify_context_class\n    if cachify_class and isinstance(cachify_class, str):\n        cachify_class = lazy_import(cachify_class)\n    if cachify_class is not None:\n        self.cachify_class = cachify_class\n</code></pre>"},{"location":"api/cachify/context-manager/#kvdb.io.cachify.main.CachifyContextManager.create_cachify_context","title":"create_cachify_context","text":"<pre><code>create_cachify_context(\n    cache_name: typing.Optional[str] = None,\n    cachify_class: typing.Optional[\n        typing.Type[\"Cachify\"]\n    ] = None,\n    cachify_context_class: typing.Optional[\n        typing.Type[kvdb.io.cachify.cache.CachifyContext]\n    ] = None,\n    session: typing.Optional[\"KVDBSession\"] = None,\n    session_name: typing.Optional[str] = None,\n    partial_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    **kwargs\n) -&gt; kvdb.io.cachify.cache.CachifyContext\n</code></pre> <p>Creates a CachifyContext</p> Source code in <code>kvdb/io/cachify/main.py</code> <pre><code>def create_cachify_context(\n    self,\n    cache_name: Optional[str] = None,\n    cachify_class: Optional[Type['Cachify']] = None,\n    cachify_context_class: Optional[Type[CachifyContext]] = None,\n    session: Optional['KVDBSession'] = None,\n    session_name: Optional[str] = None,\n    partial_kwargs: Optional[Dict[str, Any]] = None,\n    **kwargs,\n) -&gt; CachifyContext:\n    \"\"\"\n    Creates a CachifyContext\n    \"\"\"\n    cache_name = cache_name or self.default_cache_name\n    if cache_name not in self.cachify_contexts:\n        cachify_context_class = cachify_context_class or self.cachify_context_class\n        self.cachify_contexts[cache_name] = cachify_context_class(\n            cache_name = cache_name,\n            cachify_class = cachify_class or self.cachify_class,\n            session = session,\n            session_name = session_name,\n            partial_kwargs = partial_kwargs,\n            **kwargs,\n        )\n    return self.cachify_contexts[cache_name]\n</code></pre>"},{"location":"api/cachify/context-manager/#kvdb.io.cachify.main.CachifyContextManager.get_cachify_context","title":"get_cachify_context","text":"<pre><code>get_cachify_context(\n    cache_name: typing.Optional[str] = None, **kwargs\n) -&gt; kvdb.io.cachify.cache.CachifyContext\n</code></pre> <p>Gets a CachifyContext</p> Source code in <code>kvdb/io/cachify/main.py</code> <pre><code>def get_cachify_context(\n    self,\n    cache_name: Optional[str] = None,\n    **kwargs,\n) -&gt; CachifyContext:\n    \"\"\"\n    Gets a CachifyContext\n    \"\"\"\n    cache_name = cache_name or self.default_cache_name\n    if cache_name not in self.cachify_contexts:\n        self.create_cachify_context(cache_name = cache_name, **kwargs)\n    return self.cachify_contexts[cache_name]\n</code></pre>"},{"location":"api/cachify/context-manager/#kvdb.io.cachify.main.CachifyContextManager.register","title":"register","text":"<pre><code>register(\n    function: typing.Optional[\n        kvdb.io.cachify.base.FunctionT\n    ] = None,\n    cache_name: typing.Optional[str] = None,\n    ttl: typing.Optional[int] = 60 * 10,\n    ttl_kws: typing.Optional[typing.List[str]] = [\n        \"cache_ttl\"\n    ],\n    keybuilder: typing.Optional[typing.Callable] = None,\n    name: typing.Optional[\n        typing.Union[str, typing.Callable]\n    ] = None,\n    typed: typing.Optional[bool] = True,\n    exclude_keys: typing.Optional[typing.List[str]] = None,\n    exclude_null: typing.Optional[bool] = True,\n    exclude_exceptions: typing.Optional[\n        typing.Union[bool, typing.List[Exception]]\n    ] = True,\n    prefix: typing.Optional[str] = \"_kvc_\",\n    exclude_null_values_in_hash: typing.Optional[\n        bool\n    ] = None,\n    exclude_default_values_in_hash: typing.Optional[\n        bool\n    ] = None,\n    disabled: typing.Optional[\n        typing.Union[bool, typing.Callable]\n    ] = None,\n    disabled_kws: typing.Optional[typing.List[str]] = [\n        \"cache_disable\"\n    ],\n    invalidate_after: typing.Optional[\n        typing.Union[int, typing.Callable]\n    ] = None,\n    invalidate_if: typing.Optional[typing.Callable] = None,\n    invalidate_kws: typing.Optional[typing.List[str]] = [\n        \"cache_invalidate\"\n    ],\n    overwrite_if: typing.Optional[typing.Callable] = None,\n    overwrite_kws: typing.Optional[typing.List[str]] = [\n        \"cache_overwrite\"\n    ],\n    retry_enabled: typing.Optional[bool] = False,\n    retry_max_attempts: typing.Optional[int] = 3,\n    retry_giveup_callable: typing.Optional[\n        typing.Callable[..., bool]\n    ] = None,\n    timeout: typing.Optional[float] = 5.0,\n    verbosity: typing.Optional[int] = None,\n    raise_exceptions: typing.Optional[bool] = True,\n    encoder: typing.Optional[\n        typing.Union[str, typing.Callable]\n    ] = None,\n    decoder: typing.Optional[\n        typing.Union[str, typing.Callable]\n    ] = None,\n    hit_setter: typing.Optional[typing.Callable] = None,\n    hit_getter: typing.Optional[typing.Callable] = None,\n    cache_max_size: typing.Optional[int] = None,\n    cache_max_size_policy: typing.Optional[\n        typing.Union[str, kvdb.types.common.CachePolicy]\n    ] = kvdb.types.common.CachePolicy.LFU,\n    post_init_hook: typing.Optional[\n        typing.Union[str, typing.Callable]\n    ] = None,\n    post_call_hook: typing.Optional[\n        typing.Union[str, typing.Callable]\n    ] = None,\n    hset_enabled: typing.Optional[bool] = True,\n    silenced_stages: typing.Optional[\n        typing.List[str]\n    ] = None,\n    session: typing.Optional[\"KVDBSession\"] = None,\n    session_name: typing.Optional[str] = None,\n    session_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    **kwargs\n) -&gt; typing.Callable[\n    [kvdb.io.cachify.base.FunctionT],\n    kvdb.io.cachify.base.FunctionT,\n]\n</code></pre> <pre><code>register(\n    cache_name: typing.Optional[str] = None,\n    function: typing.Optional[\n        kvdb.io.cachify.base.FunctionT\n    ] = None,\n    session: typing.Optional[\"KVDBSession\"] = None,\n    session_name: typing.Optional[str] = None,\n    session_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    **kwargs\n) -&gt; typing.Callable[\n    [kvdb.io.cachify.base.FunctionT],\n    kvdb.io.cachify.base.FunctionT,\n]\n</code></pre> <p>Registers a function with the CachifyManager</p> PARAMETER DESCRIPTION <code>cache_name</code> <p>The name of the cache. Defaults to None.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>function</code> <p>The function to register. Defaults to None.</p> <p> TYPE: <code>typing.Optional[kvdb.io.cachify.base.FunctionT]</code> DEFAULT: <code>None</code> </p> <code>session</code> <p>The session to use. Defaults to None.</p> <p> TYPE: <code>typing.Optional['KVDBSession']</code> DEFAULT: <code>None</code> </p> <code>session_name</code> <p>The session name to use. Defaults to None.</p> <p> TYPE: <code>typing.Optional[str]</code> DEFAULT: <code>None</code> </p> <code>session_kwargs</code> <p>The session kwargs to use. Defaults to None.</p> <p> TYPE: <code>typing.Optional[typing.Dict[str, typing.Any]]</code> DEFAULT: <code>None</code> </p> Source code in <code>kvdb/io/cachify/main.py</code> <pre><code>def register(\n    self,\n    cache_name: Optional[str] = None,\n    function: Optional[FunctionT] = None,\n    session: Optional['KVDBSession'] = None,\n    session_name: Optional[str] = None,\n    session_kwargs: Optional[Dict[str, Any]] = None,\n    **kwargs,\n) -&gt; Callable[[FunctionT], FunctionT]:  # sourcery skip: default-mutable-arg\n    \"\"\"\n    Registers a function with the CachifyManager\n\n    Args:\n        cache_name (Optional[str], optional): The name of the cache. Defaults to None.\n        function (Optional[FunctionT], optional): The function to register. Defaults to None.\n        session (Optional['KVDBSession'], optional): The session to use. Defaults to None.\n        session_name (Optional[str], optional): The session name to use. Defaults to None.\n        session_kwargs (Optional[Dict[str, Any]], optional): The session kwargs to use. Defaults to None.\n    \"\"\"\n    cache_name = cache_name or self.default_cache_name\n    cachify_context = self.get_cachify_context(\n        cache_name = cache_name,\n        session = session,\n        session_name = session_name,\n        session_kwargs = session_kwargs,\n        partial_kwargs = kwargs,\n    )\n    return cachify_context.register(function = function, **kwargs)\n</code></pre>"},{"location":"api/cachify/context-manager/#kvdb.io.cachify.main.CachifyContextManager.register_object","title":"register_object","text":"<pre><code>register_object(\n    cache_name: typing.Optional[str] = None, **kwargs\n) -&gt; types.ModuleType\n</code></pre> <p>Register the underlying object</p> Source code in <code>kvdb/io/cachify/main.py</code> <pre><code>def register_object(\n    self, \n    cache_name: Optional[str] = None, \n    **kwargs\n) -&gt; ModuleType:\n    \"\"\"\n    Register the underlying object\n    \"\"\"\n    cache_name = cache_name or self.default_cache_name\n    cachify_context = self.get_cachify_context(cache_name=cache_name, **kwargs)\n    return cachify_context.register_object(**kwargs)\n</code></pre>"},{"location":"api/cachify/context-manager/#kvdb.io.cachify.main.CachifyContextManager.register_object_method","title":"register_object_method","text":"<pre><code>register_object_method(\n    cache_name: typing.Optional[str] = None, **kwargs\n) -&gt; types.ModuleType\n</code></pre> <p>Register the underlying object</p> Source code in <code>kvdb/io/cachify/main.py</code> <pre><code>def register_object_method(\n    self, \n    cache_name: Optional[str] = None, \n    **kwargs\n) -&gt; ModuleType:\n    \"\"\"\n    Register the underlying object\n    \"\"\"\n    cache_name = cache_name or self.default_cache_name\n    cachify_context = self.get_cachify_context(cache_name=cache_name, **kwargs)\n    return cachify_context.register_object_method(**kwargs)\n</code></pre>"},{"location":"api/cachify/context/","title":"<code>Cachify Context</code>","text":"<p>The cachify context provides a simple interface for managing caching operations. Generally speaking, unless you need to customize your cachify context, a single instance of the cachify context is sufficient for most use cases.</p>"},{"location":"api/cachify/context/#api-reference","title":"API Reference","text":"<p>               Bases: <code>abc.ABC</code></p> <p>The CacheContext is used to manage the cache context</p> <p>Initializes the CacheContext</p> METHOD DESCRIPTION <code>add_function</code> <p>Adds a function to the cachify context</p> <code>bind_session</code> <p>Binds the session</p> <code>configure_classes</code> <p>Configures the classes</p> <code>create_cachify</code> <p>Creates a cachify object</p> <code>register</code> <p>Registers a function to cachify</p> <code>register_object</code> <p>Register the underlying object</p> <code>register_object_method</code> <p>Registers an object method function to be cached</p> <code>safely</code> <p>Safely wraps the function</p> ATTRIBUTE DESCRIPTION <code>ctx</code> <p>Returns the KV Session if it is available</p> <p> TYPE: <code>typing.Optional['KVDBSession']</code> </p> <code>has_async_loop</code> <p>Checks if the current process is running in an async loop</p> <p> TYPE: <code>bool</code> </p> <code>session</code> <p>Returns the session</p> <p> TYPE: <code>'KVDBSession'</code> </p> Source code in <code>kvdb/io/cachify/cache.py</code> <pre><code>def __init__(\n    self,\n    cache_name: Optional[str] = None,\n    cachify_class: Optional[Type['Cachify']] = None,\n    session: Optional['KVDBSession'] = None,\n    session_name: Optional[str] = None,\n    partial_kwargs: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"\n    Initializes the CacheContext\n    \"\"\"\n    from kvdb.configs import settings\n\n    self.settings = settings.model_copy()\n    self.config = self.settings.cache\n    self.cache_name = cache_name\n    self._session: Optional['KVDBSession'] = session\n    self._session_name: Optional[str] = session_name\n\n    self.cachify_contexts: Dict[str, 'Cachify'] = {}\n    self.partial_kwargs = partial_kwargs or {}\n\n    self._ctx_available: Optional[bool] = None\n\n    cache_config, kwargs = self.config.extract_config_and_kwargs(**kwargs)\n    self.config.update_config(**cache_config)\n    self.configure_classes(cachify_class = cachify_class, is_init = True)\n    self.registered_cachify_object: Dict[str, Dict[str, Dict]] = {}\n    self.registered_cachify_validation_func: Dict[str, str] = {}\n    self.logger = self.settings.logger\n    self.autologger = self.settings.autologger\n    self.verbose: Optional[bool] = kwargs.get('verbose', self.settings.debug_enabled)\n    # self.has_async_loop = self.settings.is_in_async_loop()\n    self._kwargs = kwargs\n</code></pre>"},{"location":"api/cachify/context/#kvdb.io.cachify.cache.CachifyContext.ctx","title":"ctx  <code>property</code>","text":"<pre><code>ctx: typing.Optional['KVDBSession']\n</code></pre> <p>Returns the KV Session if it is available</p>"},{"location":"api/cachify/context/#kvdb.io.cachify.cache.CachifyContext.has_async_loop","title":"has_async_loop  <code>property</code>","text":"<pre><code>has_async_loop: bool\n</code></pre> <p>Checks if the current process is running in an async loop</p>"},{"location":"api/cachify/context/#kvdb.io.cachify.cache.CachifyContext.session","title":"session  <code>property</code>","text":"<pre><code>session: 'KVDBSession'\n</code></pre> <p>Returns the session</p>"},{"location":"api/cachify/context/#kvdb.io.cachify.cache.CachifyContext.add_function","title":"add_function","text":"<pre><code>add_function(\n    function: typing.Union[typing.Callable, str],\n    function_name: typing.Optional[str] = None,\n    **kwargs\n) -&gt; kvdb.io.cachify.base.Cachify\n</code></pre> <p>Adds a function to the cachify context</p> Source code in <code>kvdb/io/cachify/cache.py</code> <pre><code>def add_function(\n    self,\n    function: Union[Callable, str],\n    function_name: Optional[str] = None,\n    **kwargs\n) -&gt; Cachify:\n    \"\"\"\n    Adds a function to the cachify context\n    \"\"\"\n    cachify = self.create_cachify(\n        function_name = function_name or get_function_name(function),\n        **kwargs\n    )\n    if cachify.function_name not in self.cachify_contexts:\n        self.cachify_contexts[cachify.function_name] = cachify\n    return self.cachify_contexts[cachify.function_name]\n</code></pre>"},{"location":"api/cachify/context/#kvdb.io.cachify.cache.CachifyContext.bind_session","title":"bind_session","text":"<pre><code>bind_session(session: 'KVDBSession')\n</code></pre> <p>Binds the session</p> Source code in <code>kvdb/io/cachify/cache.py</code> <pre><code>def bind_session(self, session: 'KVDBSession'):\n    \"\"\"\n    Binds the session\n    \"\"\"\n    self._session = session\n</code></pre>"},{"location":"api/cachify/context/#kvdb.io.cachify.cache.CachifyContext.configure_classes","title":"configure_classes","text":"<pre><code>configure_classes(\n    cachify_class: typing.Optional[\n        typing.Type[\"Cachify\"]\n    ] = None,\n    is_init: typing.Optional[bool] = False,\n)\n</code></pre> <p>Configures the classes</p> Source code in <code>kvdb/io/cachify/cache.py</code> <pre><code>def configure_classes(\n    self,\n    cachify_class: Optional[Type['Cachify']] = None,\n    is_init: Optional[bool] = False,\n):\n    \"\"\"\n    Configures the classes\n    \"\"\"\n    if cachify_class is None and is_init:\n        cachify_class = Cachify\n    elif cachify_class and isinstance(cachify_class, str):\n        cachify_class = lazy_import(cachify_class)\n    if cachify_class is not None:\n        self.cachify_class = cachify_class\n</code></pre>"},{"location":"api/cachify/context/#kvdb.io.cachify.cache.CachifyContext.create_cachify","title":"create_cachify","text":"<pre><code>create_cachify(**kwargs) -&gt; 'Cachify'\n</code></pre> <p>Creates a cachify object</p> Source code in <code>kvdb/io/cachify/cache.py</code> <pre><code>def create_cachify(self, **kwargs) -&gt; 'Cachify':\n    \"\"\"\n    Creates a cachify object\n    \"\"\"\n    base_kwargs = self.config.model_dump(exclude_none=True)\n    base_kwargs.update(kwargs)\n    base_kwargs.update(self.partial_kwargs)\n    # self.logger.debug(f'Creating Cachify with kwargs: {base_kwargs}')\n    return self.cachify_class(session = self.session, settings = self.settings, **kwargs)\n</code></pre>"},{"location":"api/cachify/context/#kvdb.io.cachify.cache.CachifyContext.register","title":"register","text":"<pre><code>register(\n    function: typing.Callable[\n        kvdb.io.cachify.base.FuncP,\n        kvdb.io.cachify.base.FuncT,\n    ],\n    **kwargs\n) -&gt; typing.Union[\n    typing.Awaitable[kvdb.io.cachify.base.FuncT],\n    kvdb.io.cachify.base.FuncT,\n]\n</code></pre><pre><code>register(\n    function: typing.Callable[\n        kvdb.io.cachify.base.FuncP,\n        kvdb.io.cachify.base.FuncT,\n    ],\n    **kwargs\n) -&gt; typing.Callable[\n    kvdb.io.cachify.base.FuncP,\n    typing.Union[\n        typing.Awaitable[kvdb.io.cachify.base.FuncT],\n        kvdb.io.cachify.base.FuncT,\n    ],\n]\n</code></pre><pre><code>register(\n    function: typing.Optional[\n        typing.Union[\n            kvdb.io.cachify.base.FunctionT,\n            typing.Callable[\n                kvdb.io.cachify.base.FuncP,\n                kvdb.io.cachify.base.FuncT,\n            ],\n        ]\n    ] = None,\n    ttl: typing.Optional[int] = 60 * 10,\n    ttl_kws: typing.Optional[typing.List[str]] = [\n        \"cache_ttl\"\n    ],\n    keybuilder: typing.Optional[typing.Callable] = None,\n    name: typing.Optional[\n        typing.Union[str, typing.Callable]\n    ] = None,\n    typed: typing.Optional[bool] = True,\n    exclude_keys: typing.Optional[typing.List[str]] = None,\n    exclude_null: typing.Optional[bool] = True,\n    exclude_exceptions: typing.Optional[\n        typing.Union[bool, typing.List[Exception]]\n    ] = True,\n    exclude_if: typing.Optional[typing.Callable] = None,\n    prefix: typing.Optional[str] = \"_kvc_\",\n    exclude_null_values_in_hash: typing.Optional[\n        bool\n    ] = None,\n    exclude_default_values_in_hash: typing.Optional[\n        bool\n    ] = None,\n    disabled: typing.Optional[\n        typing.Union[bool, typing.Callable]\n    ] = None,\n    disabled_kws: typing.Optional[typing.List[str]] = [\n        \"cache_disable\"\n    ],\n    invalidate_after: typing.Optional[\n        typing.Union[int, typing.Callable]\n    ] = None,\n    invalidate_if: typing.Optional[typing.Callable] = None,\n    invalidate_kws: typing.Optional[typing.List[str]] = [\n        \"cache_invalidate\"\n    ],\n    overwrite_if: typing.Optional[typing.Callable] = None,\n    overwrite_kws: typing.Optional[typing.List[str]] = [\n        \"cache_overwrite\"\n    ],\n    retry_enabled: typing.Optional[bool] = False,\n    retry_max_attempts: typing.Optional[int] = 3,\n    retry_giveup_callable: typing.Optional[\n        typing.Callable[..., bool]\n    ] = None,\n    timeout: typing.Optional[float] = 5.0,\n    verbosity: typing.Optional[int] = None,\n    raise_exceptions: typing.Optional[bool] = True,\n    encoder: typing.Optional[\n        typing.Union[str, typing.Callable]\n    ] = None,\n    decoder: typing.Optional[\n        typing.Union[str, typing.Callable]\n    ] = None,\n    hit_setter: typing.Optional[typing.Callable] = None,\n    hit_getter: typing.Optional[typing.Callable] = None,\n    cache_max_size: typing.Optional[int] = None,\n    cache_max_size_policy: typing.Optional[\n        typing.Union[str, kvdb.types.common.CachePolicy]\n    ] = kvdb.types.common.CachePolicy.LFU,\n    post_init_hook: typing.Optional[\n        typing.Union[str, typing.Callable]\n    ] = None,\n    post_call_hook: typing.Optional[\n        typing.Union[str, typing.Callable]\n    ] = None,\n    hset_enabled: typing.Optional[bool] = True,\n    silenced_stages: typing.Optional[\n        typing.List[str]\n    ] = None,\n) -&gt; typing.Callable[\n    kvdb.io.cachify.base.FuncP,\n    typing.Union[\n        typing.Awaitable[kvdb.io.cachify.base.FuncT],\n        kvdb.io.cachify.base.FuncT,\n    ],\n]\n</code></pre> <pre><code>register(\n    function: typing.Optional[\n        kvdb.io.cachify.base.FunctionT\n    ] = None,\n    **kwargs\n) -&gt; typing.Callable[\n    [kvdb.io.cachify.base.FunctionT],\n    kvdb.io.cachify.base.FunctionT,\n]\n</code></pre> <p>Registers a function to cachify</p> Source code in <code>kvdb/io/cachify/cache.py</code> <pre><code>def register(\n    self,\n    function: Optional[FunctionT] = None,\n    **kwargs,\n) -&gt; Callable[[FunctionT], FunctionT]:\n    \"\"\"\n    Registers a function to cachify\n    \"\"\"\n    if function is not None:\n        if is_uninit_method(function):\n            return self.register_object_method(**kwargs)(function)\n        cachify = self.add_function(\n            function = function,\n            **kwargs,\n        )\n        return cachify(function)\n\n    def decorator(func: FunctionT) -&gt; Callable[..., ReturnValueT]:\n        \"\"\"\n        The decorator\n        \"\"\"\n        if is_uninit_method(func):\n            return self.register_object_method(**kwargs)(func)\n        cachify = self.add_function(\n            function = func,\n            **kwargs,\n        )\n        return cachify(func)\n    return decorator\n</code></pre>"},{"location":"api/cachify/context/#kvdb.io.cachify.cache.CachifyContext.register_object","title":"register_object","text":"<pre><code>register_object(\n    validator_function_name: typing.Optional[str] = None,\n    debug_enabled: typing.Optional[bool] = None,\n    **_kwargs\n) -&gt; types.ModuleType\n</code></pre> <p>Register the underlying object</p> Source code in <code>kvdb/io/cachify/cache.py</code> <pre><code>def register_object(\n    self, \n    validator_function_name: Optional[str] = None,\n    debug_enabled: Optional[bool] = None,\n    **_kwargs\n) -&gt; ModuleType:\n    \"\"\"\n    Register the underlying object\n    \"\"\"\n    partial_kws = {k:v for k,v in _kwargs.items() if v is not None}\n    validator_function_name = validator_function_name or 'validate_cachify'\n    autologger = logger if debug_enabled else null_logger\n\n    def object_decorator(obj: ModuleType) -&gt; ModuleType:\n        \"\"\"\n        The decorator that patches the object\n        \"\"\"\n        _obj_id = f'{obj.__module__}.{obj.__name__}'\n        autologger.info(f'Registering |g|{_obj_id}|e|', colored = True)\n        patch_object_for_kvdb(obj)\n\n        # create_register_abstract_object_subclass_function(obj)\n        if _obj_id not in self.registered_cachify_object: self.registered_cachify_object[_obj_id] = {}\n        if _obj_id not in self.registered_cachify_validation_func: self.registered_cachify_validation_func[_obj_id] = validator_function_name\n\n        if not hasattr(obj, '__cachify_init__'):\n\n            def __cachify_init__(_self, obj_id: str, *args, **kwargs):\n                \"\"\"\n                Initializes the object\n                \"\"\"\n                parent_obj_names = get_parent_object_class_names(obj, _obj_id)\n                __obj_id = f'{_self.__class__.__module__}.{_self.__class__.__name__}'\n                __obj_bases = [f'{base.__module__}.{base.__name__}' for base in _self.__class__.__bases__]\n                __obj_bases = [o for o in __obj_bases if o != __obj_id and o not in parent_obj_names]\n\n                autologger.info(f'Initializing |g|{__obj_id}|e| with bases: {__obj_bases}', colored = True)\n                autologger.info(f'Parent Objects: {parent_obj_names}, for {_obj_id}, {_self.__cachify_subcls__}', prefix = __obj_id, colored = True)\n\n                cachify_functions = {}\n\n                # Register the parent functions first\n                parent_obj_functions = self.registered_cachify_object[obj_id]\n                parent_obj_validator_func = getattr(_self, self.registered_cachify_validation_func[obj_id], None)\n                cachify_validators = {\n                    f: parent_obj_validator_func\n                    for f in parent_obj_functions\n                }\n\n                cachify_functions.update(parent_obj_functions)\n\n                # Handle Subclass level objects\n                for sub_obj_id in _self.__cachify_subcls__:\n                    if sub_obj_id not in self.registered_cachify_object: continue\n                    subcls_functions = self.registered_cachify_object[sub_obj_id]\n                    subcls_validator_func = getattr(_self, self.registered_cachify_validation_func[sub_obj_id], None)\n                    cachify_validators.update({\n                        f: subcls_validator_func\n                        for f in subcls_functions\n                    })\n                    cachify_functions.update(subcls_functions)\n\n                # Handle Base Class level objects\n                for base_obj_id in __obj_bases:\n                    if base_obj_id not in self.registered_cachify_object: continue\n                    base_obj_functions = self.registered_cachify_object[base_obj_id]\n                    base_obj_validator_func = getattr(_self, self.registered_cachify_validation_func[base_obj_id], None)\n                    cachify_validators.update({\n                        f: base_obj_validator_func\n                        for f in base_obj_functions\n                    })\n                    cachify_functions.update(base_obj_functions)\n\n                # Now we do the actual patching\n                for func, task_partial_kws in cachify_functions.items():\n                    if not hasattr(_self, func): \n                        autologger.info(f'Skipping {func} for {__obj_id}')\n                        continue\n\n                    autologger.info(f'Patching {func} for {__obj_id}')\n                    func_kws = partial_kws.copy()\n                    func_kws.update(task_partial_kws)\n\n                    if cachify_validators[func] is not None:\n                        func_kws = cachify_validators[func](func, **func_kws)\n                        if func_kws is None: continue\n\n                    if 'function_name' not in func_kws:\n                        func_kws['function_name'] = f'{_self.__class__.__name__}.{func}'\n\n                    patched_func = self.register(function = getattr(_self, func), **func_kws)\n                    setattr(_self, func, patched_func)\n\n\n            setattr(obj, '__cachify_init__', __cachify_init__)\n            setattr(obj, '__cachify_subcls__', [])\n            obj.__kvdb_initializers__.append('__cachify_init__')\n        else:\n            obj.__cachify_subcls__.append(_obj_id)\n\n        return obj\n    return object_decorator\n</code></pre>"},{"location":"api/cachify/context/#kvdb.io.cachify.cache.CachifyContext.register_object_method","title":"register_object_method","text":"<pre><code>register_object_method(\n    **kwargs,\n) -&gt; typing.Callable[\n    [kvdb.io.cachify.base.FunctionT],\n    kvdb.io.cachify.base.FunctionT,\n]\n</code></pre> <p>Registers an object method function to be cached</p> Source code in <code>kvdb/io/cachify/cache.py</code> <pre><code>def register_object_method(self, **kwargs) -&gt; Callable[[FunctionT], FunctionT]:\n    \"\"\"\n    Registers an object method function to be cached\n    \"\"\"\n    kwargs = {k:v for k,v in kwargs.items() if v is not None}\n\n    def decorator(func: FunctionT) -&gt; Callable[..., ReturnValueT]:\n        \"\"\"\n        The decorator\n        \"\"\"\n        task_obj_id = f'{func.__module__}.{func.__qualname__.split(\".\")[0]}'\n        if task_obj_id not in self.registered_cachify_object:\n            self.registered_cachify_object[task_obj_id] = {}\n        func_name = func.__name__\n        if func_name not in self.registered_cachify_object[task_obj_id]:\n            self.registered_cachify_object[task_obj_id][func_name] = kwargs\n        return func\n    return decorator\n</code></pre>"},{"location":"api/cachify/context/#kvdb.io.cachify.cache.CachifyContext.safely","title":"safely","text":"<pre><code>safely(timeout: typing.Optional[float] = 2.0)\n</code></pre> <p>Safely wraps the function</p> Source code in <code>kvdb/io/cachify/cache.py</code> <pre><code>@contextlib.contextmanager\ndef safely(self, timeout: Optional[float] = 2.0):\n    \"\"\"\n    Safely wraps the function\n    \"\"\"\n    if self.has_async_loop:\n        with anyio.move_on_after(timeout = timeout):\n            yield\n    else:\n        with timeout_ctx(timeout, raise_errors = False):\n            yield\n</code></pre>"},{"location":"api/cachify/object/","title":"<code>Cachify Object</code>","text":"<p>The cachify object is the wrapper around each individual cached function that is managed by the cachify context.</p> <p>The following example demonstrates usage of the <code>Cachify</code> class to cache objects.</p>"},{"location":"api/cachify/object/#objectspy-a-very-basic-demonstration-of-how-to-use-cachify-with-objects-without-any-arguments-cachify-will-use-the-default-settings-and-initialize-a-default-session-similiar-to-registering-functions-you-can-register-an-object-for-caching-the-objects-functions-that-are-explicitly-registered-will-be-cached-and-any-that-are-not-will-not-be-affected-run-this-example-cwd-examplescaching-python-objectspy-import-time-import-abc-import-asyncio-from-lazyopsutilstimes-import-timer-from-kvdbio-import-cachify-from-kvdbutilslogs-import-logger-debug_enabled-false-cachifyregister_object-class-testobjectabcabc-def-__init__self-args-kwargs-loggerinforunning-init-cachifyregisterttl-10-verbosity-2-if-debug_enabled-else-none-cache_max_size-15-async-def-async_fibonacciself-number-int-if-number-0-return-0-elif-number-1-return-1-return-await-selfasync_fibonaccinumber-1-await-selfasync_fibonaccinumber-2-cachifyregisterttl-10-verbosity-2-if-debug_enabled-else-none-def-fibonacciself-number-int-if-number-0-return-0-elif-number-1-return-1-return-selffibonaccinumber-1-selffibonaccinumber-2-no-cache-versions-async-def-async_fibonacci_ncself-number-int-if-number-0-return-0-elif-number-1-return-1-return-await-selfasync_fibonacci_ncnumber-1-await-selfasync_fibonacci_ncnumber-2-def-fibonacci_ncself-number-int-if-number-0-return-0-elif-number-1-return-1-return-selffibonacci_ncnumber-1-selffibonacci_ncnumber-2-async-def-run_tests-start_n-int-1-runs-int-10-print_every-int-5-test-that-both-results-are-the-same-t-timerformat_mstrue-o-testobject-test-sync-st-timerformat_mstrue-for-i-in-rangeruns-r-ofibonaccistart_ni-d-stduration_s-if-i-print_every-0-loggerinfofsync-iruns-result-r-time-d-loggerinfofsync-cache-average-time-sttotal_average_sruns-total-time-sttotal_s-loggerinfoofibonaccicache_info-prefix-sync-cache-info-test-async-at-timerformat_mstrue-for-i-in-rangeruns-r-await-oasync_fibonaccistart_ni-d-atduration_s-if-i-print_every-0-loggerinfofasync-iruns-result-r-time-d-loggerinfofasync-cache-average-time-attotal_average_sruns-total-time-attotal_s-loggerinfoawait-oasync_fibonaccicache_info-prefix-async-cache-info-loggerinfottotal_s-prefix-total-time-clear-the-cache-ofibonacciclear-loggerinfoofibonaccicache_info-prefix-sync-cache-info-await-oasync_fibonacciclear-loggerinfoawait-oasync_fibonaccicache_info-prefix-async-cache-info-loggerinfotesting-non-cached-functions-t-timerformat_mstrue-test-sync-st-timerformat_mstrue-for-i-in-rangeruns-r-ofibonacci_ncstart_ni-d-stduration_s-if-i-print_every-0-loggerinfofsync-iruns-result-r-time-d-loggerinfofsync-cache-average-time-sttotal_average_sruns-total-time-sttotal_s-test-async-at-timerformat_mstrue-for-i-in-rangeruns-r-await-oasync_fibonacci_ncstart_ni-d-atduration_s-if-i-print_every-0-loggerinfofasync-iruns-result-r-time-d-loggerinfofasync-cache-average-time-attotal_average_sruns-total-time-attotal_s-loggerinfottotal_s-prefix-total-time-if-__name__-__main__-asynciorunrun_tests-start_n-5-runs-40-print_every-5","title":"objects.py<pre><code>\"\"\"\nA Very basic demonstration of how to use cachify with objects\n\nWithout any arguments, cachify will use the default settings and initialize\na default session.\n\nSimiliar to registering functions, you can register an object for caching.\n\n- The objects functions that are explicitly registered will be cached, and any that are not\n    will not be affected.\n\nRun this example:\n\n    # cwd: examples/caching\n    $ python objects.py\n\"\"\"\n\nimport time\nimport abc\nimport asyncio\nfrom lazyops.utils.times import Timer\nfrom kvdb.io import cachify\nfrom kvdb.utils.logs import logger\n\nDEBUG_ENABLED = False\n\n@cachify.register_object()\nclass TestObject(abc.ABC):\n\n    def __init__(self, *args, **kwargs):\n        logger.info('running init')\n\n    @cachify.register(ttl = 10, verbosity = 2 if DEBUG_ENABLED else None, cache_max_size = 15)\n    async def async_fibonacci(self, number: int):\n        if number == 0: return 0\n        elif number == 1: return 1\n        return await self.async_fibonacci(number - 1) + await self.async_fibonacci(number - 2)\n\n    @cachify.register(ttl = 10, verbosity = 2 if DEBUG_ENABLED else None)\n    def fibonacci(self, number: int):\n        if number == 0: return 0\n        elif number == 1: return 1\n        return self.fibonacci(number - 1) + self.fibonacci(number - 2)\n\n    # No Cache Versions\n    async def async_fibonacci_nc(self, number: int):\n        if number == 0: return 0\n        elif number == 1: return 1\n        return await self.async_fibonacci_nc(number - 1) + await self.async_fibonacci_nc(number - 2)\n\n    def fibonacci_nc(self, number: int):\n        if number == 0: return 0\n        elif number == 1: return 1\n        return self.fibonacci_nc(number - 1) + self.fibonacci_nc(number - 2)\n\n\nasync def run_tests(\n    start_n: int = 1,\n    runs: int = 10,\n    print_every: int = 5,\n):\n\n    \"\"\"\n    Test that both results are the same.\n    \"\"\"\n\n    t = Timer(format_ms=True)\n    o = TestObject()\n\n    # Test Sync\n    st = Timer(format_ms=True)\n    for i in range(runs):\n        r = o.fibonacci(start_n+i)\n        d = st.duration_s\n        if i % print_every == 0:\n            logger.info(f'[Sync - {i}/{runs}] Result: {r} | Time: {d}')\n    logger.info(f'[Sync] Cache Average Time: {st.total_average_s(runs)} | Total Time: {st.total_s}')\n    logger.info(o.fibonacci.cache_info(), prefix = '[Sync] Cache Info')\n\n    # Test Async\n    at = Timer(format_ms=True)\n    for i in range(runs):\n        r = await o.async_fibonacci(start_n+i)\n        d = at.duration_s\n        if i % print_every == 0:\n            logger.info(f'[Async - {i}/{runs}] Result: {r} | Time: {d}')\n    logger.info(f'[Async] Cache Average Time: {at.total_average_s(runs)} | Total Time: {at.total_s}')\n    logger.info(await o.async_fibonacci.cache_info(), prefix = '[Async] Cache Info')\n    logger.info(t.total_s, prefix = 'Total Time')\n\n    # Clear the Cache\n    o.fibonacci.clear()\n    logger.info(o.fibonacci.cache_info(), prefix = '[Sync] Cache Info')\n\n    await o.async_fibonacci.clear()\n    logger.info(await o.async_fibonacci.cache_info(), prefix = '[Async] Cache Info')\n\n    logger.info('Testing Non-Cached Functions')\n    t = Timer(format_ms=True)\n\n    # Test Sync\n    st = Timer(format_ms=True)\n    for i in range(runs):\n        r = o.fibonacci_nc(start_n+i)\n        d = st.duration_s\n        if i % print_every == 0:\n            logger.info(f'[Sync - {i}/{runs}] Result: {r} | Time: {d}')\n    logger.info(f'[Sync] Cache Average Time: {st.total_average_s(runs)} | Total Time: {st.total_s}')\n\n    # Test Async\n    at = Timer(format_ms=True)\n    for i in range(runs):\n        r = await o.async_fibonacci_nc(start_n+i)\n        d = at.duration_s\n        if i % print_every == 0:\n            logger.info(f'[Async - {i}/{runs}] Result: {r} | Time: {d}')\n    logger.info(f'[Async] Cache Average Time: {at.total_average_s(runs)} | Total Time: {at.total_s}')\n    logger.info(t.total_s, prefix = 'Total Time')\n\n\n\nif __name__ == '__main__':\n    asyncio.run(run_tests(\n        start_n = 5,\n        runs = 40,\n        print_every = 5,\n    ))\n</code></pre>","text":""},{"location":"api/cachify/object/#api-reference","title":"API Reference","text":"<p>               Bases: <code>kvdb.configs.caching.KVDBCachifyConfig</code></p> <p>The Cachify Config</p> METHOD DESCRIPTION <code>__call__</code> <p>Performs the decorator</p> <code>aadd_hit</code> <p>Adds a hit to the cache</p> <code>aadd_key_expiration</code> <p>Adds an expiration to the cache key</p> <code>aadd_key_hit</code> <p>Adds a hit to the cache key</p> <code>aadd_key_timestamp</code> <p>Adds a timestamp to the cache key</p> <code>abuild_hash_key</code> <p>Builds the key for the function</p> <code>abuild_hash_name</code> <p>Builds the name for the function</p> <code>acheck_cache_policies</code> <p>Runs the cache policies</p> <code>add_hit</code> <p>Adds a hit to the cache</p> <code>add_key_expiration</code> <p>Adds an expiration to the cache key</p> <code>add_key_hit</code> <p>Adds a hit to the cache key</p> <code>add_key_timestamp</code> <p>Adds a timestamp to the cache key</p> <code>aexpire_cache_expired_keys</code> <p>Expires the cache keys</p> <code>aretrieve</code> <p>Retrieves the value from the cache</p> <code>arun_cache_operation</code> <p>Runs the cache operation</p> <code>arun_post_call_hook</code> <p>Runs the post call hook which fires after the function is called</p> <code>arun_post_init_hook</code> <p>Runs the post init hook which fires once after the function is initialized</p> <code>aset</code> <p>Sets the value in the cache</p> <code>ashould_cache_value</code> <p>Returns whether or not the value should be cached</p> <code>ashould_disable</code> <p>Returns whether or not the function should be cached</p> <code>ashould_invalidate</code> <p>Returns whether or not the function should be invalidated</p> <code>ashould_overwrite</code> <p>Returns whether or not the value should be overwritten</p> <code>avalidate_cache_policies</code> <p>Runs the cache policies</p> <code>build_hash_key</code> <p>Builds the key for the function</p> <code>build_hash_name</code> <p>Builds the name for the function</p> <code>check_cache_policies</code> <p>Runs the cache policies</p> <code>clear</code> <p>Clears the cache</p> <code>create_async_decorator</code> <p>Creates the async wrapper</p> <code>create_sync_decorator</code> <p>Creates the sync wrapper</p> <code>decode</code> <p>Decodes the value</p> <code>decode_hit</code> <p>Decodes the hit</p> <code>encode</code> <p>Encodes the value</p> <code>encode_hit</code> <p>Encodes the hit</p> <code>expire_cache_expired_keys</code> <p>Expires the cache keys</p> <code>extract_cache_kwargs</code> <p>Extracts the cache kwargs from the kwargs</p> <code>extract_config_and_kwargs</code> <p>Extract the config that are valid for this model and returns</p> <code>extract_kwargs</code> <p>Extract the kwargs that are valid for this model</p> <code>get_encoder</code> <p>Returns the encoder</p> <code>get_key</code> <p>Gets the Key</p> <code>get_serializer</code> <p>Returns the serializer</p> <code>invalidate_cache</code> <p>Invalidates the cache</p> <code>is_silenced</code> <p>Returns whether or not the stage is silenced</p> <code>model_dump</code> <p>[v1] Support for model_dump</p> <code>model_validate</code> <p>[v1] Support for model_validate</p> <code>model_validate_json</code> <p>[v1] Support for model_validate_json</p> <code>retrieve</code> <p>Retrieves the value from the cache</p> <code>run_post_call_hook</code> <p>Runs the post call hook which fires after the function is called</p> <code>run_post_init_hook</code> <p>Runs the post init hook which fires once after the function is initialized</p> <code>safely</code> <p>Safely wraps the function</p> <code>set</code> <p>Sets the value in the cache</p> <code>should_cache_value</code> <p>Returns whether or not the value should be cached</p> <code>should_disable</code> <p>Returns whether or not cache should be disabled for the function</p> <code>should_invalidate</code> <p>Returns whether or not the function should be invalidated</p> <code>should_overwrite</code> <p>Returns whether or not the value should be overwritten</p> <code>update</code> <p>Validates and updates the kwargs</p> <code>update_config</code> <p>Update the config for the other settings</p> <code>validate_attrs</code> <p>Validates the attributes</p> <code>validate_cache_policies</code> <p>Runs the cache policies</p> <code>validate_callable</code> <p>Validates the callable</p> <code>validate_is_class_method</code> <p>Validates if the function is a class method</p> <code>validate_kws</code> <p>Validates the config</p> <code>validate_serializer</code> <p>Validate the serializer config</p> <code>validateself_config</code> <p>Validates the cachify config</p> ATTRIBUTE DESCRIPTION <code>acache_expirations</code> <p>Returns the expirations of the cache</p> <p> TYPE: <code>typing.Dict[str, float]</code> </p> <code>acache_info</code> <p>Returns the info for the cache</p> <p> TYPE: <code>typing.Dict[str, typing.Any]</code> </p> <code>acache_items</code> <p>Returns the items</p> <p> TYPE: <code>typing.Dict[str, typing.Any]</code> </p> <code>acache_keyhits</code> <p>Returns the keyhits of the cache</p> <p> TYPE: <code>typing.Dict[str, int]</code> </p> <code>acache_keys</code> <p>Returns the keys</p> <p> TYPE: <code>typing.List[str]</code> </p> <code>acache_timestamps</code> <p>Returns the timestamps of the cache</p> <p> TYPE: <code>typing.Dict[str, float]</code> </p> <code>acache_values</code> <p>Returns the values</p> <p> TYPE: <code>typing.List[typing.Any]</code> </p> <code>anum_hits</code> <p>Returns the number of hits</p> <p> TYPE: <code>int</code> </p> <code>anum_keys</code> <p>Returns the number of keys</p> <p> TYPE: <code>int</code> </p> <code>cache_expirations</code> <p>Returns the expirations of the cache</p> <p> TYPE: <code>typing.Dict[str, float]</code> </p> <code>cache_info</code> <p>Returns the info for the cache</p> <p> TYPE: <code>typing.Dict[str, typing.Any]</code> </p> <code>cache_items</code> <p>Returns the items</p> <p> TYPE: <code>typing.Dict[str, typing.Any]</code> </p> <code>cache_keyhits</code> <p>Returns the keyhits of the cache</p> <p> TYPE: <code>typing.Dict[str, int]</code> </p> <code>cache_keys</code> <p>Returns the keys</p> <p> TYPE: <code>typing.List[str]</code> </p> <code>cache_timestamps</code> <p>Returns the timestamps of the cache</p> <p> TYPE: <code>typing.Dict[str, float]</code> </p> <code>cache_values</code> <p>Returns the values</p> <p> TYPE: <code>typing.List[typing.Any]</code> </p> <code>client</code> <p>Returns the client</p> <p> TYPE: <code>'ClientT'</code> </p> <code>data</code> <p>Returns the persistent data</p> <p> TYPE: <code>lzl.io.persistence.PersistentDict</code> </p> <code>has_async_loop</code> <p>Checks if the current process is running in an async loop</p> <p> TYPE: <code>bool</code> </p> <code>has_post_call_hook</code> <p>Returns whether or not there is a post call hook</p> <p> TYPE: <code>bool</code> </p> <code>has_post_init_hook</code> <p>Returns whether or not there is a post init hook</p> <p> TYPE: <code>bool</code> </p> <code>is_enabled</code> <p>Returns whether or not the cache is enabled [session is available]</p> <p> TYPE: <code>bool</code> </p> <code>num_default_keys</code> <p>Returns the number of default keys</p> <p> TYPE: <code>int</code> </p> <code>num_hits</code> <p>Returns the number of hits</p> <p> TYPE: <code>int</code> </p> <code>num_keys</code> <p>Returns the number of keys</p> <p> TYPE: <code>int</code> </p> <code>super_verbose</code> <p>Returns whether or not the cache is super verbose</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.acache_expirations","title":"acache_expirations  <code>async</code> <code>property</code>","text":"<pre><code>acache_expirations: typing.Dict[str, float]\n</code></pre> <p>Returns the expirations of the cache</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.acache_info","title":"acache_info  <code>async</code> <code>property</code>","text":"<pre><code>acache_info: typing.Dict[str, typing.Any]\n</code></pre> <p>Returns the info for the cache</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.acache_items","title":"acache_items  <code>async</code> <code>property</code>","text":"<pre><code>acache_items: typing.Dict[str, typing.Any]\n</code></pre> <p>Returns the items</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.acache_keyhits","title":"acache_keyhits  <code>async</code> <code>property</code>","text":"<pre><code>acache_keyhits: typing.Dict[str, int]\n</code></pre> <p>Returns the keyhits of the cache</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.acache_keys","title":"acache_keys  <code>async</code> <code>property</code>","text":"<pre><code>acache_keys: typing.List[str]\n</code></pre> <p>Returns the keys</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.acache_timestamps","title":"acache_timestamps  <code>async</code> <code>property</code>","text":"<pre><code>acache_timestamps: typing.Dict[str, float]\n</code></pre> <p>Returns the timestamps of the cache</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.acache_values","title":"acache_values  <code>async</code> <code>property</code>","text":"<pre><code>acache_values: typing.List[typing.Any]\n</code></pre> <p>Returns the values</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.anum_hits","title":"anum_hits  <code>async</code> <code>property</code>","text":"<pre><code>anum_hits: int\n</code></pre> <p>Returns the number of hits</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.anum_keys","title":"anum_keys  <code>async</code> <code>property</code>","text":"<pre><code>anum_keys: int\n</code></pre> <p>Returns the number of keys</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.cache_expirations","title":"cache_expirations  <code>property</code>","text":"<pre><code>cache_expirations: typing.Dict[str, float]\n</code></pre> <p>Returns the expirations of the cache</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.cache_info","title":"cache_info  <code>property</code>","text":"<pre><code>cache_info: typing.Dict[str, typing.Any]\n</code></pre> <p>Returns the info for the cache</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.cache_items","title":"cache_items  <code>property</code>","text":"<pre><code>cache_items: typing.Dict[str, typing.Any]\n</code></pre> <p>Returns the items</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.cache_keyhits","title":"cache_keyhits  <code>property</code>","text":"<pre><code>cache_keyhits: typing.Dict[str, int]\n</code></pre> <p>Returns the keyhits of the cache</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.cache_keys","title":"cache_keys  <code>property</code>","text":"<pre><code>cache_keys: typing.List[str]\n</code></pre> <p>Returns the keys</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.cache_timestamps","title":"cache_timestamps  <code>property</code>","text":"<pre><code>cache_timestamps: typing.Dict[str, float]\n</code></pre> <p>Returns the timestamps of the cache</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.cache_values","title":"cache_values  <code>property</code>","text":"<pre><code>cache_values: typing.List[typing.Any]\n</code></pre> <p>Returns the values</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.client","title":"client  <code>property</code>","text":"<pre><code>client: 'ClientT'\n</code></pre> <p>Returns the client</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.data","title":"data  <code>property</code>","text":"<pre><code>data: lzl.io.persistence.PersistentDict\n</code></pre> <p>Returns the persistent data</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.has_async_loop","title":"has_async_loop  <code>property</code>","text":"<pre><code>has_async_loop: bool\n</code></pre> <p>Checks if the current process is running in an async loop</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.has_post_call_hook","title":"has_post_call_hook  <code>property</code>","text":"<pre><code>has_post_call_hook: bool\n</code></pre> <p>Returns whether or not there is a post call hook</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.has_post_init_hook","title":"has_post_init_hook  <code>property</code>","text":"<pre><code>has_post_init_hook: bool\n</code></pre> <p>Returns whether or not there is a post init hook</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.is_enabled","title":"is_enabled  <code>property</code>","text":"<pre><code>is_enabled: bool\n</code></pre> <p>Returns whether or not the cache is enabled [session is available]</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.num_default_keys","title":"num_default_keys  <code>property</code>","text":"<pre><code>num_default_keys: int\n</code></pre> <p>Returns the number of default keys</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.num_hits","title":"num_hits  <code>property</code>","text":"<pre><code>num_hits: int\n</code></pre> <p>Returns the number of hits</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.num_keys","title":"num_keys  <code>property</code>","text":"<pre><code>num_keys: int\n</code></pre> <p>Returns the number of keys</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.super_verbose","title":"super_verbose  <code>property</code>","text":"<pre><code>super_verbose: bool\n</code></pre> <p>Returns whether or not the cache is super verbose</p>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.__call__","title":"__call__","text":"<pre><code>__call__(\n    function: typing.Callable[\n        kvdb.io.cachify.base.FuncP,\n        kvdb.io.cachify.base.FuncT,\n    ],\n) -&gt; typing.Callable[\n    kvdb.io.cachify.base.FuncP,\n    typing.Union[\n        kvdb.io.cachify.base.FuncT,\n        typing.Awaitable[kvdb.io.cachify.base.FuncT],\n    ],\n]\n</code></pre> <p>Performs the decorator</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def __call__(\n    self,\n    function: Callable[FuncP, FuncT]\n) -&gt; Callable[FuncP, Union[FuncT, Awaitable[FuncT]]]:\n#     function: FunctionT,\n# ) -&gt; Callable[..., ReturnValueT]:\n    \"\"\"\n    Performs the decorator\n    \"\"\"\n    try:\n        if not self.is_enabled: return function\n    except Exception as e:\n        logger.error(f'Error in Cachify Function {function.__name__}: {e}')\n        return function\n    if self.verbosity and self.verbosity &gt; 4:\n        logger.info(f'[{self.cache_field}] Cachifying Function: {get_function_name(function)} ({is_coro_func(function)}), {self.model_dump()}')\n    if is_coro_func(function):\n        return self.create_async_decorator(function)\n    return self.create_sync_decorator(function)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.aadd_hit","title":"aadd_hit  <code>async</code>","text":"<pre><code>aadd_hit()\n</code></pre> <p>Adds a hit to the cache</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def aadd_hit(self):\n    \"\"\"\n    Adds a hit to the cache\n    \"\"\"\n    with self.safely():\n        if not await self.data.acontains('hits'): await self.data.aset('hits', 0)\n        try:\n            self.data['hits'] += 1\n        except Exception as e:\n            await self.data.aset('hits', 1)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.aadd_key_expiration","title":"aadd_key_expiration  <code>async</code>","text":"<pre><code>aadd_key_expiration(key: str, ttl: int)\n</code></pre> <p>Adds an expiration to the cache key</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def aadd_key_expiration(self, key: str, ttl: int):\n    \"\"\"\n    Adds an expiration to the cache key\n    \"\"\"\n    if ttl is None: return\n    with self.safely():\n        if self.hset_enabled:\n            expirations = await self.data.aget('expirations', {})\n            expirations[key] = time.time() + ttl\n            await self.data.aset('expirations', expirations)\n            return\n        await self._expire(key, ttl)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.aadd_key_hit","title":"aadd_key_hit  <code>async</code>","text":"<pre><code>aadd_key_hit(key: str)\n</code></pre> <p>Adds a hit to the cache key</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def aadd_key_hit(self, key: str):\n    \"\"\"\n    Adds a hit to the cache key\n    \"\"\"\n    with self.safely():\n        key_hits = await self.data.aget('keyhits', {}) #  or {}\n        if key not in key_hits: key_hits[key] = 0\n        key_hits[key] += 1\n        await self.data.aset('keyhits', key_hits)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.aadd_key_timestamp","title":"aadd_key_timestamp  <code>async</code>","text":"<pre><code>aadd_key_timestamp(key: str)\n</code></pre> <p>Adds a timestamp to the cache key</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def aadd_key_timestamp(self, key: str):\n    \"\"\"\n    Adds a timestamp to the cache key\n    \"\"\"\n    with self.safely():\n        timestamps = await self.data.aget('timestamps', {})\n        timestamps[key] = time.time()\n        await self.data.aset('timestamps', timestamps)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.abuild_hash_key","title":"abuild_hash_key  <code>async</code>","text":"<pre><code>abuild_hash_key(*args, **kwargs) -&gt; str\n</code></pre> <p>Builds the key for the function</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def abuild_hash_key(self, *args, **kwargs) -&gt; str:\n    \"\"\"\n    Builds the key for the function\n    \"\"\"\n\n    hash_func = self.keybuilder or create_cache_key_from_kwargs\n    return await ThreadPooler.asyncish(\n        hash_func, \n        # base = self.prefix,\n        args = args, \n        kwargs = kwargs, \n        typed = self.typed, \n        exclude_keys = self.exclude_keys,\n        exclude_null = self.exclude_null_values_in_hash,\n        exclude_defaults = self.exclude_default_values_in_hash,\n        is_classmethod = self.is_class_method,\n    )\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.abuild_hash_name","title":"abuild_hash_name  <code>async</code>","text":"<pre><code>abuild_hash_name(\n    func: typing.Callable, *args, **kwargs\n) -&gt; str\n</code></pre> <p>Builds the name for the function</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def abuild_hash_name(self, func: Callable, *args, **kwargs) -&gt; str:\n    \"\"\"\n    Builds the name for the function\n    \"\"\"\n    if self.cache_field is not None: return self.cache_field\n    if self.name: self.cache_field = await ThreadPooler.asyncish(self.name, func, *args, **kwargs) if callable(self.name) else self.name\n    else: \n        self.cache_field = full_name(func)\n        if self.prefix: self.cache_field = f'{self.prefix}:{self.cache_field}'\n    return self.cache_field\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.acheck_cache_policies","title":"acheck_cache_policies  <code>async</code>","text":"<pre><code>acheck_cache_policies(\n    key: str,\n    *args,\n    cache_kwargs: typing.Dict[\n        str, typing.Union[bool, int, float, typing.Any]\n    ] = None,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Runs the cache policies</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def acheck_cache_policies(self, key: str, *args, cache_kwargs: Dict[str, Union[bool, int, float, Any]] = None, **kwargs) -&gt; None:\n    # sourcery skip: low-code-quality\n    \"\"\"\n    Runs the cache policies\n    \"\"\"\n    if await self.anum_keys &lt;= self.cache_max_size: return\n    num_keys = await self.anum_keys\n    if self.verbosity and not self.is_silenced('cache_policy'): logger.info(f'[{self.cache_field}] Cache Max Size Reached: {num_keys}/{self.cache_max_size}. Running Cache Policy: {self.cache_max_size_policy}')\n    if self.cache_max_size_policy == CachePolicy.LRU:\n        # Least Recently Used\n        timestamps = await self.data.aget('timestamps', {})\n        keys_to_delete = sorted(timestamps, key = timestamps.get, reverse=True)[:num_keys - self.cache_max_size]\n        if key in keys_to_delete: keys_to_delete.remove(key)\n        if self.verbosity and not self.is_silenced('cache_policy'): logger.info(f'[{self.cache_field} - LRU] Deleting {len(keys_to_delete)} Keys: {keys_to_delete}')\n        await self.clear(keys_to_delete)\n        return\n\n    if self.cache_max_size_policy == CachePolicy.LFU:\n        # Least Frequently Used\n        key_hits = await self.data.aget('keyhits', {})\n        keys_to_delete = sorted(key_hits, key = key_hits.get)[:num_keys - self.cache_max_size]\n        if key in keys_to_delete: keys_to_delete.remove(key)\n        if self.verbosity and not self.is_silenced('cache_policy'): logger.info(f'[{self.cache_field} - LFU] Deleting {len(keys_to_delete)} Keys: {keys_to_delete}')\n        await self.clear(keys_to_delete)\n        return\n\n    if self.cache_max_size_policy == CachePolicy.FIFO:\n        # First In First Out\n        timestamps = await self.data.aget('timestamps', {})\n        keys_to_delete = sorted(timestamps, key = timestamps.get, reverse = True)[:num_keys - self.cache_max_size]\n        if key in keys_to_delete: keys_to_delete.remove(key)\n        if self.verbosity and not self.is_silenced('cache_policy'): logger.info(f'[{self.cache_field} - FIFO] Deleting {len(keys_to_delete)} Keys: {keys_to_delete}')\n        await self.clear(keys_to_delete)\n        return\n\n    if self.cache_max_size_policy == CachePolicy.LIFO:\n        # Last In First Out\n        timestamps = await self.data.aget('timestamps', {})\n        keys_to_delete = sorted(timestamps, key = timestamps.get)[:num_keys - self.cache_max_size]\n        if key in keys_to_delete: keys_to_delete.remove(key)\n        if self.verbosity and not self.is_silenced('cache_policy'): logger.info(f'[{self.cache_field} - LIFO] Deleting {len(keys_to_delete)} Keys: {keys_to_delete}')\n        await self.clear(keys_to_delete)\n        return\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.add_hit","title":"add_hit","text":"<pre><code>add_hit()\n</code></pre> <p>Adds a hit to the cache</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def add_hit(self):\n    \"\"\"\n    Adds a hit to the cache\n    \"\"\"\n    with self.safely():\n        if not self.data.contains('hits'): self.data.set('hits', 0)\n        try:\n            self.data['hits'] += 1\n        except Exception as e:\n            self.data.set('hits', 1)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.add_key_expiration","title":"add_key_expiration","text":"<pre><code>add_key_expiration(key: str, ttl: int)\n</code></pre> <p>Adds an expiration to the cache key</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def add_key_expiration(self, key: str, ttl: int):\n    \"\"\"\n    Adds an expiration to the cache key\n    \"\"\"\n    if ttl is None: return\n    with self.safely():\n        if self.hset_enabled:\n            expirations = self.data.get('expirations', {})\n            expirations[key] = time.time() + ttl\n            self.data['expirations'] = expirations\n            return\n        self._expire(key, ttl)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.add_key_hit","title":"add_key_hit","text":"<pre><code>add_key_hit(key: str)\n</code></pre> <p>Adds a hit to the cache key</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def add_key_hit(self, key: str):\n    \"\"\"\n    Adds a hit to the cache key\n    \"\"\"\n    with self.safely():\n        key_hits = self.data.get('keyhits', {})\n        if key not in key_hits: key_hits[key] = 0\n        key_hits[key] += 1\n        self.data['keyhits'] = key_hits\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.add_key_timestamp","title":"add_key_timestamp","text":"<pre><code>add_key_timestamp(key: str)\n</code></pre> <p>Adds a timestamp to the cache key</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def add_key_timestamp(self, key: str):\n    \"\"\"\n    Adds a timestamp to the cache key\n    \"\"\"\n    with self.safely():\n        timestamps = self.data.get('timestamps', {})\n        timestamps[key] = time.time()\n        self.data['timestamps'] = timestamps\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.aexpire_cache_expired_keys","title":"aexpire_cache_expired_keys  <code>async</code>","text":"<pre><code>aexpire_cache_expired_keys()\n</code></pre> <p>Expires the cache keys</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def aexpire_cache_expired_keys(self):\n    \"\"\"\n    Expires the cache keys\n    \"\"\"\n    with self.safely():\n        expirations = await self.data.aget('expirations', {})\n        if not isinstance(expirations, dict): expirations = {}\n        to_delete = [\n            key\n            for key, expiration in expirations.items()\n            if time.time() &gt; expiration\n        ]\n        if to_delete: \n            keyhits = await self.data.aget('keyhits', {})\n            if not isinstance(keyhits, dict): keyhits = {}\n            timestamps = await self.data.aget('timestamps', {})\n            if not isinstance(timestamps, dict): timestamps = {}\n            for key in to_delete:\n                keyhits.pop(key, None)\n                timestamps.pop(key, None)\n                expirations.pop(key, None)\n            await self.data.aset('expirations', expirations)\n            await self.data.aset('keyhits', keyhits)\n            await self.data.aset('timestamps', timestamps)\n            if self.verbosity and not self.is_silenced('expire'): logger.info(f'[{self.cache_field}] Deleting {len(to_delete)} Expired Keys: {to_delete}')\n            await self.clear(to_delete)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.aretrieve","title":"aretrieve  <code>async</code>","text":"<pre><code>aretrieve(\n    key: str,\n    *args,\n    cache_kwargs: typing.Dict[\n        str, typing.Union[bool, int, float, typing.Any]\n    ] = None,\n    **kwargs\n) -&gt; typing.Any\n</code></pre> <p>Retrieves the value from the cache</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def aretrieve(self, key: str, *args, cache_kwargs: Dict[str, Union[bool, int, float, Any]] = None, **kwargs) -&gt; Any:\n    \"\"\"\n    Retrieves the value from the cache\n    \"\"\"\n    if await self.ashould_overwrite(*args, cache_kwargs = cache_kwargs, **kwargs): \n        if self.super_verbose and not self.is_silenced('cache_ovewrite', 'cache', 'retrieve'): logger.info(f'[{self.cache_field}:{key}] Overwriting Cache')\n        return ENOVAL\n    value = None\n    try:\n        with self.safely():\n            if not await self._exists(key):\n                if self.super_verbose and not self.is_silenced('cache_miss', 'cache', 'retrieve'): logger.info(f'[{self.cache_field}:{key}] Not Found')\n                return ENOVAL\n            value = await self._get(key)\n        if value is None: return ENOVAL\n\n    except TimeoutError:\n        if self.super_verbose: logger.error(f'[{self.cache_field}:{key}] Retrieve Timeout')\n        return ENOVAL\n\n    except Exception as e:\n        if self.verbosity: logger.trace(f'[{self.cache_field}:{key}] Retrieve Exception', error = e)\n        return ENOVAL\n\n    if not self.disable_background_tasks:\n        ThreadPooler.background_task(self.avalidate_cache_policies, key, *args, cache_kwargs = cache_kwargs, **kwargs)\n    else:\n        await self.avalidate_cache_policies(key, *args, cache_kwargs = cache_kwargs, **kwargs)\n    try:\n        result = self.decode_hit(value, *args, **kwargs)\n        if result is not None: return result\n    except Exception as e:\n        if self.verbosity: logger.trace(f'[{self.cache_field}:{key}] Decode Exception', error = e)\n    return ENOVAL\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.arun_cache_operation","title":"arun_cache_operation  <code>async</code>","text":"<pre><code>arun_cache_operation(\n    cache_key: str,\n    value: typing.Any,\n    *args,\n    cachify_kwargs: typing.Dict[str, typing.Any] = None,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Runs the cache operation</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def arun_cache_operation(self, cache_key: str, value: Any, *args, cachify_kwargs: Dict[str, Any] = None, **kwargs) -&gt; None:\n    \"\"\"\n    Runs the cache operation\n    \"\"\"\n    if self.disable_background_tasks:\n        return await self._arun_cache_operation(cache_key, value, *args, cachify_kwargs = cachify_kwargs, **kwargs)\n    ThreadPooler.background_task(self._arun_cache_operation, cache_key, value, *args, cachify_kwargs = cachify_kwargs, **kwargs)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.arun_post_call_hook","title":"arun_post_call_hook  <code>async</code>","text":"<pre><code>arun_post_call_hook(\n    result: typing.Any,\n    *args,\n    is_hit: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Runs the post call hook which fires after the function is called</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def arun_post_call_hook(self, result: Any, *args, is_hit: Optional[bool] = None, **kwargs) -&gt; None:\n    \"\"\"\n    Runs the post call hook which fires after the function is called\n    \"\"\"\n    if not self.has_post_call_hook: return\n    if self.super_verbose and not self.is_silenced('post_call'): logger.info(f'[{self.cache_field}] Running Post Call Hook')\n    ThreadPooler.background_task(self.post_call_hook, result, *args, is_hit = is_hit, **kwargs)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.arun_post_init_hook","title":"arun_post_init_hook  <code>async</code>","text":"<pre><code>arun_post_init_hook(\n    func: typing.Callable, *args, **kwargs\n) -&gt; None\n</code></pre> <p>Runs the post init hook which fires once after the function is initialized</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def arun_post_init_hook(self, func: Callable, *args, **kwargs) -&gt; None:\n    \"\"\"\n    Runs the post init hook which fires once after the function is initialized\n    \"\"\"\n    if not self.has_post_init_hook: return\n    if self.has_ran_post_init_hook: return\n    if self.verbosity and not self.is_silenced('post_init'): logger.info(f'[{self.cache_field}] Running Post Init Hook')\n    ThreadPooler.background_task(self.post_init_hook, func, *args, **kwargs)\n    self.has_ran_post_init_hook = True\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.aset","title":"aset  <code>async</code>","text":"<pre><code>aset(\n    key: str,\n    value: typing.Any,\n    *args,\n    cache_kwargs: typing.Dict[\n        str, typing.Union[bool, int, float, typing.Any]\n    ] = None,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Sets the value in the cache</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def aset(self, key: str, value: Any, *args, cache_kwargs: Dict[str, Union[bool, int, float, Any]] = None, **kwargs) -&gt; None:\n    \"\"\"\n    Sets the value in the cache\n    \"\"\"\n    try:\n        with self.safely():\n            await self._set(key, self.encode_hit(value, *args, **kwargs))\n            await self.aadd_key_expiration(key, (cache_kwargs.get('ttl') or self.ttl))\n    except TimeoutError:\n        if self.super_verbose: logger.error(f'[{self.cache_field}:{key}] Set Timeout')\n    except Exception as e:\n        if self.verbosity: logger.trace(f'[{self.cache_field}:{key}] Set Exception: {value}', error = e)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.ashould_cache_value","title":"ashould_cache_value  <code>async</code>","text":"<pre><code>ashould_cache_value(\n    val: typing.Any,\n    *args,\n    cache_kwargs: typing.Dict[str, typing.Any] = None,\n    **kwargs\n) -&gt; bool\n</code></pre> <p>Returns whether or not the value should be cached</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def ashould_cache_value(self, val: Any,  *args, cache_kwargs: Dict[str, Any] = None, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns whether or not the value should be cached\n    \"\"\"\n    if self.exclude_null and val is None: return False\n    if self.exclude_exceptions:\n        if isinstance(self.exclude_exceptions, list): \n            return not isinstance(val, tuple(self.exclude_exceptions))\n        if isinstance(val, Exception): return False\n    if self.exclude_kws and cache_kwargs.get('exclude') is True: return False\n    if self.exclude_if is not None: return not (await ThreadPooler.asyncish(self.exclude_if, val, *args, **kwargs))\n    return True\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.ashould_disable","title":"ashould_disable  <code>async</code>","text":"<pre><code>ashould_disable(\n    *args,\n    cache_kwargs: typing.Dict[str, typing.Any] = None,\n    **kwargs\n) -&gt; bool\n</code></pre> <p>Returns whether or not the function should be cached</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def ashould_disable(self, *args, cache_kwargs: Dict[str, Any] = None, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns whether or not the function should be cached\n    \"\"\"\n    if self.disabled is not None: self.disabled\n    if self.disabled_kws and cache_kwargs.get('disabled') is True: return True\n    return await ThreadPooler.asyncish(self.disabled, *args, **kwargs) if callable(self.disabled) else False\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.ashould_invalidate","title":"ashould_invalidate  <code>async</code>","text":"<pre><code>ashould_invalidate(\n    *args,\n    cache_kwargs: typing.Dict[str, typing.Any] = None,\n    **kwargs\n) -&gt; bool\n</code></pre> <p>Returns whether or not the function should be invalidated</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def ashould_invalidate(self, *args, cache_kwargs: Dict[str, Any] = None, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns whether or not the function should be invalidated\n    \"\"\"\n    if self.invalidate_if is not None: return await ThreadPooler.asyncish(self.invalidate_if, *args, **kwargs)\n    if self.invalidate_kws and cache_kwargs.get('invalidate') is True: return True\n    if self.invalidate_after is not None: \n        _hits = await self.anum_hits\n        if isinstance(self.invalidate_after, int):\n            return _hits is not None and _hits &gt;= self.invalidate_after\n        # if _hits and isinstance(self.invalidate_after, int):\n        #     return _hits &gt;= self.invalidate_after\n        return await ThreadPooler.asyncish(self.invalidate_after, *args, _hits = _hits, **kwargs)\n    return False\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.ashould_overwrite","title":"ashould_overwrite  <code>async</code>","text":"<pre><code>ashould_overwrite(\n    *args,\n    cache_kwargs: typing.Dict[str, typing.Any] = None,\n    **kwargs\n) -&gt; bool\n</code></pre> <p>Returns whether or not the value should be overwritten which is based on the overwrite_if function</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def ashould_overwrite(self, *args, cache_kwargs: Dict[str, Any] = None, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns whether or not the value should be overwritten\n    which is based on the overwrite_if function\n    \"\"\"\n    if self.overwrite_if is not None: \n        return await ThreadPooler.asyncish(self.overwrite_if, *args, **kwargs)\n    if self.overwrite_kws and cache_kwargs.get('overwrite') is True: return True\n    return False\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.avalidate_cache_policies","title":"avalidate_cache_policies  <code>async</code>","text":"<pre><code>avalidate_cache_policies(\n    key: str,\n    *args,\n    cache_kwargs: typing.Dict[\n        str, typing.Union[bool, int, float, typing.Any]\n    ] = None,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Runs the cache policies</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>async def avalidate_cache_policies(self, key: str, *args, cache_kwargs: Dict[str, Union[bool, int, float, Any]] = None, **kwargs) -&gt; None:\n    \"\"\"\n    Runs the cache policies\n    \"\"\"\n    await self.aadd_hit()\n    await self.aexpire_cache_expired_keys()\n    if not self.hset_enabled or self.cache_max_size is None: return\n    await self.aadd_key_timestamp(key)\n    await self.aadd_key_hit(key)\n    await self.acheck_cache_policies(key, *args, cache_kwargs = cache_kwargs, **kwargs)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.build_hash_key","title":"build_hash_key","text":"<pre><code>build_hash_key(*args, **kwargs) -&gt; str\n</code></pre> <p>Builds the key for the function</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def build_hash_key(self, *args, **kwargs) -&gt; str:\n    \"\"\"\n    Builds the key for the function\n    \"\"\"\n    hash_func = self.keybuilder or create_cache_key_from_kwargs\n    return hash_func(\n        # base = self.prefix,\n        args = args, \n        kwargs = kwargs, \n        typed = self.typed, \n        exclude_keys = self.exclude_keys,\n        exclude_null = self.exclude_null_values_in_hash,\n        exclude_defaults = self.exclude_default_values_in_hash,\n        is_classmethod = self.is_class_method,\n    )\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.build_hash_name","title":"build_hash_name","text":"<pre><code>build_hash_name(\n    func: typing.Callable, *args, **kwargs\n) -&gt; str\n</code></pre> <p>Builds the name for the function</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def build_hash_name(self, func: Callable, *args, **kwargs) -&gt; str:\n    \"\"\"\n    Builds the name for the function\n    \"\"\"\n    if self.cache_field is not None: return self.cache_field\n    if self.name: self.cache_field = self.name(func, *args, **kwargs) if callable(self.name) else self.name\n    else: \n        self.cache_field = full_name(func)\n        if self.prefix: self.cache_field = f'{self.prefix}:{self.cache_field}'\n    return self.cache_field\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.check_cache_policies","title":"check_cache_policies","text":"<pre><code>check_cache_policies(\n    key: str,\n    *args,\n    cache_kwargs: typing.Dict[\n        str, typing.Union[bool, int, float, typing.Any]\n    ] = None,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Runs the cache policies</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def check_cache_policies(self, key: str, *args, cache_kwargs: Dict[str, Union[bool, int, float, Any]] = None, **kwargs) -&gt; None:\n    # sourcery skip: low-code-quality\n    \"\"\"\n    Runs the cache policies\n    \"\"\"\n    if self.num_keys &lt;= self.cache_max_size: return\n    num_keys = self.num_keys\n    if self.verbosity and not self.is_silenced('cache_policy'): logger.info(f'[{self.cache_field}] Cache Max Size Reached: {num_keys}/{self.cache_max_size}. Running Cache Policy: {self.cache_max_size_policy}')\n    if self.cache_max_size_policy == CachePolicy.LRU:\n        # Least Recently Used\n        timestamps = self.data.get('timestamps', {})\n        keys_to_delete = sorted(timestamps, key = timestamps.get)[:num_keys - self.cache_max_size]\n        if key in keys_to_delete: keys_to_delete.remove(key)\n        if self.verbosity and not self.is_silenced('cache_policy'): logger.info(f'[{self.cache_field}- LRU] Deleting {len(keys_to_delete)} Keys: {keys_to_delete}')\n        self.clear(keys_to_delete)\n        return\n\n    if self.cache_max_size_policy == CachePolicy.LFU:\n        # Least Frequently Used\n        key_hits = self.data.get('keyhits', {})\n        keys_to_delete = sorted(key_hits, key = key_hits.get)[:num_keys - self.cache_max_size]\n        if key in keys_to_delete: keys_to_delete.remove(key)\n        if self.verbosity and not self.is_silenced('cache_policy'): logger.info(f'[{self.cache_field} - LFU] Deleting {len(keys_to_delete)} Keys: {keys_to_delete}')\n        self.clear(keys_to_delete)\n        return\n\n    if self.cache_max_size_policy == CachePolicy.FIFO:\n        # First In First Out\n        timestamps = self.data.get('timestamps', {})\n        keys_to_delete = sorted(timestamps, key = timestamps.get, reverse = True)[:num_keys - self.cache_max_size]\n        if key in keys_to_delete: keys_to_delete.remove(key)\n        if self.verbosity and not self.is_silenced('cache_policy'): logger.info(f'[{self.cache_field} - FIFO] Deleting {len(keys_to_delete)} Keys: {keys_to_delete}')\n        self.clear(keys_to_delete)\n        return\n\n    if self.cache_max_size_policy == CachePolicy.LIFO:\n        # Last In First Out\n        timestamps = self.data.get('timestamps', {})\n        keys_to_delete = sorted(timestamps, key = timestamps.get)[:num_keys - self.cache_max_size]\n        if key in keys_to_delete: keys_to_delete.remove(key)\n        if self.verbosity and not self.is_silenced('cache_policy'): logger.info(f'[{self.cache_field} - LIFO] Deleting {len(keys_to_delete)} Keys: {keys_to_delete}')\n        self.clear(keys_to_delete)\n        return\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.clear","title":"clear","text":"<pre><code>clear(\n    keys: typing.Union[str, typing.List[str]] = None,\n) -&gt; typing.Optional[int]\n</code></pre> <p>Clears the cache</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def clear(self, keys: Union[str, List[str]] = None) -&gt; Optional[int]:\n    \"\"\"\n    Clears the cache\n    \"\"\"\n    with self.safely():\n        if keys: \n            if self.hset_enabled: return self.client.hdel(self.cache_field, *keys)\n            return self.client.delete(*[self.get_key(k) for k in keys])\n        self.data.clear()\n        if self.hset_enabled: \n            return self.client.delete(self.cache_field)\n        keys = self.client.keys(self.get_key(self.cache_field, '*'))\n        return self.client.delete(*keys)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.create_async_decorator","title":"create_async_decorator","text":"<pre><code>create_async_decorator(\n    func: typing.Callable[\n        kvdb.io.cachify.base.FuncP,\n        kvdb.io.cachify.base.FuncT,\n    ],\n) -&gt; typing.Callable[\n    kvdb.io.cachify.base.FuncP,\n    typing.Awaitable[kvdb.io.cachify.base.FuncT],\n]\n</code></pre> <p>Creates the async wrapper</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def create_async_decorator(\n    self,\n    func: Callable[FuncP, FuncT]\n) -&gt; Callable[FuncP, Awaitable[FuncT]]:\n    # func: FunctionT,\n# ) -&gt; Callable[..., ReturnValueT]:\n    \"\"\"\n    Creates the async wrapper\n    \"\"\"\n    self.is_async = True\n    if self.retry_enabled:\n        _retry_func_wrapper = functools.partial(\n            backoff.on_exception,\n            backoff.expo, \n            exception = Exception, \n            giveup = self.retry_giveup_callable,\n            factor = 5,\n        )\n        func = _retry_func_wrapper(max_tries = self.retry_max_attempts + 1)(func)\n\n    _current_cache_key = None\n    _current_was_cached = False\n\n    async def is_session_available():\n        if self.session_available is None:\n            with contextlib.suppress(Exception):\n                with anyio.move_on_after(1.0):\n                    if await self.session.aping():\n                        self.session_available = True\n        return self.session_available\n\n\n\n    @functools.wraps(func)\n    async def wrapper(*args: FuncP.args, **kwargs: FuncP.kwargs) -&gt; FuncT:\n        \"\"\"\n        Inner wrapper\n        \"\"\"\n        nonlocal _current_cache_key, _current_was_cached\n        if not await is_session_available():\n            with contextlib.suppress(Exception):\n                return await timed_cache(secs = self.ttl)(func)(*args, **kwargs)\n            return await func(*args, **kwargs)\n\n        # Set the cache field\n        await self.abuild_hash_name(func, *args, **kwargs)\n        self.validate_is_class_method(func)\n        await self.arun_post_init_hook(func, *args, **kwargs)\n        cachify_kwargs, kwargs = self.extract_cache_kwargs(**kwargs)\n\n        # Check if we should disable the cache\n        if await self.ashould_disable(*args, cache_kwargs = cachify_kwargs, **kwargs):\n            if self.super_verbose and not self.is_silenced('cache_disable', 'cache'): logger.info('Disabling', prefix = self.cache_field, colored = True)\n            return await func(*args, **kwargs)\n\n        # Get the cache key\n        cache_key = await wrapper.__cache_key__(*args, **kwargs)\n        _current_cache_key = cache_key\n\n        # Check if we should invalidate\n        if await self.ashould_invalidate(*args, cache_kwargs = cachify_kwargs, **kwargs):\n            if self.verbosity and not self.is_silenced('cache_invalidate', 'cache'): logger.info('Invalidating', prefix = f'{self.cache_field}:{cache_key}', colored = True)\n            await self.invalidate_cache(cache_key)\n\n        # Check if we have a cache hit\n        value = await self.aretrieve(cache_key, *args, cache_kwargs = cachify_kwargs, **kwargs)\n        if value == ENOVAL:\n            if self.super_verbose and not self.is_silenced('cache_miss', 'cache'): logger.info('Cache Miss', prefix = f'{self.cache_field}:{cache_key}', colored = True)\n            try:\n                value = await func(*args, **kwargs)\n                await self.arun_cache_operation(cache_key, value, *args, cachify_kwargs = cachify_kwargs, **kwargs)\n                # if await self.ashould_cache_value(value, *args, cache_kwargs = cachify_kwargs, **kwargs):\n                #     if self.super_verbose and not self.is_silenced('cache_value', 'cache'): logger.info('Caching Value', prefix = f'{self.cache_field}:{cache_key}', colored = True)\n                #     await self.aset(cache_key, value, *args, cache_kwargs = cachify_kwargs, **kwargs)\n                # await self.arun_post_call_hook(value, *args, is_hit = False, **kwargs)\n                return value\n\n            except Exception as e:\n                if self.verbosity: logger.trace(f'[{self.cache_field}:{cache_key}] Exception', error = e)\n                if self.raise_exceptions and e is not None: raise e\n                return None\n\n        _current_was_cached = True\n        if self.super_verbose and not self.is_silenced('cache_hit', 'cache'): logger.info('Cache Hit', prefix = f'{self.cache_field}:{cache_key}', colored = True)\n        await self.arun_post_call_hook(value, *args, is_hit = True, **kwargs)\n        return value\n\n    async def __cache_key__(*args, **kwargs) -&gt; str:\n        \"\"\"\n        Returns the cache key\n        \"\"\"\n        return await self.abuild_hash_key(*args, **kwargs)\n\n    def is_cached() -&gt; bool:\n        \"\"\"\n        Returns whether or not the function is cached\n        \"\"\"\n        return self._exists(_current_cache_key)\n\n    def was_cached() -&gt; bool:\n        \"\"\"\n        Returns whether or not the function was cached\n        \"\"\"\n        return _current_was_cached\n\n\n    async def clear(keys: Optional[Union[str, List[str]]] = None, **kwargs) -&gt; Optional[int]:\n        \"\"\"\n        Clears the cache\n        \"\"\"\n        return await self.clear(keys = keys)\n\n    async def num_hits(*args, **kwargs) -&gt; int:\n        \"\"\"\n        Returns the number of hits\n        \"\"\"\n        return await self.anum_hits\n\n    async def num_keys(**kwargs) -&gt; int:\n        \"\"\"\n        Returns the number of keys\n        \"\"\"\n        return await self.anum_keys\n\n    async def cache_keys(**kwargs) -&gt; List[str]:\n        \"\"\"\n        Returns the keys\n        \"\"\"\n        return await self.acache_keys\n\n    async def cache_values(**kwargs) -&gt; List[Any]:\n        \"\"\"\n        Returns the values\n        \"\"\"\n        return await self.acache_values\n\n    async def cache_items(**kwargs) -&gt; Dict[str, Any]:\n        \"\"\"\n        Returns the items\n        \"\"\"\n        return await self.acache_items\n\n    async def invalidate_key(key: str, **kwargs) -&gt; int:\n        \"\"\"\n        Invalidates the cache\n        \"\"\"\n        return await self.invalidate_cache(key)\n\n    async def cache_timestamps(**kwargs) -&gt; Dict[str, float]:\n        \"\"\"\n        Returns the timestamps\n        \"\"\"\n        return await self.acache_timestamps\n\n    async def cache_keyhits(**kwargs) -&gt; Dict[str, int]:\n        \"\"\"\n        Returns the keyhits\n        \"\"\"\n        return await self.acache_keyhits\n\n    async def cache_policy(**kwargs) -&gt; Dict[str, Union[int, CachePolicy]]:\n        \"\"\"\n        Returns the cache policy\n        \"\"\"\n        return {\n            'max_size': self.cache_max_size,\n            'max_size_policy': self.cache_max_size_policy,\n        }\n\n    async def cache_config(**kwargs) -&gt; Dict[str, Any]:\n        \"\"\"\n        Returns the cache config\n        \"\"\"\n        values = self.model_dump(exclude = {'session'})\n        for k, v in values.items():\n            if callable(v): values[k] = get_function_name(v)\n        return values\n\n    async def cache_info(**kwargs) -&gt; Dict[str, Any]:\n        \"\"\"\n        Returns the info for the cache\n        \"\"\"\n        return await self.acache_info\n\n    async def cache_update(**kwargs) -&gt; Dict[str, Any]:\n        \"\"\"\n        Updates the cache config\n        \"\"\"\n        self.update(**kwargs)\n        return await cache_config(**kwargs)\n\n\n    wrapper.__cache_key__ = __cache_key__\n    wrapper.is_cached = is_cached\n    wrapper.was_cached = was_cached\n    wrapper.clear = clear\n    wrapper.num_hits = num_hits\n    wrapper.num_keys = num_keys\n    wrapper.cache_keys = cache_keys\n    wrapper.cache_values = cache_values\n    wrapper.cache_items = cache_items\n    wrapper.invalidate_key = invalidate_key\n    wrapper.cache_timestamps = cache_timestamps\n    wrapper.cache_keyhits = cache_keyhits\n    wrapper.cache_policy = cache_policy\n    wrapper.cache_config = cache_config\n    wrapper.cache_info = cache_info\n    wrapper.cache_update = cache_update\n    return wrapper\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.create_sync_decorator","title":"create_sync_decorator","text":"<pre><code>create_sync_decorator(\n    func: typing.Callable[\n        kvdb.io.cachify.base.FuncP,\n        kvdb.io.cachify.base.FuncT,\n    ],\n) -&gt; typing.Callable[\n    kvdb.io.cachify.base.FuncP, kvdb.io.cachify.base.FuncT\n]\n</code></pre> <p>Creates the sync wrapper</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def create_sync_decorator(self, func: Callable[FuncP, FuncT]) -&gt; Callable[FuncP, FuncT]:\n    \"\"\"\n    Creates the sync wrapper\n    \"\"\"\n    self.is_async = False\n    if self.retry_enabled:\n        _retry_func_wrapper = functools.partial(\n            backoff.on_exception,\n            backoff.expo, \n            exception = Exception, \n            giveup = self.retry_giveup_callable,\n            factor = 5,\n        )\n        func = _retry_func_wrapper(max_tries = self.retry_max_attempts + 1)(func)\n\n    _current_cache_key = None\n    _current_was_cached = False\n\n    def is_session_available():\n        if self.session_available is None:\n            with contextlib.suppress(Exception):\n                self.session.ping()\n                self.session_available = True\n        return self.session_available\n\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        \"\"\"\n        Inner wrapper\n        \"\"\"\n        nonlocal _current_cache_key, _current_was_cached\n\n        if not is_session_available():\n            with contextlib.suppress(Exception):\n                return timed_cache(secs = self.ttl)(func)(*args, **kwargs)\n            return func(*args, **kwargs)\n\n        # Set the cache field\n        self.build_hash_name(func, *args, **kwargs)\n        self.validate_is_class_method(func)\n        self.run_post_init_hook(func, *args, **kwargs)\n\n        cachify_kwargs, kwargs = self.extract_cache_kwargs(**kwargs)\n\n        # Check if we should disable the cache\n        if self.should_disable(*args, cache_kwargs = cachify_kwargs, **kwargs):\n            if self.super_verbose and not self.is_silenced('cache_disable', 'cache'): logger.info('Disabling', prefix = self.cache_field, colored = True)\n            return func(*args, **kwargs)\n\n        # Get the cache key\n        cache_key = wrapper.__cache_key__(*args, **kwargs)\n        _current_cache_key = cache_key\n\n\n        # Check if we should invalidate\n        if self.should_invalidate(*args, cache_kwargs = cachify_kwargs, **kwargs):\n            if self.verbosity and not self.is_silenced('cache_invalidate', 'cache'): logger.info('Invalidating', prefix = f'{self.cache_field}:{cache_key}', colored = True)\n            self.invalidate_cache(cache_key)\n\n        # Check if we have a cache hit\n        value = self.retrieve(cache_key, *args, cache_kwargs = cachify_kwargs, **kwargs)\n        if value == ENOVAL:\n            if self.super_verbose and not self.is_silenced('cache_miss', 'cache'): logger.info('Cache Miss', prefix = f'{self.cache_field}:{cache_key}', colored = True)\n            try:\n                value = func(*args, **kwargs)\n                if self.should_cache_value(value, *args, cache_kwargs = cachify_kwargs, **kwargs):\n                    if self.super_verbose and not self.is_silenced('cache_value', 'cache'): logger.info('Caching Value', prefix = f'{self.cache_field}:{cache_key}', colored = True)\n                    self.set(cache_key, value, *args, cache_kwargs = cachify_kwargs, **kwargs)\n\n                self.run_post_call_hook(value, *args, is_hit = False, **kwargs)\n                return value\n\n            except Exception as e:\n                if self.verbosity: logger.trace(f'[{self.cache_field}:{cache_key}] Exception', error = e)\n                if self.raise_exceptions and e is not None: raise e\n                return None\n        _current_was_cached = True\n        if self.super_verbose and not self.is_silenced('cache_hit', 'cache'): logger.info('Cache Hit', prefix = f'{self.cache_field}:{cache_key}', colored = True)\n        self.run_post_call_hook(value, *args, is_hit = True, **kwargs)\n        return value\n\n    def __cache_key__(*args, **kwargs) -&gt; str:\n        \"\"\"\n        Returns the cache key\n        \"\"\"\n        return self.build_hash_key(*args, **kwargs)\n\n    def is_cached() -&gt; bool:\n        \"\"\"\n        Returns whether or not the function is cached\n        \"\"\"\n        return self._exists(_current_cache_key)\n\n    def was_cached() -&gt; bool:\n        \"\"\"\n        Returns whether or not the function was cached\n        \"\"\"\n        return _current_was_cached\n\n    def clear(keys: Optional[Union[str, List[str]]] = None, **kwargs) -&gt; Optional[int]:\n        \"\"\"\n        Clears the cache\n        \"\"\"\n        return self.clear(keys = keys)\n\n    def num_hits(*args, **kwargs) -&gt; int:\n        \"\"\"\n        Returns the number of hits\n        \"\"\"\n        return self.num_hits\n\n    def num_keys(**kwargs) -&gt; int:\n        \"\"\"\n        Returns the number of keys\n        \"\"\"\n        return self.num_keys\n\n    def cache_keys(**kwargs) -&gt; List[str]:\n        \"\"\"\n        Returns the keys\n        \"\"\"\n        return self.cache_keys\n\n    def cache_values(**kwargs) -&gt; List[Any]:\n        \"\"\"\n        Returns the values\n        \"\"\"\n        return self.cache_values\n\n    def cache_items(**kwargs) -&gt; Dict[str, Any]:\n        \"\"\"\n        Returns the items\n        \"\"\"\n        return self.cache_items\n\n    def invalidate_key(key: str, **kwargs) -&gt; int:\n        \"\"\"\n        Invalidates the cache\n        \"\"\"\n        return self.invalidate_cache(key)\n\n    def cache_timestamps(**kwargs) -&gt; Dict[str, float]:\n        \"\"\"\n        Returns the timestamps\n        \"\"\"\n        return self.cache_timestamps\n\n    def cache_keyhits(**kwargs) -&gt; Dict[str, int]:\n        \"\"\"\n        Returns the keyhits\n        \"\"\"\n        return self.cache_keyhits\n\n    def cache_policy(**kwargs) -&gt; Dict[str, Union[int, CachePolicy]]:\n        \"\"\"\n        Returns the cache policy\n        \"\"\"\n        return {\n            'max_size': self.cache_max_size,\n            'max_size_policy': self.cache_max_size_policy,\n        }\n\n    def cache_config(**kwargs) -&gt; Dict[str, Any]:\n        \"\"\"\n        Returns the cache config\n        \"\"\"\n        values = self.model_dump(exclude = {'session'})\n        for k, v in values.items():\n            if callable(v): values[k] = get_function_name(v)\n        return values\n\n    def cache_info(**kwargs) -&gt; Dict[str, Any]:\n        \"\"\"\n        Returns the info for the cache\n        \"\"\"\n        return self.cache_info\n\n    def cache_update(**kwargs) -&gt; Dict[str, Any]:\n        \"\"\"\n        Updates the cache config\n        \"\"\"\n        self.update(**kwargs)\n        return cache_config(**kwargs)\n\n    wrapper.__cache_key__ = __cache_key__\n    wrapper.is_cached = is_cached\n    wrapper.was_cached = was_cached\n    wrapper.clear = clear\n    wrapper.num_hits = num_hits\n    wrapper.num_keys = num_keys\n    wrapper.cache_keys = cache_keys\n    wrapper.cache_values = cache_values\n    wrapper.cache_items = cache_items\n    wrapper.invalidate_key = invalidate_key\n    wrapper.cache_timestamps = cache_timestamps\n    wrapper.cache_keyhits = cache_keyhits\n    wrapper.cache_policy = cache_policy\n    wrapper.cache_config = cache_config\n    wrapper.cache_info = cache_info\n    wrapper.cache_update = cache_update\n    return wrapper\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.decode","title":"decode","text":"<pre><code>decode(value: bytes) -&gt; typing.Any\n</code></pre> <p>Decodes the value</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def decode(self, value: bytes) -&gt; Any:\n    \"\"\"\n    Decodes the value\n    \"\"\"\n    if self.session.session_serialization_enabled: return value\n    return self.decoder(value)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.decode_hit","title":"decode_hit","text":"<pre><code>decode_hit(value: bytes, *args, **kwargs) -&gt; typing.Any\n</code></pre> <p>Decodes the hit</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def decode_hit(self, value: bytes, *args, **kwargs) -&gt; Any:\n    \"\"\"\n    Decodes the hit\n    \"\"\"\n    value = self.decode(value)\n    if self.hit_getter is not None: \n        value = self.hit_getter(value, *args, **kwargs)\n    return value\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.encode","title":"encode","text":"<pre><code>encode(value: typing.Any) -&gt; bytes\n</code></pre> <p>Encodes the value</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def encode(self, value: Any) -&gt; bytes:\n    \"\"\"\n    Encodes the value\n    \"\"\"\n    if self.session.session_serialization_enabled: return value\n    return self.encoder(value)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.encode_hit","title":"encode_hit","text":"<pre><code>encode_hit(value: typing.Any, *args, **kwargs) -&gt; bytes\n</code></pre> <p>Encodes the hit</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def encode_hit(self, value: Any, *args, **kwargs) -&gt; bytes:\n    \"\"\"\n    Encodes the hit\n    \"\"\"\n    if self.hit_setter is not None: \n        value = self.hit_setter(value, *args, **kwargs)\n    return self.encode(value)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.expire_cache_expired_keys","title":"expire_cache_expired_keys","text":"<pre><code>expire_cache_expired_keys()\n</code></pre> <p>Expires the cache keys</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def expire_cache_expired_keys(self):  # sourcery skip: extract-method\n    \"\"\"\n    Expires the cache keys\n    \"\"\"\n    with self.safely():\n        expirations = self.data.get('expirations', {})\n        if not isinstance(expirations, dict): expirations = {}\n        to_delete = [\n            key\n            for key, expiration in expirations.items()\n            if time.time() &gt; expiration\n        ]\n        if to_delete: \n            keyhits = self.data.get('keyhits', {})\n            if not isinstance(keyhits, dict): keyhits = {}\n            timestamps = self.data.get('timestamps', {})\n            if not isinstance(timestamps, dict): timestamps = {}\n            for key in to_delete:\n                keyhits.pop(key, None)\n                timestamps.pop(key, None)\n                expirations.pop(key, None)\n            self.data['expirations'] = expirations\n            self.data['keyhits'] = keyhits\n            self.data['timestamps'] = timestamps\n            if self.verbosity and not self.is_silenced('expire'): \n                logger.info(f'[{self.cache_field}] Deleting {len(to_delete)} Expired Keys: {to_delete}')\n            self.clear(to_delete)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.extract_cache_kwargs","title":"extract_cache_kwargs","text":"<pre><code>extract_cache_kwargs(\n    **kwargs,\n) -&gt; typing.Tuple[\n    typing.Dict[\n        str, typing.Union[bool, int, float, typing.Any]\n    ],\n    typing.Dict[str, typing.Any],\n]\n</code></pre> <p>Extracts the cache kwargs from the kwargs</p> <p>Returns the cache kwargs and the remaining kwargs</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def extract_cache_kwargs(self, **kwargs) -&gt; Tuple[Dict[str, Union[bool, int, float, Any]], Dict[str, Any]]:\n    \"\"\"\n    Extracts the cache kwargs from the kwargs\n\n    Returns the cache kwargs and the remaining kwargs\n    \"\"\"\n    cache_kwargs = {}\n    if self.disabled_kws:\n        for kw in self.disabled_kws:\n            if kw in kwargs:\n                cache_kwargs['disabled'] = kwargs.pop(kw)\n                break\n    if self.invalidate_kws:\n        for kw in self.invalidate_kws:\n            if kw in kwargs:\n                cache_kwargs['invalidate'] = kwargs.pop(kw)\n                break\n    if self.overwrite_kws:\n        for kw in self.overwrite_kws:\n            if kw in kwargs:\n                cache_kwargs['overwrite'] = kwargs.pop(kw)\n                break\n    if self.ttl_kws:\n        for kw in self.ttl_kws:\n            if kw in kwargs:\n                cache_kwargs['ttl'] = kwargs.pop(kw)\n                break\n    if self.exclude_kws:\n        for kw in self.exclude_kws:\n            if kw in kwargs:\n                cache_kwargs['exclude'] = kwargs.pop(kw)\n                break\n    return cache_kwargs, kwargs\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.extract_config_and_kwargs","title":"extract_config_and_kwargs  <code>classmethod</code>","text":"<pre><code>extract_config_and_kwargs(\n    _prefix: typing.Optional[str] = None,\n    _include_prefix: typing.Optional[bool] = None,\n    _include: typing.Optional[set[str]] = None,\n    _exclude: typing.Optional[set[str]] = None,\n    _exclude_none: typing.Optional[bool] = True,\n    **kwargs\n) -&gt; typing.Tuple[\n    typing.Dict[str, typing.Any],\n    typing.Dict[str, typing.Any],\n]\n</code></pre> <p>Extract the config that are valid for this model and returns the config and kwargs</p> RETURNS DESCRIPTION <code>typing.Tuple[typing.Dict[str, typing.Any], typing.Dict[str, typing.Any]]</code> <p>Tuple[Dict[str, Any], Dict[str, Any]]: The config and deduplicated kwargs</p> Source code in <code>kvdb/types/base.py</code> <pre><code>@classmethod\ndef extract_config_and_kwargs(\n    cls,\n    _prefix: Optional[str] = None,\n    _include_prefix: Optional[bool] = None,\n    _include: Optional[set[str]] = None,\n    _exclude: Optional[set[str]] = None,\n    _exclude_none: Optional[bool] = True,\n    **kwargs\n) -&gt; Tuple[Dict[str, Any], Dict[str, Any]]:\n    \"\"\"\n    Extract the config that are valid for this model and returns\n    the config and kwargs\n\n    Returns:\n        Tuple[Dict[str, Any], Dict[str, Any]]: The config and deduplicated kwargs\n    \"\"\"\n    config = cls.extract_kwargs(\n        _prefix = _prefix,\n        _include_prefix = _include_prefix,\n        _include = _include,\n        _exclude = _exclude,\n        _exclude_none = _exclude_none,\n        **kwargs\n    )\n    kwargs = {k: v for k, v in kwargs.items() if k not in config}\n    if _prefix: kwargs = {k: v for k, v in kwargs.items() if f'{_prefix}{k}' not in config}\n    return config, kwargs\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.extract_kwargs","title":"extract_kwargs  <code>classmethod</code>","text":"<pre><code>extract_kwargs(\n    _prefix: typing.Optional[str] = None,\n    _include_prefix: typing.Optional[bool] = None,\n    _include: typing.Optional[set[str]] = None,\n    _exclude: typing.Optional[set[str]] = None,\n    _exclude_none: typing.Optional[bool] = True,\n    **kwargs\n) -&gt; typing.Dict[str, typing.Any]\n</code></pre> <p>Extract the kwargs that are valid for this model</p> Source code in <code>kvdb/types/base.py</code> <pre><code>@classmethod\ndef extract_kwargs(\n    cls, \n    _prefix: Optional[str] = None,\n    _include_prefix: Optional[bool] = None,\n    _include: Optional[set[str]] = None,\n    _exclude: Optional[set[str]] = None,\n    _exclude_none: Optional[bool] = True,\n    **kwargs\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Extract the kwargs that are valid for this model\n    \"\"\"\n    if _prefix:\n        _kwargs = {(k if _include_prefix else k.replace(_prefix, '')): v for k, v in kwargs.items() if k.startswith(_prefix) and k.replace(_prefix, '') in cls.__fields__}\n    else:\n        _kwargs = {k: v for k, v in kwargs.items() if k in cls.__fields__}\n    if _exclude_none: _kwargs = {k: v for k, v in _kwargs.items() if v is not None}\n    if _include is not None: \n        _extra_kwargs = {k: v for k, v in _kwargs.items() if k in _include}\n        _kwargs.update(_extra_kwargs)\n    if _exclude is not None: _kwargs = {k: v for k, v in _kwargs.items() if k not in _exclude}\n    return _kwargs\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.get_encoder","title":"get_encoder","text":"<pre><code>get_encoder(\n    serializer: typing.Optional[str] = None,\n    serializer_enabled: typing.Optional[bool] = True,\n    serializer_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    compression: typing.Optional[str] = None,\n    compression_level: typing.Optional[int] = None,\n    raise_errors: typing.Optional[bool] = False,\n    encoding: typing.Optional[str] = None,\n    decode_responses: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; \"Encoder\"\n</code></pre> <p>Returns the encoder</p> Source code in <code>kvdb/configs/base.py</code> <pre><code>def get_encoder(\n    self,\n    serializer: Optional[str] = None,\n    serializer_enabled: Optional[bool] = True,\n    serializer_kwargs: Optional[Dict[str, Any]] = None,\n    compression: Optional[str] = None,\n    compression_level: Optional[int] = None,\n    raise_errors: Optional[bool] = False,\n    encoding: Optional[str] = None,\n    decode_responses: Optional[bool] = None,\n    **kwargs\n) -&gt; 'Encoder':\n    \"\"\"\n    Returns the encoder\n    \"\"\"\n    _serializer = self.get_serializer(\n        serializer = serializer,\n        serializer_kwargs = serializer_kwargs,\n        compression = compression,\n        compression_level = compression_level,\n        raise_errors = raise_errors,\n        encoding = encoding,\n        **kwargs\n    ) if serializer_enabled else None\n    from kvdb.io.encoder import Encoder\n    encoding = self.encoding if encoding is None else encoding\n    decode_responses = self.decode_responses if decode_responses is None else decode_responses\n    return Encoder(\n        encoding = encoding,\n        serializer = _serializer,\n        decode_responses = decode_responses,\n    )\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.get_key","title":"get_key","text":"<pre><code>get_key(key: str) -&gt; str\n</code></pre> <p>Gets the Key</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def get_key(self, key: str) -&gt; str:\n    \"\"\"\n    Gets the Key\n    \"\"\"\n    return key if self.hset_enabled else f'{self.cache_field}:{key}'\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.get_serializer","title":"get_serializer","text":"<pre><code>get_serializer(\n    serializer: typing.Optional[str] = None,\n    serializer_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    compression: typing.Optional[str] = None,\n    compression_level: typing.Optional[int] = None,\n    raise_errors: typing.Optional[bool] = False,\n    encoding: typing.Optional[str] = None,\n    **kwargs\n) -&gt; \"SerializerT\"\n</code></pre> <p>Returns the serializer</p> Source code in <code>kvdb/configs/base.py</code> <pre><code>def get_serializer(\n    self,\n    serializer: Optional[str] = None,\n    serializer_kwargs: Optional[Dict[str, Any]] = None,\n    compression: Optional[str] = None,\n    compression_level: Optional[int] = None,\n    raise_errors: Optional[bool] = False,\n    encoding: Optional[str] = None,\n    **kwargs\n) -&gt; 'SerializerT':\n    \"\"\"\n    Returns the serializer\n    \"\"\"\n    from kvdb.io.serializers import get_serializer\n    serializer = self.serializer if serializer is None else serializer\n    serializer_kwargs = self.serializer_kwargs if serializer_kwargs is None else serializer_kwargs\n    if 'compression' in serializer_kwargs:\n        compression = serializer_kwargs.pop('compression')\n    if 'compression_level' in serializer_kwargs:\n        compression_level = serializer_kwargs.pop('compression_level')\n    compression = self.compression if compression is None else compression\n    compression_level = self.compression_level if compression_level is None else compression_level\n    encoding = self.encoding if encoding is None else encoding\n    if serializer is None:\n        return None\n    return get_serializer(\n        serializer = serializer,\n        serializer_kwargs = serializer_kwargs,\n        compression = compression,\n        compression_level = compression_level,\n        encoding = encoding,\n        raise_errors = raise_errors,\n        **kwargs\n    )\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.invalidate_cache","title":"invalidate_cache","text":"<pre><code>invalidate_cache(key: str) -&gt; int\n</code></pre> <p>Invalidates the cache</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def invalidate_cache(self, key: str) -&gt; int:\n    \"\"\"\n    Invalidates the cache\n    \"\"\"\n    with self.safely():\n        if key in self.cache_keyhits:\n            _ = self.data['keyhits'].pop(key, None)\n        if key in self.cache_timestamps:\n            _ = self.data['timestamps'].pop(key, None)\n        if key in self.cache_expirations:\n            _ = self.data['expirations'].pop(key, None)\n        self.data.flush()\n        return self._delete(key)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.is_silenced","title":"is_silenced","text":"<pre><code>is_silenced(*stages: str) -&gt; bool\n</code></pre> <p>Returns whether or not the stage is silenced</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def is_silenced(self, *stages: str) -&gt; bool:\n    \"\"\"\n    Returns whether or not the stage is silenced\n    \"\"\"\n    if not self.silenced_stages: return False\n    return any(stage in self.silenced_stages for stage in stages)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.model_dump","title":"model_dump","text":"<pre><code>model_dump(\n    *,\n    mode: str = \"python\",\n    include: (\n        set[int]\n        | set[str]\n        | dict[int, typing.Any]\n        | dict[str, typing.Any]\n        | None\n    ) = None,\n    exclude: (\n        set[int]\n        | set[str]\n        | dict[int, typing.Any]\n        | dict[str, typing.Any]\n        | None\n    ) = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    round_trip: bool = False,\n    warnings: bool = True\n) -&gt; typing.Dict[str, typing.Any]\n</code></pre> <p>[v1] Support for model_dump</p> Source code in <code>kvdb/types/base.py</code> <pre><code>def model_dump(self, *, mode: str = 'python', include: set[int] | set[str] | dict[int, Any] | dict[str, Any] | None = None, exclude: set[int] | set[str] | dict[int, Any] | dict[str, Any] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool = True) -&gt; Dict[str, Any]:\n    \"\"\"\n    [v1] Support for model_dump\n    \"\"\"\n    return self.dict(\n        include = include,\n        exclude = exclude,\n        by_alias = by_alias,\n        exclude_unset = exclude_unset,\n        exclude_defaults = exclude_defaults,\n        exclude_none = exclude_none,\n\n    )\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(\n    value: typing.Any, *args, **kwargs\n) -&gt; \"BaseModel\"\n</code></pre> <p>[v1] Support for model_validate</p> Source code in <code>kvdb/types/base.py</code> <pre><code>@classmethod\ndef model_validate(cls: type['BaseModel'], value: Any, *args, **kwargs) -&gt; 'BaseModel':\n    \"\"\"\n    [v1] Support for model_validate\n    \"\"\"\n    return cls.parse_obj(value)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(\n    value: typing.Any, *args, **kwargs\n) -&gt; \"BaseModel\"\n</code></pre> <p>[v1] Support for model_validate_json</p> Source code in <code>kvdb/types/base.py</code> <pre><code>@classmethod\ndef model_validate_json(cls: type['BaseModel'], value: Any, *args, **kwargs) -&gt; 'BaseModel':\n    \"\"\"\n    [v1] Support for model_validate_json\n    \"\"\"\n    return cls.parse_raw(value)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.retrieve","title":"retrieve","text":"<pre><code>retrieve(\n    key: str,\n    *args,\n    cache_kwargs: typing.Dict[\n        str, typing.Union[bool, int, float, typing.Any]\n    ] = None,\n    **kwargs\n) -&gt; typing.Any\n</code></pre> <p>Retrieves the value from the cache</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def retrieve(self, key: str, *args, cache_kwargs: Dict[str, Union[bool, int, float, Any]] = None, **kwargs) -&gt; Any:\n    \"\"\"\n    Retrieves the value from the cache\n    \"\"\"\n    if self.should_overwrite(*args, cache_kwargs = cache_kwargs, **kwargs): \n        if self.super_verbose and not self.is_silenced('cache_overwrite', 'cache', 'retrieve'): logger.info(f'[{self.cache_field}:{key}] Overwriting Cache')\n        return ENOVAL\n    value = None\n    try:\n        with self.safely():\n            if not self._exists(key):\n                if self.super_verbose and not self.is_silenced('cache_miss', 'cache', 'retrieve'): logger.info(f'[{self.cache_field}:{key}] Not Found')\n                return ENOVAL\n            value = self._get(key)\n        if value is None: return ENOVAL\n\n    except TimeoutError:\n        if self.super_verbose and not self.is_silenced('retrieve'): logger.error(f'[{self.cache_field}:{key}] Retrieve Timeout')\n        return ENOVAL\n\n    except Exception as e:\n        if self.verbosity: logger.trace(f'[{self.cache_field}:{key}] Retrieve Exception', error = e)\n        return ENOVAL\n\n    # ThreadPooler.threadpool_task(self.validate_cache_policies, key, *args, cache_kwargs = cache_kwargs, **kwargs)\n    self.validate_cache_policies(key, *args, cache_kwargs = cache_kwargs, **kwargs)\n    try:\n        result = self.decode_hit(value, *args, **kwargs)\n        if result is not None: return result\n    except Exception as e:\n        if self.verbosity: logger.trace(f'[{self.cache_field}:{key}] Decode Exception', error = e)\n    return ENOVAL\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.run_post_call_hook","title":"run_post_call_hook","text":"<pre><code>run_post_call_hook(\n    result: typing.Any,\n    *args,\n    is_hit: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Runs the post call hook which fires after the function is called</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def run_post_call_hook(self, result: Any, *args, is_hit: Optional[bool] = None, **kwargs) -&gt; None:\n    \"\"\"\n    Runs the post call hook which fires after the function is called\n    \"\"\"\n    if not self.has_post_call_hook: return\n    if self.super_verbose and not self.is_silenced('post_call'): logger.info(f'[{self.cache_field}] Running Post Call Hook')\n    self.post_call_hook(result, *args, is_hit = is_hit, **kwargs)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.run_post_init_hook","title":"run_post_init_hook","text":"<pre><code>run_post_init_hook(\n    func: typing.Callable, *args, **kwargs\n) -&gt; None\n</code></pre> <p>Runs the post init hook which fires once after the function is initialized</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def run_post_init_hook(self, func: Callable, *args, **kwargs) -&gt; None:\n    \"\"\"\n    Runs the post init hook which fires once after the function is initialized\n    \"\"\"\n    if not self.has_post_init_hook: return\n    if self.has_ran_post_init_hook: return\n    if self.verbosity and not self.is_silenced('post_init'): logger.info(f'[{self.cache_field}] Running Post Init Hook')\n    # ThreadPooler.threadpool_task(self.post_init_hook, func, *args, **kwargs)\n    self.post_init_hook(func, *args, **kwargs)\n    self.has_ran_post_init_hook = True\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.safely","title":"safely","text":"<pre><code>safely()\n</code></pre> <p>Safely wraps the function</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>@contextlib.contextmanager\ndef safely(self):\n    \"\"\"\n    Safely wraps the function\n    \"\"\"\n    if is_in_ci_env():\n        logger.warning('Currently in CI/CD - Will Fail Quickly')\n        with anyio.move_on_after(1):\n            yield\n\n    if self.is_async and self.has_async_loop:\n        with anyio.move_on_after(self.timeout):\n            yield\n    else:\n        with timeout(int(self.timeout), raise_errors = False):\n            yield\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.set","title":"set","text":"<pre><code>set(\n    key: str,\n    value: typing.Any,\n    *args,\n    cache_kwargs: typing.Dict[\n        str, typing.Union[bool, int, float, typing.Any]\n    ] = None,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Sets the value in the cache</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def set(self, key: str, value: Any, *args, cache_kwargs: Dict[str, Union[bool, int, float, Any]] = None, **kwargs) -&gt; None:\n    \"\"\"\n    Sets the value in the cache\n    \"\"\"\n    try:\n        with self.safely():\n            self._set(key, self.encode_hit(value, *args, **kwargs))\n            self.add_key_expiration(key, (cache_kwargs.get('ttl') or self.ttl))\n    except TimeoutError:\n        if self.super_verbose: logger.error(f'[{self.cache_field}:{key}] Set Timeout')\n    except Exception as e:\n        if self.verbosity: logger.trace(f'[{self.cache_field}:{key}] Set Exception: {value}', error = e)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.should_cache_value","title":"should_cache_value","text":"<pre><code>should_cache_value(\n    val: typing.Any,\n    *args,\n    cache_kwargs: typing.Dict[str, typing.Any] = None,\n    **kwargs\n) -&gt; bool\n</code></pre> <p>Returns whether or not the value should be cached</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def should_cache_value(self, val: Any, *args, cache_kwargs: Dict[str, Any] = None, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns whether or not the value should be cached\n    \"\"\"\n    if self.exclude_null and val is None: return False\n    if self.exclude_exceptions:\n        if isinstance(self.exclude_exceptions, list): \n            return not isinstance(val, tuple(self.exclude_exceptions))\n        if isinstance(val, Exception): return False\n    if self.exclude_kws and cache_kwargs.get('exclude') is True: return False\n    if self.exclude_if is not None: return not self.exclude_if(val, *args, **kwargs)\n    return True\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.should_disable","title":"should_disable","text":"<pre><code>should_disable(\n    *args,\n    cache_kwargs: typing.Dict[str, typing.Any] = None,\n    **kwargs\n) -&gt; bool\n</code></pre> <p>Returns whether or not cache should be disabled for the function</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def should_disable(self, *args, cache_kwargs: Dict[str, Any] = None, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns whether or not cache should be disabled for the function\n    \"\"\"\n    if self.disabled is not None: self.disabled\n    if self.disabled_kws and cache_kwargs.get('disabled') is True: return True\n    return self.disabled(*args, **kwargs) if callable(self.disabled) else False\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.should_invalidate","title":"should_invalidate","text":"<pre><code>should_invalidate(\n    *args,\n    _hits: typing.Optional[int] = None,\n    cache_kwargs: typing.Dict[str, typing.Any] = None,\n    **kwargs\n) -&gt; bool\n</code></pre> <p>Returns whether or not the function should be invalidated</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def should_invalidate(self, *args, _hits: Optional[int] = None, cache_kwargs: Dict[str, Any] = None, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns whether or not the function should be invalidated\n    \"\"\"\n    if self.invalidate_if is not None: return self.invalidate_if(*args, **kwargs)\n    if self.invalidate_kws and cache_kwargs.get('invalidate') is True: return True\n    if self.invalidate_after is not None: \n        if isinstance(self.invalidate_after, int):\n            return _hits is not None and _hits &gt;= self.invalidate_after\n        # if _hits and isinstance(self.invalidate_after, int):\n        #     return _hits &gt;= self.invalidate_after\n        return self.invalidate_after(*args, _hits = _hits, **kwargs)\n    return False\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.should_overwrite","title":"should_overwrite","text":"<pre><code>should_overwrite(\n    *args,\n    cache_kwargs: typing.Dict[str, typing.Any] = None,\n    **kwargs\n) -&gt; bool\n</code></pre> <p>Returns whether or not the value should be overwritten which is based on the overwrite_if function</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def should_overwrite(self, *args, cache_kwargs: Dict[str, Any] = None, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns whether or not the value should be overwritten\n    which is based on the overwrite_if function\n    \"\"\"\n    if self.overwrite_if is not None: return self.overwrite_if(*args, **kwargs)\n    if self.overwrite_kws and cache_kwargs.get('overwrite') is True: return True\n    return False\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.update","title":"update","text":"<pre><code>update(**kwargs)\n</code></pre> <p>Validates and updates the kwargs</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def update(self, **kwargs):\n    \"\"\"\n    Validates and updates the kwargs\n    \"\"\"\n    kwargs = self.validate_kws(kwargs, is_update = True)\n    for k, v in kwargs.items():\n        if not hasattr(self, k): continue\n        setattr(self, k, v)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.update_config","title":"update_config","text":"<pre><code>update_config(**kwargs)\n</code></pre> <p>Update the config for the other settings</p> Source code in <code>kvdb/types/base.py</code> <pre><code>def update_config(self, **kwargs):\n    \"\"\"\n    Update the config for the other settings\n    \"\"\"\n    for k, v in kwargs.items():\n        if not hasattr(self, k): continue\n        if isinstance(getattr(self, k), BaseModel):\n            val: 'BaseModel' = getattr(self, k)\n            if hasattr(val, 'update_config'):\n                val.update_config(**v)\n            else: val = val.__class__(**v)\n            setattr(self, k, val)\n        else:  setattr(self, k, v)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.validate_attrs","title":"validate_attrs","text":"<pre><code>validate_attrs(\n    values: typing.Dict[str, typing.Any],\n) -&gt; typing.Dict[str, typing.Any]\n</code></pre> <p>Validates the attributes</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>@root_validator(pre = True)\ndef validate_attrs(cls, values: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Validates the attributes\n    \"\"\"\n    return cls.validate_kws(values)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.validate_cache_policies","title":"validate_cache_policies","text":"<pre><code>validate_cache_policies(\n    key: str,\n    *args,\n    cache_kwargs: typing.Dict[\n        str, typing.Union[bool, int, float, typing.Any]\n    ] = None,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Runs the cache policies</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def validate_cache_policies(self, key: str, *args, cache_kwargs: Dict[str, Union[bool, int, float, Any]] = None, **kwargs) -&gt; None:\n    \"\"\"\n    Runs the cache policies\n    \"\"\"\n    self.add_hit()\n    self.expire_cache_expired_keys()\n    if not self.hset_enabled or self.cache_max_size is None: return\n    self.add_key_hit(key)\n    self.add_key_timestamp(key)\n    self.check_cache_policies(key, *args, cache_kwargs = cache_kwargs, **kwargs)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.validate_callable","title":"validate_callable  <code>classmethod</code>","text":"<pre><code>validate_callable(\n    v: typing.Optional[\n        typing.Union[str, int, typing.Callable]\n    ],\n) -&gt; typing.Optional[\n    typing.Union[typing.Callable, typing.Any]\n]\n</code></pre> <p>Validates the callable</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>@classmethod\ndef validate_callable(cls, v: Optional[Union[str, int, Callable]]) -&gt; Optional[Union[Callable, Any]]:\n    \"\"\"\n    Validates the callable\n    \"\"\"\n    return lazy_import(v) if isinstance(v, str) else v\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.validate_is_class_method","title":"validate_is_class_method","text":"<pre><code>validate_is_class_method(func: typing.Callable)\n</code></pre> <p>Validates if the function is a class method</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>def validate_is_class_method(self, func: Callable):\n    \"\"\"\n    Validates if the function is a class method\n    \"\"\"\n    if self.is_class_method is not None: return\n    self.is_class_method = hasattr(func, '__class__') and inspect.isclass(func.__class__) and is_classmethod(func)\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.validate_kws","title":"validate_kws  <code>classmethod</code>","text":"<pre><code>validate_kws(\n    values: typing.Dict[str, typing.Any],\n    is_update: typing.Optional[bool] = None,\n) -&gt; typing.Dict[str, typing.Any]\n</code></pre> <p>Validates the config</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>@classmethod\ndef validate_kws(cls, values: Dict[str, Any], is_update: Optional[bool] = None) -&gt; Dict[str, Any]:\n    \"\"\"\n    Validates the config\n    \"\"\"\n    _validated_serializer = False\n    if 'serializer' in values:\n        serializer = values.pop('serializer')\n        from kvdb.io.serializers import get_serializer, BaseSerializer\n        if isinstance(serializer, str):\n            serializer_kwargs = values.pop('serializer_kwargs', {})\n            if 'compression' not in serializer_kwargs:\n                serializer_kwargs['compression'] = values.pop('compression', None)\n            if 'compression_level' not in serializer_kwargs:\n                serializer_kwargs['compression_level'] = values.pop('compression_level', None)\n            serializer = get_serializer(serializer, **serializer_kwargs)\n        if not isinstance(serializer, BaseSerializer):\n            raise ValueError('`serializer` must be an instance of `BaseSerializer`')\n        values['encoder'] = serializer.dumps\n        values['decoder'] = serializer.loads\n        _validated_serializer = True\n\n    for key in {\n        'name',\n        'keybuilder',\n        'encoder',\n        'decoder',\n        'hit_setter',\n        'hit_getter',\n        'disabled',\n        'invalidate_if',\n        'invalidate_after',\n        'overwrite_if',\n        'exclude_if',\n        # 'bypass_if',\n        'post_init_hook',\n        'post_call_hook',\n    }:\n        if key in values:\n            try:\n                values[key] = cls.validate_callable(values[key])\n            except Exception as e:\n                if key in {'name'}: continue\n                raise e\n            if key in {'encoder', 'decoder'}:\n                if _validated_serializer: continue\n                # if not inspect.isfunction(values[key]):\n                if not callable(values[key]):\n                    func_value = 'loads' if key == 'decoder' else 'dumps'\n                    if hasattr(values[key], func_value) and inspect.isfunction(getattr(values[key], func_value)):\n                        values[key] = getattr(values[key], func_value)\n                    else:\n                        raise ValueError(f'`{key}` must be callable or have a callable \"{func_value}\" method')\n\n    if 'cache_max_size' in values:\n        values['cache_max_size'] = int(values['cache_max_size']) if values['cache_max_size'] else None\n        if 'cache_max_size_policy' in values:\n            values['cache_max_size_policy'] = CachePolicy(values['cache_max_size_policy'])\n        elif not is_update:\n            values['cache_max_size_policy'] = CachePolicy.LFU\n    elif 'cache_max_size_policy' in values:\n        values['cache_max_size_policy'] = CachePolicy(values['cache_max_size_policy'])\n    return values\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.validate_serializer","title":"validate_serializer","text":"<pre><code>validate_serializer()\n</code></pre> <p>Validate the serializer config</p> Source code in <code>kvdb/configs/base.py</code> <pre><code>@model_validator(mode = 'after')\ndef validate_serializer(self):\n    \"\"\"\n    Validate the serializer config\n    \"\"\"\n    if self.compression is None and self.compression_level is None:\n        from kvdb.io.compression import get_default_compression\n        self.compression, self.compression_level = get_default_compression(enabled = self.compression_enabled)\n        if self.compression and not temp_data.has_logged('kvdb_default_compression'):\n            logger.info(f'Setting default compression to {self.compression} with level {self.compression_level}')\n    if self.serializer_kwargs is None: self.serializer_kwargs = {}\n    return self\n</code></pre>"},{"location":"api/cachify/object/#kvdb.io.cachify.base.Cachify.validateself_config","title":"validateself_config","text":"<pre><code>validateself_config()\n</code></pre> <p>Validates the cachify config</p> Source code in <code>kvdb/io/cachify/base.py</code> <pre><code>@model_validator(mode = 'after')\ndef validateself_config(self):\n    \"\"\"\n    Validates the cachify config\n    \"\"\"\n    if self.encoder is None or self.decoder is None:\n        serializer = self.get_serializer()\n        self.encoder = serializer.dumps\n        self.decoder = serializer.loads\n    if self.kwarg_override_prefix:\n        if self.disabled_kws: self.disabled_kws = [f'{self.kwarg_override_prefix}{kw}' for kw in self.disabled_kws]\n        if self.invalidate_kws: self.invalidate_kws = [f'{self.kwarg_override_prefix}{kw}' for kw in self.invalidate_kws]\n        if self.overwrite_kws: self.overwrite_kws = [f'{self.kwarg_override_prefix}{kw}' for kw in self.overwrite_kws]\n        if self.ttl_kws: self.ttl_kws = [f'{self.kwarg_override_prefix}{kw}' for kw in self.ttl_kws]\n        if self.exclude_kws: self.exclude_kws = [f'{self.kwarg_override_prefix}{kw}' for kw in self.exclude_kws]\n    from kvdb.configs import settings\n    self.settings = settings\n    # self.has_async_loop = self.settings.is_in_async_loop()\n    return self\n</code></pre>"},{"location":"api/serializers/json/","title":"JSON","text":"<p>JSON Serialization is the most common serialization format used in the <code>KVDB</code> library. It is a good choice for serializing data that will be sent over the network or stored in a file, and is customized to provide serialization of most data types and objects.</p> <p>Additionally, it can be customized to use sub-libraries such as <code>simdjson</code>, <code>orjson</code>, <code>ujson</code>, and the standard <code>json</code> library.</p>"},{"location":"api/serializers/json/#references","title":"References","text":"<ul> <li>pysimdjson</li> <li>orjson</li> <li>ujson</li> </ul>"},{"location":"api/serializers/json/#json-encoder-utility","title":"JSON Encoder Utility","text":"<p>The following function is called to support the JSON serialization of objects:</p> <p>Helper to serialize an object</p> PARAMETER DESCRIPTION <code>obj</code> <p>the object to serialize</p> <p> TYPE: <code>kvdb.io.serializers.utils.SerializableObject</code> </p> RETURNS DESCRIPTION <code>typing.Union[typing.Dict[str, typing.Any], typing.List[typing.Dict[str, typing.Any]], typing.Any]</code> <p>the serialized object in dict</p> <code>typing.Union[typing.Dict[str, typing.Any], typing.List[typing.Dict[str, typing.Any]], typing.Any]</code> <p>{ \"type\": ..., \"value\": ...,</p> <code>typing.Union[typing.Dict[str, typing.Any], typing.List[typing.Dict[str, typing.Any]], typing.Any]</code> <p>}</p> Source code in <code>kvdb/io/serializers/utils.py</code> <pre><code>def serialize_object(\n    obj: SerializableObject,\n    **kwargs\n) -&gt; Union[Dict[str, Any], List[Dict[str, Any]], Any]:\n    \"\"\"\n    Helper to serialize an object\n\n    Args:\n        obj: the object to serialize\n\n    Returns:\n        the serialized object in dict\n        {\n            \"__type__\": ...,\n            \"value\": ...,\n        }\n    \"\"\"\n    if obj is None: return None\n\n    if isinstance(obj, BaseModel) or hasattr(obj, 'model_dump'):\n        obj_class_name = register_object_class(obj)\n\n        obj_value = obj.model_dump(mode = 'json', round_trip = True, **kwargs)\n        # for k,v in obj_value.items():\n        #     # if isinstance(v, BaseModel) or hasattr(v, 'model_dump'):\n        #     #     obj_value[k] = serialize_object(v)\n        #     if not is_primitive(v):\n        #         obj_value[k] = serialize_object(v)\n        # logger.info(f'Pydantic Serializing Object: |r|({type(obj)})|e| {str(obj_value)[:1000]}', colored = True)\n        return {\n            \"__type__\": \"pydantic\",\n            \"__class__\": obj_class_name,\n            \"value\": obj_value,\n        }\n\n    # Move this to the top before primitives\n    if np is not None:\n        # if isinstance(obj, (np.int_, np.intc, np.intp, np.int8, np.int16, np.int32, np.int64, np.uint8, np.uint16, np.uint32, np.uint64)):\n        if isinstance(obj, np_int_types):\n            obj_class_name = register_object_class(obj)\n            return {\n                \"__type__\": \"numpy\",\n                \"__class__\": obj_class_name,\n                \"value\": int(obj),\n            }\n\n\n        # if isinstance(obj, (np.float_, np.float16, np.float32, np.float64)):\n        if isinstance(obj, np_float_types):\n            obj_class_name = register_object_class(obj)\n            return {\n                \"__type__\": \"numpy\",\n                \"__class__\": obj_class_name,\n                \"value\": float(obj),\n            }\n\n\n    if is_primitive(obj, exclude_bytes = True):\n        return obj\n\n    if isinstance(obj, (list, tuple)):\n        return [serialize_object(item) for item in obj]\n\n    if isinstance(obj, dict):\n        if \"__type__\" in obj: return obj\n        return {key: serialize_object(value) for key, value in obj.items()}\n\n    if isinstance(obj, (datetime.datetime, datetime.date, datetime.time)):\n        return {\n            \"__type__\": \"datetime\",\n            \"value\": obj.isoformat(),\n        }\n\n    if isinstance(obj, datetime.timedelta):\n        return {\n            \"__type__\": \"timedelta\",\n            \"value\": obj.total_seconds(),\n        }\n\n    if isinstance(obj, dataclasses.InitVar) or dataclasses.is_dataclass(obj):\n        obj_class_name = register_object_class(obj)\n        return {\n            \"__type__\": \"dataclass\",\n            \"__class__\": obj_class_name,\n            \"value\": dataclasses.asdict(obj),\n        }\n\n    if hasattr(obj, 'as_posix'):\n        obj_class_name = register_object_class(obj)\n        return {\n            \"__type__\": \"path\",\n            \"__class__\": obj_class_name,\n            \"value\": obj.as_posix(),\n        }\n\n    if isinstance(obj, (bytes, bytearray)):\n        return {\n            \"__type__\": \"bytes\",\n            \"value\": obj.hex(),\n        }\n\n    if isinstance(obj, (set, frozenset)):\n        return {\n            \"__type__\": \"set\",\n            \"value\": list(obj),\n        }\n\n    if isinstance(obj, Enum):\n        obj_class_name = register_object_class(obj)\n        return {\n            \"__type__\": \"enum\",\n            \"__class__\": obj_class_name,\n            \"value\": obj.value,\n        }\n\n    if isinstance(obj, UUID):\n        return {\n            \"__type__\": \"uuid\",\n            \"value\": str(obj),\n        }\n\n    if isinstance(obj, abc.ABC):\n        logger.info(f'Pickle Serializing Object: |r|({type(obj)}) {str(obj)[:1000]}', colored = True)\n        obj_bytes = default_pickle.dumps(obj)\n        return {\n            \"__type__\": \"pickle\",\n            \"value\": obj_bytes.hex(),\n        }\n\n\n    if hasattr(obj, \"numpy\"):  # Checks for TF tensors without needing the import\n        return {\n            \"__type__\": \"tensor\",\n            \"value\": obj.numpy().tolist(),\n        }\n\n    if hasattr(obj, 'tolist'): # Checks for torch tensors without importing\n        return {\n            \"__type__\": \"tensor\",\n            \"value\": obj.tolist(),\n        }\n\n    # Try one shot encoding objects\n    # with contextlib.suppress(Exception):\n\n    try:\n        logger.info(f'Pickle Serializing Object: |r|({type(obj)}) {str(obj)[:1000]}', colored = True)\n        obj_bytes = default_pickle.dumps(obj)\n        return {\n            \"__type__\": \"pickle\",\n            \"value\": obj_bytes.hex(),\n        }\n    except Exception as e:\n\n        logger.info(f'Error Serializing Object: |r|({type(obj)}) {e}|e| {str(obj)[:1000]}', colored = True)\n\n    raise TypeError(f\"Cannot serialize object of type {type(obj)}\")\n</code></pre>"},{"location":"api/serializers/json/#api-reference","title":"API Reference","text":"<p>               Bases: <code>kvdb.io.serializers.base.BaseSerializer</code></p> METHOD DESCRIPTION <code>adecode</code> <p>Decodes the value asynchronously</p> <code>adumps</code> <p>Dumps the value asynchronously</p> <code>aencode</code> <p>Encodes the value asynchronously</p> <code>aloads</code> <p>Loads the value asynchronously</p> <code>check_encoded_value</code> <p>Check the encoded value to remove the prefix</p> <code>compress_value</code> <p>Compresses the value</p> <code>copy</code> <p>Copies the serializer</p> <code>create_hash</code> <p>Creates a hash for the object</p> <code>decode</code> <p>Decodes the value</p> <code>decode_one</code> <p>Decode the value with the JSON Library</p> <code>decode_value</code> <p>Decode the value with the JSON Library</p> <code>decompress_value</code> <p>Decompresses the value</p> <code>deprecated_decompress_value</code> <p>Attempts to decompress the value using the deprecated compressor</p> <code>dumps</code> <p>Dumps the value</p> <code>encode</code> <p>Encodes the value</p> <code>encode_value</code> <p>Encode the value with the JSON Library</p> <code>fetch_object_classname</code> <p>Fetches the object classname</p> <code>loads</code> <p>Loads the value</p> <code>set_default_lib</code> <p>Sets the default JSON library</p> ATTRIBUTE DESCRIPTION <code>compression_enabled</code> <p>Returns if compression is enabled</p> <p> TYPE: <code>bool</code> </p> <code>compression_level</code> <p>Returns the compression level</p> <p> TYPE: <code>typing.Optional[int]</code> </p> Source code in <code>kvdb/io/serializers/_json.py</code> <pre><code>def __init__(\n    self, \n    jsonlib: Optional[Union[str, Any]] = None,\n    compression: Optional[str] = None,\n    compression_level: int | None = None, \n    encoding: str | None = None, \n    serialization_obj: Optional[Type[BaseModel]] = None,\n    serialization_obj_kwargs: Optional[Dict[str, Any]] = None,\n    disable_object_serialization: Optional[bool] = None,\n    **kwargs\n):\n    super().__init__(compression, compression_level, encoding, **kwargs)\n    self.serialization_obj = serialization_obj\n    self.serialization_obj_kwargs = serialization_obj_kwargs or {}\n    self.serialization_schemas: Dict[str, Type[BaseModel]] = {}\n    if disable_object_serialization is not None:\n        self.disable_object_serialization = disable_object_serialization\n    if jsonlib is not None:\n        if isinstance(jsonlib, str):\n            jsonlib = lazy_import(jsonlib, is_module=True)\n        assert hasattr(jsonlib, \"dumps\") and hasattr(jsonlib, \"loads\"), f\"Invalid JSON Library: {jsonlib}\"\n        self.jsonlib = jsonlib\n    self.jsonlib_name = self.jsonlib.__name__\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.compression_enabled","title":"compression_enabled  <code>property</code>","text":"<pre><code>compression_enabled: bool\n</code></pre> <p>Returns if compression is enabled</p>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.compression_level","title":"compression_level  <code>property</code>","text":"<pre><code>compression_level: typing.Optional[int]\n</code></pre> <p>Returns the compression level</p>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.adecode","title":"adecode  <code>async</code>","text":"<pre><code>adecode(\n    value: typing.Union[str, bytes],\n    schema_map: typing.Optional[\n        typing.Dict[str, str]\n    ] = None,\n    raise_errors: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Decodes the value asynchronously</p> Source code in <code>kvdb/io/serializers/_json.py</code> <pre><code>async def adecode(self, value: Union[str, bytes], schema_map: Optional[Dict[str, str]] = None, raise_errors: Optional[bool] = None, **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Decodes the value asynchronously\n    \"\"\"\n    # try:\n    return await Pooler.arun(self.decode, value, schema_map = schema_map, raise_errors = raise_errors, **kwargs)\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.adumps","title":"adumps  <code>async</code>","text":"<pre><code>adumps(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Dumps the value asynchronously</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>async def adumps(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Dumps the value asynchronously\n    \"\"\"\n    return await Pooler.arun(self.dumps, value, **kwargs)\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.aencode","title":"aencode  <code>async</code>","text":"<pre><code>aencode(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Encodes the value asynchronously</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>async def aencode(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Encodes the value asynchronously\n    \"\"\"\n    return await Pooler.arun(self.encode, value, **kwargs)\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.aloads","title":"aloads  <code>async</code>","text":"<pre><code>aloads(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Loads the value asynchronously</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>async def aloads(self, value: Union[str, bytes], **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Loads the value asynchronously\n    \"\"\"\n    return await Pooler.arun(self.loads, value, **kwargs)\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.check_encoded_value","title":"check_encoded_value","text":"<pre><code>check_encoded_value(\n    value: typing.Union[str, bytes],\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Check the encoded value to remove the prefix</p> Source code in <code>kvdb/io/serializers/_json.py</code> <pre><code>def check_encoded_value(self, value: Union[str, bytes]) -&gt; Union[str, bytes]:\n    \"\"\"\n    Check the encoded value to remove the prefix\n    \"\"\"\n    if isinstance(value, bytes):\n        logger.info(f'Value Bytes: {value}')\n        if value.startswith(ENCODER_SERIALIZER_PREFIX_BYTES):\n            value = value[ENCODER_SERIALIZER_PREFIX_BYTES_LEN:]\n    elif isinstance(value, str):\n        logger.info(f'Value Str: {value}')\n        if value.startswith(ENCODER_SERIALIZER_PREFIX):\n            value = value[ENCODER_SERIALIZER_PREFIX_LEN:]\n    return value\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.compress_value","title":"compress_value","text":"<pre><code>compress_value(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Compresses the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def compress_value(self, value: Union[str, bytes], **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Compresses the value\n    \"\"\"\n    if self.compression_enabled:\n        if isinstance(value, str): value = value.encode(self.encoding)\n        return self.compressor.compress(value)\n    return value\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.copy","title":"copy","text":"<pre><code>copy(**kwargs) -&gt; kvdb.io.serializers.base.BaseSerializer\n</code></pre> <p>Copies the serializer</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def copy(self, **kwargs) -&gt; BaseSerializer:\n    \"\"\"\n    Copies the serializer\n    \"\"\"\n    new = deepcopy(self)\n    for k, v in kwargs.items():\n        if hasattr(new, k):\n            setattr(new, k, v)\n        else:\n            new._kwargs[k] = v\n        # setattr(new, k, v)\n    return new\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.create_hash","title":"create_hash","text":"<pre><code>create_hash(\n    obj: kvdb.io.serializers.base.ObjectValue,\n) -&gt; str\n</code></pre> <p>Creates a hash for the object</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def create_hash(self, obj: ObjectValue) -&gt; str:\n    \"\"\"\n    Creates a hash for the object\n    \"\"\"\n    return create_obj_hash(obj)\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.decode","title":"decode","text":"<pre><code>decode(\n    value: typing.Union[str, bytes],\n    schema_map: typing.Optional[\n        typing.Dict[str, str]\n    ] = None,\n    raise_errors: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Decodes the value</p> Source code in <code>kvdb/io/serializers/_json.py</code> <pre><code>def decode(self, value: Union[str, bytes], schema_map: Optional[Dict[str, str]] = None, raise_errors: Optional[bool] = None, **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Decodes the value\n    \"\"\"\n    try:\n        decompressed_value = self.decompress_value(value, **kwargs)\n        if decompressed_value is not None:\n            value = decompressed_value\n    except Exception as e:\n        if raise_errors or self.raise_errors: raise DataError(f\"[{self.name}] Error in Decompression: {str(value)[:100]}\") from e\n        # return self.decode_value(value, **kwargs)\n    return self.decode_value(value, schema_map = schema_map, raise_errors = raise_errors, **kwargs)\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.decode_one","title":"decode_one","text":"<pre><code>decode_one(value: str, **kwargs) -&gt; typing.Union[\n    kvdb.io.serializers.base.SchemaType,\n    typing.Dict,\n    typing.Any,\n]\n</code></pre> <p>Decode the value with the JSON Library</p> Source code in <code>kvdb/io/serializers/_json.py</code> <pre><code>def decode_one(self, value: str, **kwargs) -&gt; Union[SchemaType, Dict, Any]:\n    \"\"\"\n    Decode the value with the JSON Library\n    \"\"\"\n    if value is None: return None\n    try:\n        value = self.jsonlib.loads(value, **kwargs)\n        if not self.disable_object_serialization and isinstance(value, dict) and '__class__' in value:\n            obj_class_name = value.pop('__class__')\n            if obj_class_name not in self.serialization_schemas:\n                self.serialization_schemas[obj_class_name] = lazy_import(obj_class_name)\n            obj_class = self.serialization_schemas[obj_class_name]\n            value = obj_class.model_validate(value)\n        elif self.serialization_obj is not None:\n            value = self.serialization_obj.model_validate(value)\n        return value\n    except Exception as e:\n        if not self.is_encoder: \n            logger.info(f'Error Decoding Value: |r|({type(value)}) {e}|e| {str(value)[:1000]}', colored = True, prefix = self.jsonlib_name)\n            # logger.trace(f'Error Decoding Value: ({type(value)}) {str(value)[:1000]}', e, prefix = self.jsonlib_name)\n        if self.raise_errors: raise e\n    return None\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.decode_value","title":"decode_value","text":"<pre><code>decode_value(\n    value: str,\n    schema_map: typing.Optional[\n        typing.Dict[str, str]\n    ] = None,\n    raise_errors: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; typing.Union[\n    kvdb.io.serializers.base.SchemaType,\n    typing.Dict,\n    typing.Any,\n]\n</code></pre> <p>Decode the value with the JSON Library</p> Source code in <code>kvdb/io/serializers/_json.py</code> <pre><code>def decode_value(self, value: str, schema_map: Optional[Dict[str, str]] = None, raise_errors: Optional[bool] = None, **kwargs) -&gt; Union[SchemaType, Dict, Any]:\n    \"\"\"\n    Decode the value with the JSON Library\n    \"\"\"\n    if value is None: return None\n    if isinstance(value, (str, bytes)):\n        try:\n            # value = self.check_encoded_value(value)\n            value = self.jsonlib.loads(value, **kwargs)\n        except Exception as e:\n            if isinstance(value, str) and 'Exception' in value or 'Traceback (most recent call last):' in value:\n                return value\n            if not self.is_encoder: \n                str_value = str(value)\n                if not schema_map: str_value = str_value[:1000]\n                logger.info(f'Error JSON Decoding Value: |r|({type(value)}) {e}|e| {str_value}', colored = True, prefix = self.jsonlib_name)\n                # logger.trace(f'Error JSON Decoding Value: ({type(value)}) {str(value)[:1000]}', e, prefix = self.jsonlib_name)\n            if raise_errors or self.raise_errors: raise e\n    try:\n        return deserialize_object(value, schema_map = schema_map, allow_failed_import = self.allow_failed_import)\n    except Exception as e:\n        if not self.is_encoder: \n            str_value = str(value)\n            if not schema_map: str_value = str_value[:1000]\n            logger.trace(f'Error Deserializing Object: ({type(value)}) {str_value}', e, prefix = self.jsonlib_name)\n            # logger.info(f'Error Decoding Value: |r|({type(value)}) {e}|e| {str(value)[:1000]}', colored = True, prefix = self.jsonlib_name)\n        if raise_errors or self.raise_errors: raise e\n    return None\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.decompress_value","title":"decompress_value","text":"<pre><code>decompress_value(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Decompresses the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def decompress_value(self, value: Union[str, bytes], **kwargs) -&gt; Union[str, bytes]:\n    # sourcery skip: extract-duplicate-method\n    \"\"\"\n    Decompresses the value\n    \"\"\"\n    if not self.compression_enabled: return value\n    try:\n        value = self.compressor.decompress(value, **kwargs)\n    except Exception as e:\n        if self.enable_deprecation_support or self.previous_compressor is not None:\n            value = self.deprecated_decompress_value(value, **kwargs)\n    if value is not None and not self.binary: value = value.decode(self.encoding)\n    return value\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.deprecated_decompress_value","title":"deprecated_decompress_value","text":"<pre><code>deprecated_decompress_value(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; typing.Optional[typing.Union[str, bytes]]\n</code></pre> <p>Attempts to decompress the value using the deprecated compressor</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def deprecated_decompress_value(self, value: Union[str, bytes], **kwargs) -&gt; Optional[Union[str, bytes]]:\n    \"\"\"\n    Attempts to decompress the value using the deprecated compressor\n    \"\"\"\n    e = None\n    attempt_msg = f\"{self.name}\"\n    if self.previous_compressor is not None:\n        try:\n            return self.previous_compressor.decompress(value)\n        except Exception as e:\n            attempt_msg += f\"-&gt; {self.previous_compressor.name}\"\n    try:\n        return zlib.decompress(value)\n    except Exception as e:\n        attempt_msg += \" -&gt; ZLib\"\n        if self.raise_errors: raise DataError(f\"[{attempt_msg}] Error in Decompression: {str(value)[:100]}\") from e\n        return None\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.dumps","title":"dumps","text":"<pre><code>dumps(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Dumps the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def dumps(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    # sourcery skip: class-extract-method\n    \"\"\"\n    Dumps the value\n    \"\"\"\n    try:\n        return self.encode(value, **kwargs)\n    except Exception as e:\n        if self.raise_errors: raise DataError(f\"[{self.name}] Error in Encoding: {str(value)[:500]}\") from e\n        return None\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.encode","title":"encode","text":"<pre><code>encode(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Encodes the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def encode(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Encodes the value\n    \"\"\"\n    return self.compress_value(self.encode_value(value, **kwargs))\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.encode_value","title":"encode_value","text":"<pre><code>encode_value(\n    value: typing.Union[\n        typing.Any, kvdb.io.serializers.base.SchemaType\n    ],\n    **kwargs\n) -&gt; str\n</code></pre> <p>Encode the value with the JSON Library</p> Source code in <code>kvdb/io/serializers/_json.py</code> <pre><code>def encode_value(self, value: Union[Any, SchemaType], **kwargs) -&gt; str:\n    \"\"\"\n    Encode the value with the JSON Library\n    \"\"\"\n    try:\n        value_dict = serialize_object(value, **self.serialization_obj_kwargs)\n        # logger.info(f'Value Dict: {value_dict}')\n        encoded = self.jsonlib.dumps(value_dict, **kwargs)\n        if self.ensure_string_value and isinstance(encoded, bytes):\n            encoded = encoded.decode(self.encoding)\n        return encoded\n\n    except Exception as e:\n        if not self.is_encoder: logger.trace(f'Error Encoding Value: |r|({type(value)})|e| {str(value)[:1000]}', e, colored = True)\n    try:\n        encoded = self.jsonlib.dumps(value, **kwargs)\n        if self.ensure_string_value and isinstance(encoded, bytes):\n            encoded = encoded.decode(self.encoding)\n        return encoded\n    except Exception as e:\n        if not self.is_encoder: \n            logger.info(f'Error Encoding Value: |r|({type(value)}) {e}|e| {str(value)[:1000]}', colored = True, prefix = self.jsonlib_name)\n        if self.raise_errors: raise e\n    return None\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.fetch_object_classname","title":"fetch_object_classname","text":"<pre><code>fetch_object_classname(\n    obj: kvdb.io.serializers.base.ObjectValue,\n) -&gt; str\n</code></pre> <p>Fetches the object classname</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def fetch_object_classname(self, obj: ObjectValue) -&gt; str:\n    \"\"\"\n    Fetches the object classname\n    \"\"\"\n    return f\"{obj.__class__.__module__}.{obj.__class__.__name__}\"\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.loads","title":"loads","text":"<pre><code>loads(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Loads the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def loads(self, value: Union[str, bytes], **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Loads the value\n    \"\"\"\n    try:\n        return self.decode(value, **kwargs)\n    except Exception as e:\n        if not self.is_encoder: logger.trace(f'[{self.name}] Error in Decoding: {str(value)[:500]}', e)\n        if self.raise_errors: raise DataError(f\"[{self.name}] Error in Decoding: {str(value)[:500]}\") from e\n        return None\n</code></pre>"},{"location":"api/serializers/json/#kvdb.io.serializers._json.JsonSerializer.set_default_lib","title":"set_default_lib  <code>classmethod</code>","text":"<pre><code>set_default_lib(\n    lib: typing.Union[\n        str,\n        kvdb.io.serializers._json.JsonLibT,\n        kvdb.io.serializers.base.ModuleType,\n    ],\n) -&gt; None\n</code></pre> <p>Sets the default JSON library</p> Source code in <code>kvdb/io/serializers/_json.py</code> <pre><code>@classmethod\ndef set_default_lib(cls, lib: Union[str, JsonLibT, ModuleType]) -&gt; None:\n    \"\"\"\n    Sets the default JSON library\n    \"\"\"\n    global default_json\n    if isinstance(lib, str):\n        lib = lazy_import(lib, is_module=True)\n    assert hasattr(lib, \"dumps\") and hasattr(lib, \"loads\"), f\"Invalid JSON Library: {lib}\"\n    cls.jsonlib = lib\n    default_json = lib\n</code></pre>"},{"location":"api/serializers/msgpack/","title":"MsgPack","text":"<p>MsgPack is a binary serialization format that is similar to JSON, but more efficient. It is a good choice for serializing data that will be sent over the network or stored in a file.</p>"},{"location":"api/serializers/msgpack/#references","title":"References","text":"<ul> <li>MsgPack</li> <li>msgpack-python</li> </ul>"},{"location":"api/serializers/msgpack/#api-reference","title":"API Reference","text":"<p>               Bases: <code>kvdb.io.serializers.base.BinaryBaseSerializer</code></p> METHOD DESCRIPTION <code>adecode</code> <p>Decodes the value asynchronously</p> <code>adumps</code> <p>Dumps the value asynchronously</p> <code>aencode</code> <p>Encodes the value asynchronously</p> <code>aloads</code> <p>Loads the value asynchronously</p> <code>compress_value</code> <p>Compresses the value</p> <code>copy</code> <p>Copies the serializer</p> <code>create_hash</code> <p>Creates a hash for the object</p> <code>decode</code> <p>Decodes the value</p> <code>decode_value</code> <p>Decode the value with the Pickle Library</p> <code>decompress_value</code> <p>Decompresses the value</p> <code>default_deserialization_hook</code> <p>Default Deserialization Hook</p> <code>default_serialization_hook</code> <p>Default Serialization Hook</p> <code>deprecated_decompress_value</code> <p>Attempts to decompress the value using the deprecated compressor</p> <code>dumps</code> <p>Dumps the value</p> <code>encode</code> <p>Encodes the value</p> <code>encode_value</code> <p>Encode the value with the Pickle Library</p> <code>fetch_object_classname</code> <p>Fetches the object classname</p> <code>loads</code> <p>Loads the value</p> <code>set_default_lib</code> <p>Sets the default MsgPack library</p> ATTRIBUTE DESCRIPTION <code>compression_enabled</code> <p>Returns if compression is enabled</p> <p> TYPE: <code>bool</code> </p> <code>compression_level</code> <p>Returns the compression level</p> <p> TYPE: <code>typing.Optional[int]</code> </p> Source code in <code>kvdb/io/serializers/_msgpack.py</code> <pre><code>def __init__(\n    self, \n    msgpacklib: Optional[Union[str, Any]] = None,\n    compression: Optional[str] = None,\n    compression_level: int | None = None, \n    encoding: str | None = None, \n    serialization_obj: Optional[Type[BaseModel]] = None,\n    serialization_obj_kwargs: Optional[Dict[str, Any]] = None,\n    disable_object_serialization: Optional[bool] = None,\n    jsonlib: Optional[Union[str, Any]] = None,\n    **kwargs\n):\n    if not default_msgpack:\n        raise ImportError(\"MsgPack Serializer is not available. Please install `msgpack`\")\n    super().__init__(compression, compression_level, encoding, **kwargs)\n    self.serialization_obj = serialization_obj\n    self.serialization_obj_kwargs = serialization_obj_kwargs or {}\n    self.serialization_schemas: Dict[str, Type[BaseModel]] = {}\n    if disable_object_serialization is not None:\n        self.disable_object_serialization = disable_object_serialization\n\n    if msgpacklib is not None:\n        if isinstance(msgpacklib, str):\n            msgpacklib = lazy_import(msgpacklib, is_module=True)\n        assert hasattr(msgpacklib, \"packb\") and hasattr(msgpacklib, \"unpackb\"), f\"Invalid MsgPack Library: {picklelib}\"\n        self.msgpacklib = msgpacklib\n    self.msgpacklib_name = self.msgpacklib.__name__\n    if jsonlib is not None:\n        if isinstance(jsonlib, str):\n            jsonlib = lazy_import(jsonlib, is_module=True)\n        assert hasattr(jsonlib, \"dumps\") and hasattr(jsonlib, \"loads\"), f\"Invalid JSON Library: {jsonlib}\"\n        self.jsonlib = jsonlib\n    self.jsonlib_name = self.jsonlib.__name__\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.compression_enabled","title":"compression_enabled  <code>property</code>","text":"<pre><code>compression_enabled: bool\n</code></pre> <p>Returns if compression is enabled</p>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.compression_level","title":"compression_level  <code>property</code>","text":"<pre><code>compression_level: typing.Optional[int]\n</code></pre> <p>Returns the compression level</p>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.adecode","title":"adecode  <code>async</code>","text":"<pre><code>adecode(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Decodes the value asynchronously</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>async def adecode(self, value: Union[str, bytes], **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Decodes the value asynchronously\n    \"\"\"\n    return await Pooler.arun(self.decode, value, **kwargs)\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.adumps","title":"adumps  <code>async</code>","text":"<pre><code>adumps(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Dumps the value asynchronously</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>async def adumps(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Dumps the value asynchronously\n    \"\"\"\n    return await Pooler.arun(self.dumps, value, **kwargs)\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.aencode","title":"aencode  <code>async</code>","text":"<pre><code>aencode(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Encodes the value asynchronously</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>async def aencode(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Encodes the value asynchronously\n    \"\"\"\n    return await Pooler.arun(self.encode, value, **kwargs)\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.aloads","title":"aloads  <code>async</code>","text":"<pre><code>aloads(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Loads the value asynchronously</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>async def aloads(self, value: Union[str, bytes], **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Loads the value asynchronously\n    \"\"\"\n    return await Pooler.arun(self.loads, value, **kwargs)\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.compress_value","title":"compress_value","text":"<pre><code>compress_value(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Compresses the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def compress_value(self, value: Union[str, bytes], **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Compresses the value\n    \"\"\"\n    if self.compression_enabled:\n        if isinstance(value, str): value = value.encode(self.encoding)\n        return self.compressor.compress(value)\n    return value\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.copy","title":"copy","text":"<pre><code>copy(**kwargs) -&gt; kvdb.io.serializers.base.BaseSerializer\n</code></pre> <p>Copies the serializer</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def copy(self, **kwargs) -&gt; BaseSerializer:\n    \"\"\"\n    Copies the serializer\n    \"\"\"\n    new = deepcopy(self)\n    for k, v in kwargs.items():\n        if hasattr(new, k):\n            setattr(new, k, v)\n        else:\n            new._kwargs[k] = v\n        # setattr(new, k, v)\n    return new\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.create_hash","title":"create_hash","text":"<pre><code>create_hash(\n    obj: kvdb.io.serializers.base.ObjectValue,\n) -&gt; str\n</code></pre> <p>Creates a hash for the object</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def create_hash(self, obj: ObjectValue) -&gt; str:\n    \"\"\"\n    Creates a hash for the object\n    \"\"\"\n    return create_obj_hash(obj)\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.decode","title":"decode","text":"<pre><code>decode(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Decodes the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def decode(self, value: Union[str, bytes], **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Decodes the value\n    \"\"\"\n    try:\n        decompressed_value = self.decompress_value(value, **kwargs)\n        if decompressed_value is not None:\n            value = decompressed_value\n    except Exception as e:\n        if self.raise_errors: raise DataError(f\"[{self.name}] Error in Decompression: {str(value)[:100]}\") from e\n        # return self.decode_value(value, **kwargs)\n    return self.decode_value(value, **kwargs)\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.decode_value","title":"decode_value","text":"<pre><code>decode_value(value: bytes, **kwargs) -&gt; typing.Union[\n    kvdb.io.serializers.base.SchemaType,\n    typing.Dict,\n    typing.Any,\n]\n</code></pre> <p>Decode the value with the Pickle Library</p> Source code in <code>kvdb/io/serializers/_msgpack.py</code> <pre><code>def decode_value(self, value: bytes, **kwargs) -&gt; Union[SchemaType, Dict, Any]:\n    \"\"\"\n    Decode the value with the Pickle Library\n    \"\"\"\n    try:\n        if 'raw' not in kwargs: kwargs['raw'] = False\n        if 'ext_hook' not in kwargs: kwargs['ext_hook'] = self.default_deserialization_hook\n        return self.msgpacklib.unpackb(value, **kwargs)\n    except Exception as e:\n        if not self.is_encoder: logger.info(f'Error Decoding Value: |r|({type(value)}) {e}|e| {str(value)[:500]}', colored = True, prefix = \"msgpack\")\n        if self.raise_errors: raise e\n    return None\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.decompress_value","title":"decompress_value","text":"<pre><code>decompress_value(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Decompresses the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def decompress_value(self, value: Union[str, bytes], **kwargs) -&gt; Union[str, bytes]:\n    # sourcery skip: extract-duplicate-method\n    \"\"\"\n    Decompresses the value\n    \"\"\"\n    if not self.compression_enabled: return value\n    try:\n        value = self.compressor.decompress(value, **kwargs)\n    except Exception as e:\n        if self.enable_deprecation_support or self.previous_compressor is not None:\n            value = self.deprecated_decompress_value(value, **kwargs)\n    if value is not None and not self.binary: value = value.decode(self.encoding)\n    return value\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.default_deserialization_hook","title":"default_deserialization_hook","text":"<pre><code>default_deserialization_hook(\n    code: int, data: typing.Union[str, bytes]\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Default Deserialization Hook</p> Source code in <code>kvdb/io/serializers/_msgpack.py</code> <pre><code>def default_deserialization_hook(self, code: int, data: Union[str, bytes]) -&gt; ObjectValue:\n    \"\"\"\n    Default Deserialization Hook\n    \"\"\"\n    if code != 2: return data\n    if isinstance(data, bytes): data = data.decode(self.encoding)\n    try:\n        data = self.jsonlib.loads(data)\n    except Exception as e:\n        if not self.is_encoder: logger.info(f'Error Decoding Value: |r|({type(data)}) {e}|e| {str(data)[:500]}', colored = True, prefix = \"msgpack\")\n        if self.raise_errors: raise e\n        return data\n    if not self.disable_object_serialization:\n        _class = data.pop('__class__', None)\n        if _class is not None:\n            if _class not in self.serialization_schemas:\n                self.serialization_schemas[_class] = lazy_import(_class)\n            _class = self.serialization_schemas[_class]\n            return _class.model_validate(data, **self.serialization_obj_kwargs)\n    elif self.serialization_obj is not None:\n        return self.serialization_obj.model_validate(data, **self.serialization_obj_kwargs)\n    return data\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.default_serialization_hook","title":"default_serialization_hook","text":"<pre><code>default_serialization_hook(\n    obj: kvdb.io.serializers.base.ObjectValue,\n)\n</code></pre> <p>Default Serialization Hook</p> Source code in <code>kvdb/io/serializers/_msgpack.py</code> <pre><code>def default_serialization_hook(self, obj: ObjectValue):\n    \"\"\"\n    Default Serialization Hook\n    \"\"\"\n    if not isinstance(obj, BaseModel) and not hasattr(obj, 'model_dump'):\n        if not self.is_encoder: logger.info(f'Invalid Object Type: |r|{type(obj)}|e| {obj}', colored = True, prefix = \"msgpack\")\n        return obj\n\n    if self.disable_object_serialization: \n        return obj.model_dump_json(**self.serialization_obj_kwargs)\n\n    obj_class_name = self.fetch_object_classname(obj)\n    if obj_class_name not in self.serialization_schemas:\n        self.serialization_schemas[obj_class_name] = obj.__class__\n    data = obj.model_dump(mode = 'json', **self.serialization_obj_kwargs)\n    data['__class__'] = obj_class_name\n    return self.msgpacklib.ExtType(2, self.jsonlib.dumps(data).encode(self.encoding))\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.deprecated_decompress_value","title":"deprecated_decompress_value","text":"<pre><code>deprecated_decompress_value(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; typing.Optional[typing.Union[str, bytes]]\n</code></pre> <p>Attempts to decompress the value using the deprecated compressor</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def deprecated_decompress_value(self, value: Union[str, bytes], **kwargs) -&gt; Optional[Union[str, bytes]]:\n    \"\"\"\n    Attempts to decompress the value using the deprecated compressor\n    \"\"\"\n    e = None\n    attempt_msg = f\"{self.name}\"\n    if self.previous_compressor is not None:\n        try:\n            return self.previous_compressor.decompress(value)\n        except Exception as e:\n            attempt_msg += f\"-&gt; {self.previous_compressor.name}\"\n    try:\n        return zlib.decompress(value)\n    except Exception as e:\n        attempt_msg += \" -&gt; ZLib\"\n        if self.raise_errors: raise DataError(f\"[{attempt_msg}] Error in Decompression: {str(value)[:100]}\") from e\n        return None\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.dumps","title":"dumps","text":"<pre><code>dumps(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Dumps the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def dumps(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    # sourcery skip: class-extract-method\n    \"\"\"\n    Dumps the value\n    \"\"\"\n    try:\n        return self.encode(value, **kwargs)\n    except Exception as e:\n        if self.raise_errors: raise DataError(f\"[{self.name}] Error in Encoding: {str(value)[:500]}\") from e\n        return None\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.encode","title":"encode","text":"<pre><code>encode(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Encodes the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def encode(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Encodes the value\n    \"\"\"\n    return self.compress_value(self.encode_value(value, **kwargs))\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.encode_value","title":"encode_value","text":"<pre><code>encode_value(\n    value: typing.Union[\n        typing.Any, kvdb.io.serializers.base.SchemaType\n    ],\n    **kwargs\n) -&gt; bytes\n</code></pre> <p>Encode the value with the Pickle Library</p> Source code in <code>kvdb/io/serializers/_msgpack.py</code> <pre><code>def encode_value(self, value: Union[Any, SchemaType], **kwargs) -&gt; bytes:\n    \"\"\"\n    Encode the value with the Pickle Library\n    \"\"\"\n    if 'use_bin_type' not in kwargs: kwargs['use_bin_type'] = True\n    if 'default' not in kwargs: kwargs['default'] = self.default_serialization_hook\n    try:\n        return self.msgpacklib.packb(value, **kwargs)\n    except Exception as e:\n        if not self.is_encoder: logger.info(f'Error Encoding Value: |r|({type(value)}) {e}|e| {str(value)[:500]}', colored = True, prefix = \"msgpack\")\n        if self.raise_errors: raise e\n    return None\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.fetch_object_classname","title":"fetch_object_classname","text":"<pre><code>fetch_object_classname(\n    obj: kvdb.io.serializers.base.ObjectValue,\n) -&gt; str\n</code></pre> <p>Fetches the object classname</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def fetch_object_classname(self, obj: ObjectValue) -&gt; str:\n    \"\"\"\n    Fetches the object classname\n    \"\"\"\n    return f\"{obj.__class__.__module__}.{obj.__class__.__name__}\"\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.loads","title":"loads","text":"<pre><code>loads(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Loads the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def loads(self, value: Union[str, bytes], **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Loads the value\n    \"\"\"\n    try:\n        return self.decode(value, **kwargs)\n    except Exception as e:\n        if not self.is_encoder: logger.trace(f'[{self.name}] Error in Decoding: {str(value)[:500]}', e)\n        if self.raise_errors: raise DataError(f\"[{self.name}] Error in Decoding: {str(value)[:500]}\") from e\n        return None\n</code></pre>"},{"location":"api/serializers/msgpack/#kvdb.io.serializers._msgpack.MsgPackSerializer.set_default_lib","title":"set_default_lib  <code>classmethod</code>","text":"<pre><code>set_default_lib(\n    lib: typing.Union[\n        str,\n        kvdb.io.serializers._msgpack.MsgPackLibT,\n        kvdb.io.serializers.base.ModuleType,\n    ],\n) -&gt; None\n</code></pre> <p>Sets the default MsgPack library</p> Source code in <code>kvdb/io/serializers/_msgpack.py</code> <pre><code>@classmethod\ndef set_default_lib(cls, lib: Union[str, MsgPackLibT, ModuleType]) -&gt; None:\n    \"\"\"\n    Sets the default MsgPack library\n    \"\"\"\n    global default_msgpack\n    if isinstance(lib, str):\n        lib = lazy_import(lib, is_module=True)\n    assert hasattr(lib, \"packb\") and hasattr(lib, \"unpackb\"), f\"Invalid Msgpack Library: `{lib}`\"\n    cls.msgpacklib = lib\n    default_msgpack = lib\n</code></pre>"},{"location":"api/serializers/pickle/","title":"Pickle","text":"<p>Pickle is a binary serialization format that is specific to Python. It is a very powerful serialization format that can serialize almost any Python object. However, it is not recommended to use pickle to serialize and deserialize data from untrusted sources, as it can lead to security vulnerabilities.</p> <p>It is only used as the default serializer for <code>Jobs</code> to ensure that the <code>Job</code> can be serialized and deserialized across different Python environments.</p> <p>By default, the <code>pickle</code> serializer uses the the first available sub-library in the following order of priority: - <code>cloudpickle</code> - <code>dill</code> - <code>pickle</code></p>"},{"location":"api/serializers/pickle/#references","title":"References","text":"<ul> <li>cloudpickle</li> <li>dill</li> </ul>"},{"location":"api/serializers/pickle/#api-reference","title":"API Reference","text":"<p>               Bases: <code>kvdb.io.serializers.base.BinaryBaseSerializer</code></p> METHOD DESCRIPTION <code>adecode</code> <p>Decodes the value asynchronously</p> <code>adumps</code> <p>Dumps the value asynchronously</p> <code>aencode</code> <p>Encodes the value asynchronously</p> <code>aloads</code> <p>Loads the value asynchronously</p> <code>compress_value</code> <p>Compresses the value</p> <code>copy</code> <p>Copies the serializer</p> <code>create_hash</code> <p>Creates a hash for the object</p> <code>decode</code> <p>Decodes the value</p> <code>decode_value</code> <p>Decode the value with the Pickle Library</p> <code>decompress_value</code> <p>Decompresses the value</p> <code>deprecated_decompress_value</code> <p>Attempts to decompress the value using the deprecated compressor</p> <code>dumps</code> <p>Dumps the value</p> <code>encode</code> <p>Encodes the value</p> <code>encode_value</code> <p>Encode the value with the Pickle Library</p> <code>fetch_object_classname</code> <p>Fetches the object classname</p> <code>loads</code> <p>Loads the value</p> <code>set_default_lib</code> <p>Sets the default Pickle library</p> ATTRIBUTE DESCRIPTION <code>compression_enabled</code> <p>Returns if compression is enabled</p> <p> TYPE: <code>bool</code> </p> <code>compression_level</code> <p>Returns the compression level</p> <p> TYPE: <code>typing.Optional[int]</code> </p> Source code in <code>kvdb/io/serializers/_pickle.py</code> <pre><code>def __init__(\n    self, \n    picklelib: Optional[Union[str, Any]] = None,\n    compression: Optional[str] = None,\n    compression_level: int | None = None, \n    encoding: str | None = None, \n    **kwargs\n):\n    super().__init__(compression, compression_level, encoding, **kwargs)\n    if picklelib is not None:\n        if isinstance(picklelib, str):\n            picklelib = lazy_import(picklelib, is_module=True)\n        assert hasattr(picklelib, \"dumps\") and hasattr(picklelib, \"loads\"), f\"Invalid Pickle Library: {picklelib}\"\n        self.picklelib = picklelib\n    self.picklelib_name = self.picklelib.__name__\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.compression_enabled","title":"compression_enabled  <code>property</code>","text":"<pre><code>compression_enabled: bool\n</code></pre> <p>Returns if compression is enabled</p>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.compression_level","title":"compression_level  <code>property</code>","text":"<pre><code>compression_level: typing.Optional[int]\n</code></pre> <p>Returns the compression level</p>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.adecode","title":"adecode  <code>async</code>","text":"<pre><code>adecode(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Decodes the value asynchronously</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>async def adecode(self, value: Union[str, bytes], **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Decodes the value asynchronously\n    \"\"\"\n    return await Pooler.arun(self.decode, value, **kwargs)\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.adumps","title":"adumps  <code>async</code>","text":"<pre><code>adumps(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Dumps the value asynchronously</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>async def adumps(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Dumps the value asynchronously\n    \"\"\"\n    return await Pooler.arun(self.dumps, value, **kwargs)\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.aencode","title":"aencode  <code>async</code>","text":"<pre><code>aencode(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Encodes the value asynchronously</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>async def aencode(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Encodes the value asynchronously\n    \"\"\"\n    return await Pooler.arun(self.encode, value, **kwargs)\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.aloads","title":"aloads  <code>async</code>","text":"<pre><code>aloads(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Loads the value asynchronously</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>async def aloads(self, value: Union[str, bytes], **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Loads the value asynchronously\n    \"\"\"\n    return await Pooler.arun(self.loads, value, **kwargs)\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.compress_value","title":"compress_value","text":"<pre><code>compress_value(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Compresses the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def compress_value(self, value: Union[str, bytes], **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Compresses the value\n    \"\"\"\n    if self.compression_enabled:\n        if isinstance(value, str): value = value.encode(self.encoding)\n        return self.compressor.compress(value)\n    return value\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.copy","title":"copy","text":"<pre><code>copy(**kwargs) -&gt; kvdb.io.serializers.base.BaseSerializer\n</code></pre> <p>Copies the serializer</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def copy(self, **kwargs) -&gt; BaseSerializer:\n    \"\"\"\n    Copies the serializer\n    \"\"\"\n    new = deepcopy(self)\n    for k, v in kwargs.items():\n        if hasattr(new, k):\n            setattr(new, k, v)\n        else:\n            new._kwargs[k] = v\n        # setattr(new, k, v)\n    return new\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.create_hash","title":"create_hash","text":"<pre><code>create_hash(\n    obj: kvdb.io.serializers.base.ObjectValue,\n) -&gt; str\n</code></pre> <p>Creates a hash for the object</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def create_hash(self, obj: ObjectValue) -&gt; str:\n    \"\"\"\n    Creates a hash for the object\n    \"\"\"\n    return create_obj_hash(obj)\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.decode","title":"decode","text":"<pre><code>decode(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Decodes the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def decode(self, value: Union[str, bytes], **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Decodes the value\n    \"\"\"\n    try:\n        decompressed_value = self.decompress_value(value, **kwargs)\n        if decompressed_value is not None:\n            value = decompressed_value\n    except Exception as e:\n        if self.raise_errors: raise DataError(f\"[{self.name}] Error in Decompression: {str(value)[:100]}\") from e\n        # return self.decode_value(value, **kwargs)\n    return self.decode_value(value, **kwargs)\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.decode_value","title":"decode_value","text":"<pre><code>decode_value(value: bytes, **kwargs) -&gt; typing.Union[\n    kvdb.io.serializers.base.SchemaType,\n    typing.Dict,\n    typing.Any,\n]\n</code></pre> <p>Decode the value with the Pickle Library</p> Source code in <code>kvdb/io/serializers/_pickle.py</code> <pre><code>def decode_value(self, value: bytes, **kwargs) -&gt; Union[SchemaType, Dict, Any]:\n    \"\"\"\n    Decode the value with the Pickle Library\n    \"\"\"\n    try:\n        if self.picklelib_name == 'cloudpickle':\n            if 'encoding' not in kwargs:\n                kwargs['encoding'] = self.encoding\n            if 'fix_imports' not in kwargs:\n                kwargs['fix_imports'] = False\n        return self.picklelib.loads(value, **kwargs)\n    except Exception as e:\n        if not self.is_encoder: \n            logger.trace(f'Error Deserializing Object: ({type(value)}) {str(value)[:1000]}', e, prefix = self.picklelib_name)\n            # logger.info(f'Error Decoding Value: |r|({type(value)}) {e}|e| {value}', colored = True, prefix = self.picklelib_name)\n        if self.raise_errors: raise e\n    return None\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.decompress_value","title":"decompress_value","text":"<pre><code>decompress_value(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Decompresses the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def decompress_value(self, value: Union[str, bytes], **kwargs) -&gt; Union[str, bytes]:\n    # sourcery skip: extract-duplicate-method\n    \"\"\"\n    Decompresses the value\n    \"\"\"\n    if not self.compression_enabled: return value\n    try:\n        value = self.compressor.decompress(value, **kwargs)\n    except Exception as e:\n        if self.enable_deprecation_support or self.previous_compressor is not None:\n            value = self.deprecated_decompress_value(value, **kwargs)\n    if value is not None and not self.binary: value = value.decode(self.encoding)\n    return value\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.deprecated_decompress_value","title":"deprecated_decompress_value","text":"<pre><code>deprecated_decompress_value(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; typing.Optional[typing.Union[str, bytes]]\n</code></pre> <p>Attempts to decompress the value using the deprecated compressor</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def deprecated_decompress_value(self, value: Union[str, bytes], **kwargs) -&gt; Optional[Union[str, bytes]]:\n    \"\"\"\n    Attempts to decompress the value using the deprecated compressor\n    \"\"\"\n    e = None\n    attempt_msg = f\"{self.name}\"\n    if self.previous_compressor is not None:\n        try:\n            return self.previous_compressor.decompress(value)\n        except Exception as e:\n            attempt_msg += f\"-&gt; {self.previous_compressor.name}\"\n    try:\n        return zlib.decompress(value)\n    except Exception as e:\n        attempt_msg += \" -&gt; ZLib\"\n        if self.raise_errors: raise DataError(f\"[{attempt_msg}] Error in Decompression: {str(value)[:100]}\") from e\n        return None\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.dumps","title":"dumps","text":"<pre><code>dumps(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Dumps the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def dumps(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    # sourcery skip: class-extract-method\n    \"\"\"\n    Dumps the value\n    \"\"\"\n    try:\n        return self.encode(value, **kwargs)\n    except Exception as e:\n        if self.raise_errors: raise DataError(f\"[{self.name}] Error in Encoding: {str(value)[:500]}\") from e\n        return None\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.encode","title":"encode","text":"<pre><code>encode(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Encodes the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def encode(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Encodes the value\n    \"\"\"\n    return self.compress_value(self.encode_value(value, **kwargs))\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.encode_value","title":"encode_value","text":"<pre><code>encode_value(\n    value: typing.Union[\n        typing.Any, kvdb.io.serializers.base.SchemaType\n    ],\n    **kwargs\n) -&gt; bytes\n</code></pre> <p>Encode the value with the Pickle Library</p> Source code in <code>kvdb/io/serializers/_pickle.py</code> <pre><code>def encode_value(self, value: Union[Any, SchemaType], **kwargs) -&gt; bytes:\n    \"\"\"\n    Encode the value with the Pickle Library\n    \"\"\"\n    try:\n        return self.picklelib.dumps(value, **kwargs)\n    except Exception as e:\n        if not self.is_encoder: \n            logger.trace(f'Error Encoding Object: ({type(value)}) {str(value)[:1000]}', e, prefix = self.picklelib_name)\n            # logger.info(f'Error Encoding Value: |r|({type(value)}) {e}|e| {value}', colored = True, prefix = self.picklelib_name)\n        if self.raise_errors: raise e\n    return None\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.fetch_object_classname","title":"fetch_object_classname","text":"<pre><code>fetch_object_classname(\n    obj: kvdb.io.serializers.base.ObjectValue,\n) -&gt; str\n</code></pre> <p>Fetches the object classname</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def fetch_object_classname(self, obj: ObjectValue) -&gt; str:\n    \"\"\"\n    Fetches the object classname\n    \"\"\"\n    return f\"{obj.__class__.__module__}.{obj.__class__.__name__}\"\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.loads","title":"loads","text":"<pre><code>loads(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Loads the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def loads(self, value: Union[str, bytes], **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Loads the value\n    \"\"\"\n    try:\n        return self.decode(value, **kwargs)\n    except Exception as e:\n        if not self.is_encoder: logger.trace(f'[{self.name}] Error in Decoding: {str(value)[:500]}', e)\n        if self.raise_errors: raise DataError(f\"[{self.name}] Error in Decoding: {str(value)[:500]}\") from e\n        return None\n</code></pre>"},{"location":"api/serializers/pickle/#kvdb.io.serializers._pickle.PickleSerializer.set_default_lib","title":"set_default_lib  <code>classmethod</code>","text":"<pre><code>set_default_lib(\n    lib: typing.Union[\n        str,\n        kvdb.io.serializers._pickle.PickleLibT,\n        kvdb.io.serializers.base.ModuleType,\n    ],\n) -&gt; None\n</code></pre> <p>Sets the default Pickle library</p> Source code in <code>kvdb/io/serializers/_pickle.py</code> <pre><code>@classmethod\ndef set_default_lib(cls, lib: Union[str, PickleLibT, ModuleType]) -&gt; None:\n    \"\"\"\n    Sets the default Pickle library\n    \"\"\"\n    global default_pickle\n    if isinstance(lib, str):\n        lib = lazy_import(lib, is_module=True)\n    assert hasattr(lib, \"loads\") and hasattr(lib, \"dumps\"), f\"Invalid Pickle Library: `{lib}`\"\n    cls.picklelib = lib\n    default_pickle = lib\n</code></pre>"},{"location":"api/session-manager/api/","title":"KVDBClient","text":"<p>The <code>KVDBSessionManager</code> (accessed as <code>kvdb.KVDBClient</code>) class provides a context manager interface for managing sessions with the KVDB server. It keeps track and registration of all active sessions and provides a simple interface for managing session operations. It inherits from a <code>ProxyObject</code> Singleton to lazily initialize and prevent multiple instances of the session manager.</p>"},{"location":"api/session-manager/api/#api-reference","title":"API Reference","text":"<p>               Bases: <code>abc.ABC</code>, <code>lzl.proxied.Singleton</code></p> <p>The KVDB Session Manager</p> <p>Initializes the KVDB Session Manager</p> METHOD DESCRIPTION <code>add_session</code> <p>Adds a KVDB Session to the KVDB Session Manager</p> <code>get_pool</code> <p>Configures the session pools</p> <code>get_session</code> <p>Returns the KVDB Session with the given name</p> <code>init_session</code> <p>Initializes a KVDB Session that is managed by the KVDB Session Manager</p> <code>session</code> <p>Initializes a KVDB Session that is managed by the KVDB Session Manager</p> <code>set_session</code> <p>Set the current KVDB Session</p> <code>with_session</code> <p>Returns the session with the given name as the current session</p> Source code in <code>kvdb/client.py</code> <pre><code>def __init__(\n    self, \n    **kwargs\n):\n    \"\"\"\n    Initializes the KVDB Session Manager\n    \"\"\"\n    self.session_class: Optional[Type['KVDBSession']] = None\n    self.session_pool_class: Optional[Type['SessionPools']] = None\n    self.serializer_config_class: Optional[Type['SerializerConfig']] = None\n    self.url_class: Optional[Type['KVDBUrl']] = None\n    self.configure_classes()\n\n    from kvdb.configs import settings\n    from kvdb.types.contexts import GlobalKVDBContext\n\n    self.c = GlobalKVDBContext()\n    self.pools = self.c.pools\n    self.sessions = self.c.sessions\n    self.settings = settings\n    self.logger = self.settings.logger\n    self.autologger = self.settings.autologger\n    self.settings.configure(**kwargs)\n</code></pre>"},{"location":"api/session-manager/api/#kvdb.client.KVDBSessionManager.add_session","title":"add_session","text":"<pre><code>add_session(\n    session: \"KVDBSession\",\n    overwrite: typing.Optional[bool] = None,\n    set_as_ctx: typing.Optional[bool] = None,\n    **kwargs\n)\n</code></pre> <p>Adds a KVDB Session to the KVDB Session Manager</p> Source code in <code>kvdb/client.py</code> <pre><code>def add_session(\n    self,\n    session: 'KVDBSession',\n    overwrite: Optional[bool] = None,\n    set_as_ctx: Optional[bool] = None,\n    **kwargs,\n):\n    \"\"\"\n    Adds a KVDB Session to the KVDB Session Manager\n    \"\"\"\n    if not isinstance(session, 'KVDBSession'): raise ValueError(f'Invalid session type: {type(session)}')\n    if session.name in self.sessions and overwrite is not True:\n        raise ValueError(f'The session with name {session.name} already exists. Use overwrite = True to overwrite the session')\n    if set_as_ctx is None: set_as_ctx = not len(self.sessions)\n    self.sessions[session.name] = session\n    if set_as_ctx is True: self.c.set_ctx(name = session.name)\n</code></pre>"},{"location":"api/session-manager/api/#kvdb.client.KVDBSessionManager.get_pool","title":"get_pool","text":"<pre><code>get_pool(\n    name: str,\n    url: typing.Optional[\n        typing.Union[str, \"KVDBUrl\"]\n    ] = None,\n    serializer_config: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    disable_store: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; kvdb.types.contexts.SessionPools\n</code></pre> <p>Configures the session pools</p> Source code in <code>kvdb/client.py</code> <pre><code>def get_pool(\n    self,\n    name: str,\n    url: Optional[Union[str, 'KVDBUrl']] = None,\n    serializer_config: Optional[Dict[str, Any]] = None,\n    disable_store: Optional[bool] = None,\n    **kwargs,\n) -&gt; SessionPools:\n    \"\"\"\n    Configures the session pools\n    \"\"\"\n    if url is None: url = self.settings.url\n    if isinstance(url, str): url = self.url_class(url)\n    # url.set_key(name = name, serializer_config = serializer_config, **kwargs)\n    if url.key in self.pools: \n        if self.settings.debug:\n            self.autologger.info(f'Using existing pool with name {name} and url {url}: {url.key}')\n        return self.pools[url.key]\n    if self.settings.debug:\n        self.autologger.info(f'Creating newpool with name {name} and url {url}: {url.key}')\n\n    # Get the serializer config\n    # from kvdb.configs.base import SerializerConfig\n    serializer_config = self.serializer_config_class.extract_kwargs(_exclude_none = True, **kwargs) \\\n        if serializer_config is None else serializer_config\n\n    kwargs = {k : v for k, v in kwargs.items() if k not in serializer_config}\n\n    # Get the pool config\n    pool_config = self.settings.pool.model_dump(exclude_none = True)\n    pool_kwargs = self.settings.pool.extract_kwargs(_exclude_none = True, **kwargs)\n    if pool_kwargs: pool_config.update(pool_kwargs)\n    kwargs = {k : v for k, v in kwargs.items() if k not in pool_config}\n\n    # Get the pool class\n    pool_class = self.settings.pool.get_pool_class(pool_class=pool_config.pop('pool_class', None), is_async=False)\n    pool_max_connections = pool_config.pop('pool_max_connections', None)\n    # pool_autoclose = pool_config.pop('auto_close_connection_pool', None)\n    # pool_autoreset = pool_config.get('auto_reset_enabled')\n\n    apool_class = self.settings.pool.get_pool_class(pool_class=pool_config.pop('apool_class', None), is_async=True)\n    apool_max_connections = pool_config.pop('apool_max_connections', None)\n    # apool_autoclose = pool_config.get('auto_close_aconnection_pool', None)\n    if serializer_config: pool_config.update(serializer_config)\n\n    pool = self.session_pool_class(\n        name = name,\n        pool = pool_class.from_url(\n            url, max_connections = pool_max_connections, **pool_config,\n        ),\n        apool = apool_class.from_url(\n            url, max_connections = apool_max_connections, **pool_config,\n        ),\n    )\n    if not disable_store: self.pools[url.key] = pool\n    return pool\n</code></pre>"},{"location":"api/session-manager/api/#kvdb.client.KVDBSessionManager.get_session","title":"get_session","text":"<pre><code>get_session(\n    name: typing.Optional[str] = \"default\",\n    url: typing.Optional[\n        typing.Union[str, \"KVDBUrl\"]\n    ] = None,\n    db_id: typing.Optional[int] = None,\n    pool_class: typing.Optional[\n        typing.Union[str, typing.Type[\"ConnectionPoolT\"]]\n    ] = None,\n    pool_max_connections: typing.Optional[int] = None,\n    apool_class: typing.Optional[\n        typing.Union[\n            str, typing.Type[\"AsyncConnectionPoolT\"]\n        ]\n    ] = None,\n    apool_max_connections: typing.Optional[int] = None,\n    serializer: typing.Optional[str] = None,\n    serializer_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    compression: typing.Optional[str] = None,\n    compression_level: typing.Optional[int] = None,\n    compression_enabled: typing.Optional[bool] = None,\n    encoding: typing.Optional[str] = None,\n    decode_responses: typing.Optional[bool] = None,\n    socket_timeout: typing.Optional[float] = None,\n    socket_connect_timeout: typing.Optional[float] = None,\n    socket_keepalive: typing.Optional[bool] = None,\n    socket_keepalive_options: typing.Optional[\n        typing.Mapping[int, typing.Union[int, bytes]]\n    ] = None,\n    unix_socket_path: typing.Optional[str] = None,\n    ssl: typing.Optional[bool] = None,\n    ssl_keyfile: typing.Optional[str] = None,\n    ssl_certfile: typing.Optional[str] = None,\n    ssl_cert_reqs: typing.Optional[str] = None,\n    ssl_ca_certs: typing.Optional[str] = None,\n    ssl_ca_data: typing.Optional[str] = None,\n    ssl_check_hostname: bool = None,\n    retry_on_timeout: typing.Optional[bool] = None,\n    retry_on_error: typing.Optional[\n        typing.List[Exception]\n    ] = None,\n    retry_on_connection_error: typing.Optional[bool] = None,\n    retry_on_connection_reset_error: typing.Optional[\n        bool\n    ] = None,\n    retry_on_response_error: typing.Optional[bool] = None,\n    retry_enabled: typing.Optional[bool] = None,\n    retry_client_enabled: typing.Optional[bool] = None,\n    retry_client_max_attempts: typing.Optional[int] = None,\n    retry_client_max_delay: typing.Optional[float] = None,\n    retry_client_logging_level: typing.Optional[str] = None,\n    retry_pubsub_enabled: typing.Optional[bool] = None,\n    retry_pubsub_max_attempts: typing.Optional[int] = None,\n    retry_pubsub_max_delay: typing.Optional[float] = None,\n    retry_pubsub_logging_level: typing.Optional[str] = None,\n    retry_pipeline_enabled: typing.Optional[bool] = None,\n    retry_pipeline_max_attempts: typing.Optional[\n        int\n    ] = None,\n    retry_pipeline_max_delay: typing.Optional[float] = None,\n    retry_pipeline_logging_level: typing.Optional[\n        str\n    ] = None,\n    persistence_base_key: typing.Optional[str] = None,\n    persistence_expiration: typing.Optional[int] = None,\n    persistence_hset_disabled: typing.Optional[bool] = None,\n    persistence_keyjoin: typing.Optional[str] = None,\n    persistence_async_enabled: typing.Optional[bool] = None,\n    set_as_ctx: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; \"KVDBSession\"\n</code></pre> <pre><code>get_session(\n    name: typing.Optional[str] = None, **kwargs\n) -&gt; \"KVDBSession\"\n</code></pre> <p>Returns the KVDB Session with the given name</p> Source code in <code>kvdb/client.py</code> <pre><code>def get_session(\n    self,\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; 'KVDBSession':\n    \"\"\"\n    Returns the KVDB Session with the given name\n    \"\"\"\n    if name is None: name = self.c.current\n    if name is None: name = 'default'\n    if name not in self.sessions:\n        return self.session(name = name, **kwargs)\n    return self.sessions[name]\n</code></pre>"},{"location":"api/session-manager/api/#kvdb.client.KVDBSessionManager.init_session","title":"init_session","text":"<pre><code>init_session(\n    name: typing.Optional[str] = \"default\",\n    url: typing.Optional[\n        typing.Union[str, \"KVDBUrl\"]\n    ] = None,\n    db_id: typing.Optional[int] = None,\n    pool_class: typing.Optional[\n        typing.Union[\n            str,\n            typing.Type[\n                kvdb.components.connection_pool.ConnectionPoolT\n            ],\n        ]\n    ] = None,\n    pool_max_connections: typing.Optional[int] = None,\n    apool_class: typing.Optional[\n        typing.Union[\n            str,\n            typing.Type[\n                kvdb.components.connection_pool.AsyncConnectionPoolT\n            ],\n        ]\n    ] = None,\n    apool_max_connections: typing.Optional[int] = None,\n    serializer: typing.Optional[str] = None,\n    serializer_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    compression: typing.Optional[str] = None,\n    compression_level: typing.Optional[int] = None,\n    compression_enabled: typing.Optional[bool] = None,\n    encoding: typing.Optional[str] = None,\n    decode_responses: typing.Optional[bool] = None,\n    socket_timeout: typing.Optional[float] = None,\n    socket_connect_timeout: typing.Optional[float] = None,\n    socket_keepalive: typing.Optional[bool] = None,\n    socket_keepalive_options: typing.Optional[\n        typing.Mapping[int, typing.Union[int, bytes]]\n    ] = None,\n    unix_socket_path: typing.Optional[str] = None,\n    ssl: typing.Optional[bool] = None,\n    ssl_keyfile: typing.Optional[str] = None,\n    ssl_certfile: typing.Optional[str] = None,\n    ssl_cert_reqs: typing.Optional[str] = None,\n    ssl_ca_certs: typing.Optional[str] = None,\n    ssl_ca_data: typing.Optional[str] = None,\n    ssl_check_hostname: bool = None,\n    retry_on_timeout: typing.Optional[bool] = None,\n    retry_on_error: typing.Optional[\n        typing.List[Exception]\n    ] = None,\n    retry_on_connection_error: typing.Optional[bool] = None,\n    retry_on_connection_reset_error: typing.Optional[\n        bool\n    ] = None,\n    retry_on_response_error: typing.Optional[bool] = None,\n    retry_enabled: typing.Optional[bool] = None,\n    retry_client_enabled: typing.Optional[bool] = None,\n    retry_client_max_attempts: typing.Optional[int] = None,\n    retry_client_max_delay: typing.Optional[float] = None,\n    retry_client_logging_level: typing.Optional[str] = None,\n    retry_pubsub_enabled: typing.Optional[bool] = None,\n    retry_pubsub_max_attempts: typing.Optional[int] = None,\n    retry_pubsub_max_delay: typing.Optional[float] = None,\n    retry_pubsub_logging_level: typing.Optional[str] = None,\n    retry_pipeline_enabled: typing.Optional[bool] = None,\n    retry_pipeline_max_attempts: typing.Optional[\n        int\n    ] = None,\n    retry_pipeline_max_delay: typing.Optional[float] = None,\n    retry_pipeline_logging_level: typing.Optional[\n        str\n    ] = None,\n    persistence_base_key: typing.Optional[str] = None,\n    persistence_expiration: typing.Optional[int] = None,\n    persistence_hset_disabled: typing.Optional[bool] = None,\n    persistence_keyjoin: typing.Optional[str] = None,\n    persistence_async_enabled: typing.Optional[bool] = None,\n    set_as_ctx: typing.Optional[bool] = None,\n    overwrite: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; \"KVDBSession\"\n</code></pre> <pre><code>init_session(\n    name: typing.Optional[str] = \"default\",\n    url: typing.Optional[\n        typing.Union[str, kvdb.types.base.KVDBUrl]\n    ] = None,\n    db_id: typing.Optional[int] = None,\n    set_as_ctx: typing.Optional[bool] = None,\n    overwrite: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; \"KVDBSession\"\n</code></pre> <p>Initializes a KVDB Session that is managed by the KVDB Session Manager</p> <ul> <li>Raises an error if the session already exists</li> </ul> Source code in <code>kvdb/client.py</code> <pre><code>def init_session(\n    self,\n    name: Optional[str] = 'default',\n    url: Optional[Union[str, KVDBUrl]] = None,\n    db_id: Optional[int] = None,\n    set_as_ctx: Optional[bool] = None,\n    overwrite: Optional[bool] = None,\n    **kwargs,\n) -&gt; 'KVDBSession':\n    \"\"\"\n    Initializes a KVDB Session that is managed by the KVDB Session Manager\n\n    - Raises an error if the session already exists\n    \"\"\"\n    if name in self.sessions and overwrite is not True:\n        raise ValueError(f'The session with name {name} already exists. Use overwrite = True to overwrite the session')\n    return self.session(name = name, url = url, db_id = db_id, set_as_ctx = set_as_ctx, overwrite = overwrite, **kwargs)\n</code></pre>"},{"location":"api/session-manager/api/#kvdb.client.KVDBSessionManager.session","title":"session","text":"<pre><code>session(\n    name: typing.Optional[str] = \"default\",\n    url: typing.Optional[\n        typing.Union[str, \"KVDBUrl\"]\n    ] = None,\n    db_id: typing.Optional[int] = None,\n    pool_class: typing.Optional[\n        typing.Union[str, typing.Type[\"ConnectionPoolT\"]]\n    ] = None,\n    pool_max_connections: typing.Optional[int] = None,\n    apool_class: typing.Optional[\n        typing.Union[\n            str, typing.Type[\"AsyncConnectionPoolT\"]\n        ]\n    ] = None,\n    apool_max_connections: typing.Optional[int] = None,\n    serializer: typing.Optional[str] = None,\n    serializer_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    compression: typing.Optional[str] = None,\n    compression_level: typing.Optional[int] = None,\n    compression_enabled: typing.Optional[bool] = None,\n    encoding: typing.Optional[str] = None,\n    decode_responses: typing.Optional[bool] = None,\n    socket_timeout: typing.Optional[float] = None,\n    socket_connect_timeout: typing.Optional[float] = None,\n    socket_keepalive: typing.Optional[bool] = None,\n    socket_keepalive_options: typing.Optional[\n        typing.Mapping[int, typing.Union[int, bytes]]\n    ] = None,\n    unix_socket_path: typing.Optional[str] = None,\n    ssl: typing.Optional[bool] = None,\n    ssl_keyfile: typing.Optional[str] = None,\n    ssl_certfile: typing.Optional[str] = None,\n    ssl_cert_reqs: typing.Optional[str] = None,\n    ssl_ca_certs: typing.Optional[str] = None,\n    ssl_ca_data: typing.Optional[str] = None,\n    ssl_check_hostname: bool = None,\n    retry_on_timeout: typing.Optional[bool] = None,\n    retry_on_error: typing.Optional[\n        typing.List[Exception]\n    ] = None,\n    retry_on_connection_error: typing.Optional[bool] = None,\n    retry_on_connection_reset_error: typing.Optional[\n        bool\n    ] = None,\n    retry_on_response_error: typing.Optional[bool] = None,\n    retry_enabled: typing.Optional[bool] = None,\n    retry_client_enabled: typing.Optional[bool] = None,\n    retry_client_max_attempts: typing.Optional[int] = None,\n    retry_client_max_delay: typing.Optional[float] = None,\n    retry_client_logging_level: typing.Optional[str] = None,\n    retry_pubsub_enabled: typing.Optional[bool] = None,\n    retry_pubsub_max_attempts: typing.Optional[int] = None,\n    retry_pubsub_max_delay: typing.Optional[float] = None,\n    retry_pubsub_logging_level: typing.Optional[str] = None,\n    retry_pipeline_enabled: typing.Optional[bool] = None,\n    retry_pipeline_max_attempts: typing.Optional[\n        int\n    ] = None,\n    retry_pipeline_max_delay: typing.Optional[float] = None,\n    retry_pipeline_logging_level: typing.Optional[\n        str\n    ] = None,\n    persistence_base_key: typing.Optional[str] = None,\n    persistence_expiration: typing.Optional[int] = None,\n    persistence_hset_disabled: typing.Optional[bool] = None,\n    persistence_keyjoin: typing.Optional[str] = None,\n    persistence_async_enabled: typing.Optional[bool] = None,\n    set_as_ctx: typing.Optional[bool] = None,\n    overwrite: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; \"KVDBSession\"\n</code></pre> <pre><code>session(\n    name: typing.Optional[str] = \"default\",\n    url: typing.Optional[\n        typing.Union[str, \"KVDBUrl\"]\n    ] = None,\n    db_id: typing.Optional[int] = None,\n    set_as_ctx: typing.Optional[bool] = None,\n    overwrite: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; \"KVDBSession\"\n</code></pre> <p>Initializes a KVDB Session that is managed by the KVDB Session Manager</p> Source code in <code>kvdb/client.py</code> <pre><code>def session(\n    self,\n    name: Optional[str] = 'default',\n    url: Optional[Union[str, 'KVDBUrl']] = None,\n    db_id: Optional[int] = None,\n    set_as_ctx: Optional[bool] = None,\n    overwrite: Optional[bool] = None,\n    **kwargs,\n) -&gt; 'KVDBSession':\n    \"\"\"\n    Initializes a KVDB Session that is managed by the KVDB Session Manager\n    \"\"\"\n    if name in self.sessions and overwrite is not True:\n        if set_as_ctx is True: self.c.set_ctx(name = name)\n        return self.sessions[name]\n\n    session = self.create_session(name = name, url = url, db_id = db_id, **kwargs)\n    if set_as_ctx is None: set_as_ctx = not len(self.sessions)\n    self.sessions[name] = session\n    if set_as_ctx is True: self.c.set_ctx(name = name)\n    return session\n</code></pre>"},{"location":"api/session-manager/api/#kvdb.client.KVDBSessionManager.set_session","title":"set_session","text":"<pre><code>set_session(name: str, **kwargs)\n</code></pre> <p>Set the current KVDB Session</p> Source code in <code>kvdb/client.py</code> <pre><code>def set_session(\n    self,\n    name: str,\n    **kwargs,\n):\n    \"\"\"\n    Set the current KVDB Session\n    \"\"\"\n    if name not in self.sessions: raise ValueError(f'Invalid session name: {name}')\n    self.c.set_ctx(name = name)    \n</code></pre>"},{"location":"api/session-manager/api/#kvdb.client.KVDBSessionManager.with_session","title":"with_session","text":"<pre><code>with_session(name: str) -&gt; typing.Iterator['KVDBSession']\n</code></pre> <p>Returns the session with the given name as the current session</p> Source code in <code>kvdb/client.py</code> <pre><code>@contextlib.contextmanager\ndef with_session(self, name: str) -&gt; Iterator['KVDBSession']:\n    \"\"\"\n    Returns the session with the given name as the current session\n    \"\"\"\n    if name not in self.sessions: \n        raise ValueError(f'Invalid session name: `{name}`. Initialize the session first using `session` or `init_session`')\n    yield self.sessions[name]\n</code></pre>"},{"location":"api/sessions/api/","title":"KVDBSession","text":"<p>Sessions are the underlying object that contains the state of a single <code>KVDB</code> connection to a server. This session contains both asynchronous and synchronous methods for interacting with the server, as well as methods for managing the session itself.</p> <p>The underlying connection pools are managed by the <code>KVDBClient</code> class, which is a singleton that manages all sessions. This allows you to create multiple sessions with different configurations, but still share the same underlying connection pool, unless there is any configuration differences that would require a new connection pool.</p>"},{"location":"api/sessions/api/#api-reference","title":"API Reference","text":"<p>               Bases: <code>abc.ABC</code></p> <p>The KVDB Session protocol</p> <p>Initializes the KVDB Session</p> METHOD DESCRIPTION <code>__aenter__</code> <p>Enter the runtime context related to this object.</p> <code>__aexit__</code> <p>Close the session</p> <code>__contains__</code> <p>[Dict] Returns whether the key exists</p> <code>__delitem__</code> <p>[Dict] Deletes the key</p> <code>__enter__</code> <p>Enter the runtime context related to this object.</p> <code>__exit__</code> <p>On exit, close the session</p> <code>__getitem__</code> <p>[Dict] Returns the value for the given key</p> <code>__setitem__</code> <p>[Dict] Sets the value for the given key</p> <code>aacl_cat</code> <p>Returns a list of categories or commands within a category.</p> <code>aacl_deluser</code> <p>Delete the ACL for the specified <code>username</code>s</p> <code>aacl_dryrun</code> <p>Simulate the execution of a given command by a given <code>username</code>.</p> <code>aacl_genpass</code> <p>Generate a random password value.</p> <code>aacl_getuser</code> <p>Get the ACL details for the specified <code>username</code>.</p> <code>aacl_help</code> <p>The ACL HELP command returns helpful text describing</p> <code>aacl_list</code> <p>Return a list of all ACLs on the server</p> <code>aacl_load</code> <p>Load ACL rules from the configured <code>aclfile</code>.</p> <code>aacl_log</code> <p>Get ACL logs as a list.</p> <code>aacl_log_reset</code> <p>Reset ACL logs.</p> <code>aacl_save</code> <p>Save ACL rules to the configured <code>aclfile</code>.</p> <code>aacl_setuser</code> <p>Create or update an ACL user.</p> <code>aacl_users</code> <p>Returns a list of all registered users on the server.</p> <code>aacl_whoami</code> <p>Get the username for the current connection</p> <code>aappend</code> <p>Appends the string <code>value</code> to the value at <code>key</code>. If <code>key</code></p> <code>aauth</code> <p>Authenticates the user. If you do not pass username, Redis will try to</p> <code>abgrewriteaof</code> <p>Tell the Redis server to rewrite the AOF file from data in memory.</p> <code>abgsave</code> <p>Tell the Redis server to save its data to disk.  Unlike save(),</p> <code>abitcount</code> <p>Returns the count of set bits in the value of <code>key</code>.  Optional</p> <code>abitfield</code> <p>Return a BitFieldOperation instance to conveniently construct one or</p> <code>abitfield_ro</code> <p>Return an array of the specified bitfield values</p> <code>abitop</code> <p>Perform a bitwise operation using <code>operation</code> between <code>keys</code> and</p> <code>abitpos</code> <p>Return the position of the first bit set to 1 or 0 in a string.</p> <code>ablmove</code> <p>Blocking version of lmove.</p> <code>ablmpop</code> <p>Pop <code>count</code> values (default 1) from first non-empty in the list</p> <code>ablpop</code> <p>LPOP a value off of the first non-empty list</p> <code>abrpop</code> <p>RPOP a value off of the first non-empty list</p> <code>abrpoplpush</code> <p>Pop a value off the tail of <code>src</code>, push it on the head of <code>dst</code></p> <code>abzmpop</code> <p>Pop <code>count</code> values (default 1) off of the first non-empty sorted set</p> <code>abzpopmax</code> <p>ZPOPMAX a value off of the first non-empty sorted set</p> <code>abzpopmin</code> <p>ZPOPMIN a value off of the first non-empty sorted set</p> <code>acl_cat</code> <p>Returns a list of categories or commands within a category.</p> <code>acl_deluser</code> <p>Delete the ACL for the specified <code>username</code>s</p> <code>acl_dryrun</code> <p>Simulate the execution of a given command by a given <code>username</code>.</p> <code>acl_genpass</code> <p>Generate a random password value.</p> <code>acl_getuser</code> <p>Get the ACL details for the specified <code>username</code>.</p> <code>acl_help</code> <p>The ACL HELP command returns helpful text describing</p> <code>acl_list</code> <p>Return a list of all ACLs on the server</p> <code>acl_load</code> <p>Load ACL rules from the configured <code>aclfile</code>.</p> <code>acl_log</code> <p>Get ACL logs as a list.</p> <code>acl_log_reset</code> <p>Reset ACL logs.</p> <code>acl_save</code> <p>Save ACL rules to the configured <code>aclfile</code>.</p> <code>acl_setuser</code> <p>Create or update an ACL user.</p> <code>acl_users</code> <p>Returns a list of all registered users on the server.</p> <code>acl_whoami</code> <p>Get the username for the current connection</p> <code>aclear</code> <p>Clears the current database</p> <code>aclient_getname</code> <p>Returns the current connection name</p> <code>aclient_getredir</code> <p>Returns the ID (an integer) of the client to whom we are</p> <code>aclient_id</code> <p>Returns the current connection id</p> <code>aclient_info</code> <p>Returns information and statistics about the current</p> <code>aclient_kill</code> <p>Disconnects the client at <code>address</code> (ip:port)</p> <code>aclient_kill_filter</code> <p>Disconnects client(s) using a variety of filter options</p> <code>aclient_list</code> <p>Returns a list of currently connected clients.</p> <code>aclient_no_evict</code> <p>Sets the client eviction mode for the current connection.</p> <code>aclient_no_touch</code> <code>aclient_pause</code> <p>Suspend all the Redis clients for the specified amount of time.</p> <code>aclient_reply</code> <p>Enable and disable redis server replies.</p> <code>aclient_setinfo</code> <p>Sets the current connection library name or version</p> <code>aclient_setname</code> <p>Sets the current connection name</p> <code>aclient_tracking</code> <p>Enables the tracking feature of the Redis server, that is used</p> <code>aclient_tracking_off</code> <p>Turn off the tracking mode.</p> <code>aclient_tracking_on</code> <p>Turn on the tracking mode.</p> <code>aclient_trackinginfo</code> <p>Returns the information about the current client connection's</p> <code>aclient_unblock</code> <p>Unblocks a connection by its client id.</p> <code>aclient_unpause</code> <p>Unpause all redis clients</p> <code>aclose</code> <p>Close the session</p> <code>aclose_locks</code> <p>Closes the locks that are currently managed by the session</p> <code>acommand_docs</code> <p>This function throws a NotImplementedError since it is intentionally</p> <code>acommand_getkeysandflags</code> <p>Returns array of keys from a full Redis command and their usage flags.</p> <code>acommand_list</code> <p>Return an array of the server's command names.</p> <code>aconfig_get</code> <p>Return a dictionary of configuration based on the <code>pattern</code></p> <code>aconfig_resetstat</code> <p>Reset runtime statistics</p> <code>aconfig_rewrite</code> <p>Rewrite config file with the minimal change to reflect running config.</p> <code>aconfig_set</code> <p>Set config item <code>name</code> with <code>value</code></p> <code>acopy</code> <p>Copy the value stored in the <code>source</code> key to the <code>destination</code> key.</p> <code>adbsize</code> <p>Returns the number of keys in the current database</p> <code>adebug_object</code> <p>Returns version specific meta information about a given key</p> <code>adecrby</code> <p>Decrements the value of <code>key</code> by <code>amount</code>.  If no key exists,</p> <code>adelete</code> <p>Delete one or more keys specified by <code>names</code></p> <code>adelitem</code> <p>[Dict] Deletes the key</p> <code>adump</code> <p>Return a serialized version of the value stored at the specified key.</p> <code>aecho</code> <p>Echo the string back from the server</p> <code>aeval</code> <p>Execute the Lua <code>script</code>, specifying the <code>numkeys</code> the script</p> <code>aeval_ro</code> <p>The read-only variant of the EVAL command</p> <code>aevalsha</code> <p>Use the <code>sha</code> to execute a Lua script already registered via EVAL</p> <code>aevalsha_ro</code> <p>The read-only variant of the EVALSHA command</p> <code>aexecute_command</code> <p>Execute a command and return a parsed response</p> <code>aexists</code> <p>Returns the number of <code>names</code> that exist</p> <code>aexpire</code> <p>Set an expire flag on key <code>name</code> for <code>time</code> seconds with given</p> <code>aexpireat</code> <p>Set an expire flag on key <code>name</code> with given <code>option</code>. <code>when</code></p> <code>aexpiretime</code> <p>Returns the absolute Unix timestamp (since January 1, 1970) in seconds</p> <code>afailover</code> <p>This function throws a NotImplementedError since it is intentionally</p> <code>afcall</code> <p>Invoke a function.</p> <code>afcall_ro</code> <p>This is a read-only variant of the FCALL command that cannot</p> <code>aflushall</code> <p>Delete all keys in all databases on the current host.</p> <code>aflushdb</code> <p>Delete all keys in the current database.</p> <code>afunction_delete</code> <p>Delete the library called <code>library</code> and all its functions.</p> <code>afunction_dump</code> <p>Return the serialized payload of loaded libraries.</p> <code>afunction_flush</code> <p>Deletes all the libraries.</p> <code>afunction_kill</code> <p>Kill a function that is currently executing.</p> <code>afunction_list</code> <p>Return information about the functions and libraries.</p> <code>afunction_load</code> <p>Load a library to Redis.</p> <code>afunction_restore</code> <p>Restore libraries from the serialized <code>payload</code>.</p> <code>afunction_stats</code> <p>Return information about the function that's currently running</p> <code>ageoadd</code> <p>Add the specified geospatial items to the specified key identified</p> <code>ageodist</code> <p>Return the distance between <code>place1</code> and <code>place2</code> members of the</p> <code>ageohash</code> <p>Return the geo hash string for each item of <code>values</code> members of</p> <code>ageopos</code> <p>Return the positions of each item of <code>values</code> as members of</p> <code>ageoradius</code> <p>Return the members of the specified key identified by the</p> <code>ageoradiusbymember</code> <p>This command is exactly like <code>georadius</code> with the sole difference</p> <code>ageosearch</code> <p>Return the members of specified key identified by the</p> <code>ageosearchstore</code> <p>This command is like GEOSEARCH, but stores the result in</p> <code>aget</code> <p>Return the value at key <code>name</code>, or None if the key doesn't exist</p> <code>agetbit</code> <p>Returns an integer indicating the value of <code>offset</code> in <code>name</code></p> <code>agetdel</code> <p>Get the value at key <code>name</code> and delete the key. This command</p> <code>agetex</code> <p>Get the value of key and optionally set its expiration.</p> <code>agetitem</code> <p>[Dict] Returns the value for the given key</p> <code>agetrange</code> <p>Returns the substring of the string value stored at <code>key</code>,</p> <code>agetset</code> <p>Sets the value at key <code>name</code> to <code>value</code></p> <code>ahdel</code> <p>Delete <code>keys</code> from hash <code>name</code></p> <code>ahello</code> <p>This function throws a NotImplementedError since it is intentionally</p> <code>ahexists</code> <p>Returns a boolean indicating if <code>key</code> exists within hash <code>name</code></p> <code>ahget</code> <p>Return the value of <code>key</code> within the hash <code>name</code></p> <code>ahgetall</code> <p>Return a Python dict of the hash's name/value pairs</p> <code>ahincrby</code> <p>Increment the value of <code>key</code> in hash <code>name</code> by <code>amount</code></p> <code>ahincrbyfloat</code> <p>Increment the value of <code>key</code> in hash <code>name</code> by floating <code>amount</code></p> <code>ahkeys</code> <p>Return the list of keys within hash <code>name</code></p> <code>ahlen</code> <p>Return the number of elements in hash <code>name</code></p> <code>ahmget</code> <p>Returns a list of values ordered identically to <code>keys</code></p> <code>ahmset</code> <p>Set key to value within hash <code>name</code> for each corresponding</p> <code>ahrandfield</code> <p>Return a random field from the hash value stored at key.</p> <code>ahscan</code> <p>Incrementally return key/value slices in a hash. Also return a cursor</p> <code>ahscan_iter</code> <p>Make an iterator using the HSCAN command so that the client doesn't</p> <code>ahset</code> <p>Set <code>key</code> to <code>value</code> within hash <code>name</code>,</p> <code>ahsetnx</code> <p>Set <code>key</code> to <code>value</code> within hash <code>name</code> if <code>key</code> does not</p> <code>ahstrlen</code> <p>Return the number of bytes stored in the value of <code>key</code></p> <code>ahvals</code> <p>Return the list of values within hash <code>name</code></p> <code>aincrby</code> <p>Increments the value of <code>key</code> by <code>amount</code>.  If no key exists,</p> <code>aincrbyfloat</code> <p>Increments the value at key <code>name</code> by floating <code>amount</code>.</p> <code>ainfo</code> <p>Returns a dictionary containing information about the Redis server</p> <code>akeys</code> <p>Returns a list of keys matching <code>pattern</code></p> <code>alastsave</code> <p>Return a Python datetime object representing the last time the</p> <code>alatency_doctor</code> <p>Raise a NotImplementedError, as the client will not support LATENCY DOCTOR.</p> <code>alatency_graph</code> <p>Raise a NotImplementedError, as the client will not support LATENCY GRAPH.</p> <code>alatency_histogram</code> <p>This function throws a NotImplementedError since it is intentionally</p> <code>alatency_history</code> <p>Returns the raw data of the <code>event</code>'s latency spikes time series.</p> <code>alatency_latest</code> <p>Reports the latest latency events logged.</p> <code>alatency_reset</code> <p>Resets the latency spikes time series of all, or only some, events.</p> <code>alcs</code> <p>Find the longest common subsequence between <code>key1</code> and <code>key2</code>.</p> <code>alindex</code> <p>Return the item from list <code>name</code> at position <code>index</code></p> <code>alinsert</code> <p>Insert <code>value</code> in list <code>name</code> either immediately before or after</p> <code>allen</code> <p>Return the length of the list <code>name</code></p> <code>almove</code> <p>Atomically returns and removes the first/last element of a list,</p> <code>almpop</code> <p>Pop <code>count</code> values (default 1) first non-empty list key from the list</p> <code>alock</code> <p>Create a new Lock instance named <code>name</code> using the Redis client</p> <code>alolwut</code> <p>Get the Redis version and a piece of generative computer art</p> <code>alpop</code> <p>Removes and returns the first elements of the list <code>name</code>.</p> <code>alpos</code> <p>Get position of <code>value</code> within the list <code>name</code></p> <code>alpush</code> <p>Push <code>values</code> onto the head of the list <code>name</code></p> <code>alpushx</code> <p>Push <code>value</code> onto the head of the list <code>name</code> if <code>name</code> exists</p> <code>alrange</code> <p>Return a slice of the list <code>name</code> between</p> <code>alrem</code> <p>Remove the first <code>count</code> occurrences of elements equal to <code>value</code></p> <code>alset</code> <p>Set element at <code>index</code> of list <code>name</code> to <code>value</code></p> <code>altrim</code> <p>Trim the list <code>name</code>, removing all values not within the slice</p> <code>amemory_malloc_stats</code> <p>Return an internal statistics report from the memory allocator.</p> <code>amemory_purge</code> <p>Attempts to purge dirty pages for reclamation by allocator</p> <code>amemory_stats</code> <p>Return a dictionary of memory stats</p> <code>amemory_usage</code> <p>Return the total memory usage for key, its value and associated</p> <code>amget</code> <p>Returns a list of values ordered identically to <code>keys</code></p> <code>amigrate</code> <p>Migrate 1 or more keys from the current Redis server to a different</p> <code>amodule_list</code> <p>Returns a list of dictionaries containing the name and version of</p> <code>amodule_load</code> <p>Loads the module from <code>path</code>.</p> <code>amodule_loadex</code> <p>Loads a module from a dynamic library at runtime with configuration directives.</p> <code>amodule_unload</code> <p>Unloads the module <code>name</code>.</p> <code>amove</code> <p>Moves the key <code>name</code> to a different Redis database <code>db</code></p> <code>amset</code> <p>Sets key/values based on a mapping. Mapping is a dictionary of</p> <code>amsetnx</code> <p>Sets key/values based on a mapping if none of the keys are already set.</p> <code>aobject</code> <p>Return the encoding, idletime, or refcount about the key</p> <code>aoverflow</code> <p>Update the overflow algorithm of successive INCRBY operations</p> <code>apersist</code> <p>Removes an expiration on <code>name</code></p> <code>apexpire</code> <p>Set an expire flag on key <code>name</code> for <code>time</code> milliseconds</p> <code>apexpireat</code> <p>Set an expire flag on key <code>name</code> with given <code>option</code>. <code>when</code></p> <code>apexpiretime</code> <p>Returns the absolute Unix timestamp (since January 1, 1970) in milliseconds</p> <code>apfadd</code> <p>Adds the specified elements to the specified HyperLogLog.</p> <code>apfcount</code> <p>Return the approximated cardinality of</p> <code>apfmerge</code> <p>Merge N different HyperLogLogs into a single one.</p> <code>aping</code> <p>Ping the Redis server</p> <code>apipeline</code> <p>Return a new pipeline object that can queue multiple commands for</p> <code>append</code> <p>Appends the string <code>value</code> to the value at <code>key</code>. If <code>key</code></p> <code>apsetex</code> <p>Set the value of key <code>name</code> to <code>value</code> that expires in <code>time_ms</code></p> <code>apsync</code> <p>Initiates a replication stream from the master.</p> <code>apttl</code> <p>Returns the number of milliseconds until the key <code>name</code> will expire</p> <code>apublish</code> <p>Publish <code>message</code> on <code>channel</code>.</p> <code>apubsub</code> <p>Return a Publish/Subscribe object. With this object, you can</p> <code>apubsub_channels</code> <p>Return a list of channels that have at least one subscriber</p> <code>apubsub_numpat</code> <p>Returns the number of subscriptions to patterns</p> <code>apubsub_numsub</code> <p>Return a list of (channel, number of subscribers) tuples</p> <code>apubsub_shardchannels</code> <p>Return a list of shard_channels that have at least one subscriber</p> <code>apubsub_shardnumsub</code> <p>Return a list of (shard_channel, number of subscribers) tuples</p> <code>aquit</code> <p>Ask the server to close the connection.</p> <code>arandomkey</code> <p>Returns the name of a random key</p> <code>areadonly</code> <p>Enables read queries for a connection to a Redis Cluster replica node.</p> <code>areadwrite</code> <p>Disables read queries for a connection to a Redis Cluster slave node.</p> <code>aregister_script</code> <p>Register a Lua <code>script</code> specifying the <code>keys</code> it will touch.</p> <code>arename</code> <p>Rename key <code>src</code> to <code>dst</code></p> <code>arenamenx</code> <p>Rename key <code>src</code> to <code>dst</code> if <code>dst</code> doesn't already exist</p> <code>areplicaof</code> <p>Update the replication settings of a redis replica, on the fly.</p> <code>areset</code> <p>Reset the state of the instance to when it was constructed</p> <code>arestore</code> <p>Create a key using the provided serialized value, previously obtained</p> <code>arole</code> <p>Provide information on the role of a Redis instance in</p> <code>arpop</code> <p>Removes and returns the last elements of the list <code>name</code>.</p> <code>arpoplpush</code> <p>RPOP a value off of the <code>src</code> list and atomically LPUSH it</p> <code>arpush</code> <p>Push <code>values</code> onto the tail of the list <code>name</code></p> <code>arpushx</code> <p>Push <code>value</code> onto the tail of the list <code>name</code> if <code>name</code> exists</p> <code>asadd</code> <p>Add <code>value(s)</code> to set <code>name</code></p> <code>asave</code> <p>Tell the Redis server to save its data to disk,</p> <code>ascan</code> <p>Incrementally return lists of key names. Also return a cursor</p> <code>ascan_iter</code> <p>Make an iterator using the SCAN command so that the client doesn't</p> <code>ascard</code> <p>Return the number of elements in set <code>name</code></p> <code>ascript_exists</code> <p>Check if a script exists in the script cache by specifying the SHAs of</p> <code>ascript_flush</code> <p>Flush all scripts from the script cache.</p> <code>ascript_kill</code> <p>Kill the currently executing Lua script</p> <code>ascript_load</code> <p>Load a Lua <code>script</code> into the script cache. Returns the SHA.</p> <code>asdiff</code> <p>Return the difference of sets specified by <code>keys</code></p> <code>asdiffstore</code> <p>Store the difference of sets specified by <code>keys</code> into a new</p> <code>aselect</code> <p>Select the Redis logical database at index.</p> <code>aset</code> <p>Set the value at key <code>name</code> to <code>value</code></p> <code>asetbit</code> <p>Flag the <code>offset</code> in <code>name</code> as <code>value</code>. Returns an integer</p> <code>asetex</code> <p>Set the value of key <code>name</code> to <code>value</code> that expires in <code>time</code></p> <code>asetitem</code> <p>[Dict] Sets the value for the given key</p> <code>asetnx</code> <p>Set the value of key <code>name</code> to <code>value</code> if key doesn't exist</p> <code>asetrange</code> <p>Overwrite bytes in the value of <code>name</code> starting at <code>offset</code> with</p> <code>ashutdown</code> <p>Shutdown the Redis server.  If Redis has persistence configured,</p> <code>asinter</code> <p>Return the intersection of sets specified by <code>keys</code></p> <code>asintercard</code> <p>Return the cardinality of the intersect of multiple sets specified by <code>`keys</code>.</p> <code>asinterstore</code> <p>Store the intersection of sets specified by <code>keys</code> into a new</p> <code>asismember</code> <p>Return whether <code>value</code> is a member of set <code>name</code>:</p> <code>aslaveof</code> <p>Set the server to be a replicated slave of the instance identified</p> <code>aslowlog_get</code> <p>Get the entries from the slowlog. If <code>num</code> is specified, get the</p> <code>aslowlog_len</code> <p>Get the number of items in the slowlog</p> <code>aslowlog_reset</code> <p>Remove all items in the slowlog</p> <code>asmembers</code> <p>Return all members of the set <code>name</code></p> <code>asmismember</code> <p>Return whether each value in <code>values</code> is a member of the set <code>name</code></p> <code>asmove</code> <p>Move <code>value</code> from set <code>src</code> to set <code>dst</code> atomically</p> <code>asort</code> <p>Sort and return the list, set or sorted set at <code>name</code>.</p> <code>asort_ro</code> <p>Returns the elements contained in the list, set or sorted set at key.</p> <code>aspop</code> <p>Remove and return a random member of set <code>name</code></p> <code>aspublish</code> <p>Posts a message to the given shard channel.</p> <code>asrandmember</code> <p>If <code>number</code> is None, returns a random member of set <code>name</code>.</p> <code>asrem</code> <p>Remove <code>values</code> from set <code>name</code></p> <code>asscan</code> <p>Incrementally return lists of elements in a set. Also return a cursor</p> <code>asscan_iter</code> <p>Make an iterator using the SSCAN command so that the client doesn't</p> <code>astralgo</code> <p>Implements complex algorithms that operate on strings.</p> <code>astrlen</code> <p>Return the number of bytes stored in the value of <code>name</code></p> <code>asubstr</code> <p>Return a substring of the string at key <code>name</code>. <code>start</code> and <code>end</code></p> <code>asunion</code> <p>Return the union of sets specified by <code>keys</code></p> <code>asunionstore</code> <p>Store the union of sets specified by <code>keys</code> into a new</p> <code>aswapdb</code> <p>Swap two databases</p> <code>async_</code> <p>Initiates a replication stream from the master.</p> <code>atfcall</code> <p>Invoke a function.</p> <code>atfcall_async</code> <p>Invoke an async function (coroutine).</p> <code>atfunction_delete</code> <p>Delete a library from RedisGears.</p> <code>atfunction_list</code> <p>List the functions with additional information about each function.</p> <code>atfunction_load</code> <p>Load a new library to RedisGears.</p> <code>atime</code> <p>Returns the server time as a 2-item tuple of ints:</p> <code>atouch</code> <p>Alters the last access time of a key(s) <code>*args</code>. A key is ignored</p> <code>attl</code> <p>Returns the number of seconds until the key <code>name</code> will expire</p> <code>atype</code> <p>Returns the type of key <code>name</code></p> <code>aunlink</code> <p>Unlink one or more keys specified by <code>names</code></p> <code>aunwatch</code> <p>Unwatches the value at key <code>name</code>, or None of the key doesn't exist</p> <code>auth</code> <p>Authenticates the user. If you do not pass username, Redis will try to</p> <code>await_</code> <p>Redis synchronous replication</p> <code>awaitaof</code> <p>This command blocks the current client until all previous write</p> <code>awatch</code> <p>Watches the values at keys <code>names</code>, or None if the key doesn't exist</p> <code>axack</code> <p>Acknowledges the successful processing of one or more messages.</p> <code>axadd</code> <p>Add to a stream.</p> <code>axautoclaim</code> <p>Transfers ownership of pending stream entries that match the specified</p> <code>axclaim</code> <p>Changes the ownership of a pending message.</p> <code>axdel</code> <p>Deletes one or more messages from a stream.</p> <code>axgroup_create</code> <p>Create a new consumer group associated with a stream.</p> <code>axgroup_createconsumer</code> <p>Consumers in a consumer group are auto-created every time a new</p> <code>axgroup_delconsumer</code> <p>Remove a specific consumer from a consumer group.</p> <code>axgroup_destroy</code> <p>Destroy a consumer group.</p> <code>axgroup_setid</code> <p>Set the consumer group last delivered ID to something else.</p> <code>axinfo_consumers</code> <p>Returns general information about the consumers in the group.</p> <code>axinfo_groups</code> <p>Returns general information about the consumer groups of the stream.</p> <code>axinfo_stream</code> <p>Returns general information about the stream.</p> <code>axlen</code> <p>Returns the number of elements in a given stream.</p> <code>axpending</code> <p>Returns information about pending messages of a group.</p> <code>axpending_range</code> <p>Returns information about pending messages, in a range.</p> <code>axrange</code> <p>Read stream values within an interval.</p> <code>axread</code> <p>Block and monitor multiple streams for new data.</p> <code>axreadgroup</code> <p>Read from a stream via a consumer group.</p> <code>axrevrange</code> <p>Read stream values within an interval, in reverse order.</p> <code>axtrim</code> <p>Trims old messages from a stream.</p> <code>azadd</code> <p>Set any number of element-name, score pairs to the key <code>name</code>. Pairs</p> <code>azcard</code> <p>Return the number of elements in the sorted set <code>name</code></p> <code>azcount</code> <p>Returns the number of elements in the sorted set at key <code>name</code> with</p> <code>azdiff</code> <p>Returns the difference between the first and all successive input</p> <code>azdiffstore</code> <p>Computes the difference between the first and all successive input</p> <code>azincrby</code> <p>Increment the score of <code>value</code> in sorted set <code>name</code> by <code>amount</code></p> <code>azinter</code> <p>Return the intersect of multiple sorted sets specified by <code>keys</code>.</p> <code>azintercard</code> <p>Return the cardinality of the intersect of multiple sorted sets</p> <code>azinterstore</code> <p>Intersect multiple sorted sets specified by <code>keys</code> into a new</p> <code>azlexcount</code> <p>Return the number of items in the sorted set <code>name</code> between the</p> <code>azmpop</code> <p>Pop <code>count</code> values (default 1) off of the first non-empty sorted set</p> <code>azmscore</code> <p>Returns the scores associated with the specified members</p> <code>azpopmax</code> <p>Remove and return up to <code>count</code> members with the highest scores</p> <code>azpopmin</code> <p>Remove and return up to <code>count</code> members with the lowest scores</p> <code>azrandmember</code> <p>Return a random element from the sorted set value stored at key.</p> <code>azrange</code> <p>Return a range of values from sorted set <code>name</code> between</p> <code>azrangebylex</code> <p>Return the lexicographical range of values from sorted set <code>name</code></p> <code>azrangebyscore</code> <p>Return a range of values from the sorted set <code>name</code> with scores</p> <code>azrangestore</code> <p>Stores in <code>dest</code> the result of a range of values from sorted set</p> <code>azrank</code> <p>Returns a 0-based value indicating the rank of <code>value</code> in sorted set</p> <code>azrem</code> <p>Remove member <code>values</code> from sorted set <code>name</code></p> <code>azremrangebylex</code> <p>Remove all elements in the sorted set <code>name</code> between the</p> <code>azremrangebyrank</code> <p>Remove all elements in the sorted set <code>name</code> with ranks between</p> <code>azremrangebyscore</code> <p>Remove all elements in the sorted set <code>name</code> with scores</p> <code>azrevrange</code> <p>Return a range of values from sorted set <code>name</code> between</p> <code>azrevrangebylex</code> <p>Return the reversed lexicographical range of values from sorted set</p> <code>azrevrangebyscore</code> <p>Return a range of values from the sorted set <code>name</code> with scores</p> <code>azrevrank</code> <p>Returns a 0-based value indicating the descending rank of</p> <code>azscan</code> <p>Incrementally return lists of elements in a sorted set. Also return a</p> <code>azscan_iter</code> <p>Make an iterator using the ZSCAN command so that the client doesn't</p> <code>azscore</code> <p>Return the score of element <code>value</code> in sorted set <code>name</code></p> <code>azunion</code> <p>Return the union of multiple sorted sets specified by <code>keys</code>.</p> <code>azunionstore</code> <p>Union multiple sorted sets specified by <code>keys</code> into</p> <code>bgrewriteaof</code> <p>Tell the Redis server to rewrite the AOF file from data in memory.</p> <code>bgsave</code> <p>Tell the Redis server to save its data to disk.  Unlike save(),</p> <code>bitcount</code> <p>Returns the count of set bits in the value of <code>key</code>.  Optional</p> <code>bitfield</code> <p>Return a BitFieldOperation instance to conveniently construct one or</p> <code>bitfield_ro</code> <p>Return an array of the specified bitfield values</p> <code>bitop</code> <p>Perform a bitwise operation using <code>operation</code> between <code>keys</code> and</p> <code>bitpos</code> <p>Return the position of the first bit set to 1 or 0 in a string.</p> <code>blmove</code> <p>Blocking version of lmove.</p> <code>blmpop</code> <p>Pop <code>count</code> values (default 1) from first non-empty in the list</p> <code>blpop</code> <p>LPOP a value off of the first non-empty list</p> <code>brpop</code> <p>RPOP a value off of the first non-empty list</p> <code>brpoplpush</code> <p>Pop a value off the tail of <code>src</code>, push it on the head of <code>dst</code></p> <code>bzmpop</code> <p>Pop <code>count</code> values (default 1) off of the first non-empty sorted set</p> <code>bzpopmax</code> <p>ZPOPMAX a value off of the first non-empty sorted set</p> <code>bzpopmin</code> <p>ZPOPMIN a value off of the first non-empty sorted set</p> <code>clear</code> <p>Clears the current database</p> <code>client_getname</code> <p>Returns the current connection name</p> <code>client_getredir</code> <p>Returns the ID (an integer) of the client to whom we are</p> <code>client_id</code> <p>Returns the current connection id</p> <code>client_info</code> <p>Returns information and statistics about the current</p> <code>client_kill</code> <p>Disconnects the client at <code>address</code> (ip:port)</p> <code>client_kill_filter</code> <p>Disconnects client(s) using a variety of filter options</p> <code>client_list</code> <p>Returns a list of currently connected clients.</p> <code>client_no_evict</code> <p>Sets the client eviction mode for the current connection.</p> <code>client_no_touch</code> <code>client_pause</code> <p>Suspend all the Redis clients for the specified amount of time.</p> <code>client_reply</code> <p>Enable and disable redis server replies.</p> <code>client_setinfo</code> <p>Sets the current connection library name or version</p> <code>client_setname</code> <p>Sets the current connection name</p> <code>client_tracking</code> <p>Enables the tracking feature of the Redis server, that is used</p> <code>client_tracking_off</code> <p>Turn off the tracking mode.</p> <code>client_tracking_on</code> <p>Turn on the tracking mode.</p> <code>client_trackinginfo</code> <p>Returns the information about the current client connection's</p> <code>client_unblock</code> <p>Unblocks a connection by its client id.</p> <code>client_unpause</code> <p>Unpause all redis clients</p> <code>close</code> <p>Close the session</p> <code>close_locks</code> <p>Closes the locks that are currently managed by the session</p> <code>command_docs</code> <p>This function throws a NotImplementedError since it is intentionally</p> <code>command_getkeysandflags</code> <p>Returns array of keys from a full Redis command and their usage flags.</p> <code>command_list</code> <p>Return an array of the server's command names.</p> <code>config_get</code> <p>Return a dictionary of configuration based on the <code>pattern</code></p> <code>config_resetstat</code> <p>Reset runtime statistics</p> <code>config_rewrite</code> <p>Rewrite config file with the minimal change to reflect running config.</p> <code>config_set</code> <p>Set config item <code>name</code> with <code>value</code></p> <code>copy</code> <p>Copy the value stored in the <code>source</code> key to the <code>destination</code> key.</p> <code>create_persistence</code> <p>Create a new persistence instance</p> <code>dbsize</code> <p>Returns the number of keys in the current database</p> <code>debug_object</code> <p>Returns version specific meta information about a given key</p> <code>decrby</code> <p>Decrements the value of <code>key</code> by <code>amount</code>.  If no key exists,</p> <code>delete</code> <p>Delete one or more keys specified by <code>names</code></p> <code>delitem</code> <p>[Dict] Deletes the key</p> <code>disable_serialization</code> <p>Disable Serialization in the Encoder</p> <code>dump</code> <p>Return a serialized version of the value stored at the specified key.</p> <code>echo</code> <p>Echo the string back from the server</p> <code>enable_serialization</code> <p>Enable Serialization in the Encoder</p> <code>eval</code> <p>Execute the Lua <code>script</code>, specifying the <code>numkeys</code> the script</p> <code>eval_ro</code> <p>The read-only variant of the EVAL command</p> <code>evalsha</code> <p>Use the <code>sha</code> to execute a Lua script already registered via EVAL</p> <code>evalsha_ro</code> <p>The read-only variant of the EVALSHA command</p> <code>execute_command</code> <p>Execute a command and return a parsed response</p> <code>exists</code> <p>Returns the number of <code>names</code> that exist</p> <code>expire</code> <p>Set an expire flag on key <code>name</code> for <code>time</code> seconds with given</p> <code>expireat</code> <p>Set an expire flag on key <code>name</code> with given <code>option</code>. <code>when</code></p> <code>expiretime</code> <p>Returns the absolute Unix timestamp (since January 1, 1970) in seconds</p> <code>failover</code> <p>This function throws a NotImplementedError since it is intentionally</p> <code>fcall</code> <p>Invoke a function.</p> <code>fcall_ro</code> <p>This is a read-only variant of the FCALL command that cannot</p> <code>flushall</code> <p>Delete all keys in all databases on the current host.</p> <code>flushdb</code> <p>Delete all keys in the current database.</p> <code>function_delete</code> <p>Delete the library called <code>library</code> and all its functions.</p> <code>function_dump</code> <p>Return the serialized payload of loaded libraries.</p> <code>function_flush</code> <p>Deletes all the libraries.</p> <code>function_kill</code> <p>Kill a function that is currently executing.</p> <code>function_list</code> <p>Return information about the functions and libraries.</p> <code>function_load</code> <p>Load a library to Redis.</p> <code>function_restore</code> <p>Restore libraries from the serialized <code>payload</code>.</p> <code>function_stats</code> <p>Return information about the function that's currently running</p> <code>geoadd</code> <p>Add the specified geospatial items to the specified key identified</p> <code>geodist</code> <p>Return the distance between <code>place1</code> and <code>place2</code> members of the</p> <code>geohash</code> <p>Return the geo hash string for each item of <code>values</code> members of</p> <code>geopos</code> <p>Return the positions of each item of <code>values</code> as members of</p> <code>georadius</code> <p>Return the members of the specified key identified by the</p> <code>georadiusbymember</code> <p>This command is exactly like <code>georadius</code> with the sole difference</p> <code>geosearch</code> <p>Return the members of specified key identified by the</p> <code>geosearchstore</code> <p>This command is like GEOSEARCH, but stores the result in</p> <code>get</code> <p>Return the value at key <code>name</code>, or None if the key doesn't exist</p> <code>get_dictkey</code> <p>Returns the dict key</p> <code>getbit</code> <p>Returns an integer indicating the value of <code>offset</code> in <code>name</code></p> <code>getdel</code> <p>Get the value at key <code>name</code> and delete the key. This command</p> <code>getex</code> <p>Get the value of key and optionally set its expiration.</p> <code>getitem</code> <p>[Dict] Returns the value for the given key</p> <code>getrange</code> <p>Returns the substring of the string value stored at <code>key</code>,</p> <code>getset</code> <p>Sets the value at key <code>name</code> to <code>value</code></p> <code>hdel</code> <p>Delete <code>keys</code> from hash <code>name</code></p> <code>hello</code> <p>This function throws a NotImplementedError since it is intentionally</p> <code>hexists</code> <p>Returns a boolean indicating if <code>key</code> exists within hash <code>name</code></p> <code>hget</code> <p>Return the value of <code>key</code> within the hash <code>name</code></p> <code>hgetall</code> <p>Return a Python dict of the hash's name/value pairs</p> <code>hincrby</code> <p>Increment the value of <code>key</code> in hash <code>name</code> by <code>amount</code></p> <code>hincrbyfloat</code> <p>Increment the value of <code>key</code> in hash <code>name</code> by floating <code>amount</code></p> <code>hkeys</code> <p>Return the list of keys within hash <code>name</code></p> <code>hlen</code> <p>Return the number of elements in hash <code>name</code></p> <code>hmget</code> <p>Returns a list of values ordered identically to <code>keys</code></p> <code>hmset</code> <p>Set key to value within hash <code>name</code> for each corresponding</p> <code>hrandfield</code> <p>Return a random field from the hash value stored at key.</p> <code>hscan</code> <p>Incrementally return key/value slices in a hash. Also return a cursor</p> <code>hscan_iter</code> <p>Make an iterator using the HSCAN command so that the client doesn't</p> <code>hset</code> <p>Set <code>key</code> to <code>value</code> within hash <code>name</code>,</p> <code>hsetnx</code> <p>Set <code>key</code> to <code>value</code> within hash <code>name</code> if <code>key</code> does not</p> <code>hstrlen</code> <p>Return the number of bytes stored in the value of <code>key</code></p> <code>hvals</code> <p>Return the list of values within hash <code>name</code></p> <code>incrby</code> <p>Increments the value of <code>key</code> by <code>amount</code>.  If no key exists,</p> <code>incrbyfloat</code> <p>Increments the value at key <code>name</code> by floating <code>amount</code>.</p> <code>info</code> <p>Returns a dictionary containing information about the Redis server</p> <code>init_cache_config</code> <p>Initializes the cache config</p> <code>init_encoder</code> <p>Initializes the encoder</p> <code>init_serializer</code> <p>Initializes the serializer</p> <code>init_state</code> <p>Initializes the session state</p> <code>initialize_class_functions</code> <p>Initializes the class methods</p> <code>keys</code> <p>Returns a list of keys matching <code>pattern</code></p> <code>lastsave</code> <p>Return a Python datetime object representing the last time the</p> <code>latency_doctor</code> <p>Raise a NotImplementedError, as the client will not support LATENCY DOCTOR.</p> <code>latency_graph</code> <p>Raise a NotImplementedError, as the client will not support LATENCY GRAPH.</p> <code>latency_histogram</code> <p>This function throws a NotImplementedError since it is intentionally</p> <code>latency_history</code> <p>Returns the raw data of the <code>event</code>'s latency spikes time series.</p> <code>latency_latest</code> <p>Reports the latest latency events logged.</p> <code>latency_reset</code> <p>Resets the latency spikes time series of all, or only some, events.</p> <code>lcs</code> <p>Find the longest common subsequence between <code>key1</code> and <code>key2</code>.</p> <code>lindex</code> <p>Return the item from list <code>name</code> at position <code>index</code></p> <code>linsert</code> <p>Insert <code>value</code> in list <code>name</code> either immediately before or after</p> <code>llen</code> <p>Return the length of the list <code>name</code></p> <code>lmove</code> <p>Atomically returns and removes the first/last element of a list,</p> <code>lmpop</code> <p>Pop <code>count</code> values (default 1) first non-empty list key from the list</p> <code>lock</code> <p>Create a new Lock instance named <code>name</code> using the Redis client</p> <code>lolwut</code> <p>Get the Redis version and a piece of generative computer art</p> <code>lpop</code> <p>Removes and returns the first elements of the list <code>name</code>.</p> <code>lpos</code> <p>Get position of <code>value</code> within the list <code>name</code></p> <code>lpush</code> <p>Push <code>values</code> onto the head of the list <code>name</code></p> <code>lpushx</code> <p>Push <code>value</code> onto the head of the list <code>name</code> if <code>name</code> exists</p> <code>lrange</code> <p>Return a slice of the list <code>name</code> between</p> <code>lrem</code> <p>Remove the first <code>count</code> occurrences of elements equal to <code>value</code></p> <code>lset</code> <p>Set element at <code>index</code> of list <code>name</code> to <code>value</code></p> <code>ltrim</code> <p>Trim the list <code>name</code>, removing all values not within the slice</p> <code>memory_malloc_stats</code> <p>Return an internal statistics report from the memory allocator.</p> <code>memory_purge</code> <p>Attempts to purge dirty pages for reclamation by allocator</p> <code>memory_stats</code> <p>Return a dictionary of memory stats</p> <code>memory_usage</code> <p>Return the total memory usage for key, its value and associated</p> <code>mget</code> <p>Returns a list of values ordered identically to <code>keys</code></p> <code>migrate</code> <p>Migrate 1 or more keys from the current Redis server to a different</p> <code>module_list</code> <p>Returns a list of dictionaries containing the name and version of</p> <code>module_load</code> <p>Loads the module from <code>path</code>.</p> <code>module_loadex</code> <p>Loads a module from a dynamic library at runtime with configuration directives.</p> <code>module_unload</code> <p>Unloads the module <code>name</code>.</p> <code>move</code> <p>Moves the key <code>name</code> to a different Redis database <code>db</code></p> <code>mset</code> <p>Sets key/values based on a mapping. Mapping is a dictionary of</p> <code>msetnx</code> <p>Sets key/values based on a mapping if none of the keys are already set.</p> <code>object</code> <p>Return the encoding, idletime, or refcount about the key</p> <code>overflow</code> <p>Update the overflow algorithm of successive INCRBY operations</p> <code>persist</code> <p>Removes an expiration on <code>name</code></p> <code>pexpire</code> <p>Set an expire flag on key <code>name</code> for <code>time</code> milliseconds</p> <code>pexpireat</code> <p>Set an expire flag on key <code>name</code> with given <code>option</code>. <code>when</code></p> <code>pexpiretime</code> <p>Returns the absolute Unix timestamp (since January 1, 1970) in milliseconds</p> <code>pfadd</code> <p>Adds the specified elements to the specified HyperLogLog.</p> <code>pfcount</code> <p>Return the approximated cardinality of</p> <code>pfmerge</code> <p>Merge N different HyperLogLogs into a single one.</p> <code>ping</code> <p>Ping the Redis server</p> <code>pipeline</code> <p>Return a new pipeline object that can queue multiple commands for</p> <code>psetex</code> <p>Set the value of key <code>name</code> to <code>value</code> that expires in <code>time_ms</code></p> <code>psync</code> <p>Initiates a replication stream from the master.</p> <code>pttl</code> <p>Returns the number of milliseconds until the key <code>name</code> will expire</p> <code>publish</code> <p>Publish <code>message</code> on <code>channel</code>.</p> <code>pubsub</code> <p>Return a Publish/Subscribe object. With this object, you can</p> <code>pubsub_channels</code> <p>Return a list of channels that have at least one subscriber</p> <code>pubsub_numpat</code> <p>Returns the number of subscriptions to patterns</p> <code>pubsub_numsub</code> <p>Return a list of (channel, number of subscribers) tuples</p> <code>pubsub_shardchannels</code> <p>Return a list of shard_channels that have at least one subscriber</p> <code>pubsub_shardnumsub</code> <p>Return a list of (shard_channel, number of subscribers) tuples</p> <code>quit</code> <p>Ask the server to close the connection.</p> <code>randomkey</code> <p>Returns the name of a random key</p> <code>readonly</code> <p>Enables read queries for a connection to a Redis Cluster replica node.</p> <code>readwrite</code> <p>Disables read queries for a connection to a Redis Cluster slave node.</p> <code>register_script</code> <p>Register a Lua <code>script</code> specifying the <code>keys</code> it will touch.</p> <code>rename</code> <p>Rename key <code>src</code> to <code>dst</code></p> <code>renamenx</code> <p>Rename key <code>src</code> to <code>dst</code> if <code>dst</code> doesn't already exist</p> <code>replicaof</code> <p>Update the replication settings of a redis replica, on the fly.</p> <code>reset</code> <p>Reset the state of the instance to when it was constructed</p> <code>restore</code> <p>Create a key using the provided serialized value, previously obtained</p> <code>role</code> <p>Provide information on the role of a Redis instance in</p> <code>rpop</code> <p>Removes and returns the last elements of the list <code>name</code>.</p> <code>rpoplpush</code> <p>RPOP a value off of the <code>src</code> list and atomically LPUSH it</p> <code>rpush</code> <p>Push <code>values</code> onto the tail of the list <code>name</code></p> <code>rpushx</code> <p>Push <code>value</code> onto the tail of the list <code>name</code> if <code>name</code> exists</p> <code>sadd</code> <p>Add <code>value(s)</code> to set <code>name</code></p> <code>save</code> <p>Tell the Redis server to save its data to disk,</p> <code>scan</code> <p>Incrementally return lists of key names. Also return a cursor</p> <code>scan_iter</code> <p>Make an iterator using the SCAN command so that the client doesn't</p> <code>scard</code> <p>Return the number of elements in set <code>name</code></p> <code>script_exists</code> <p>Check if a script exists in the script cache by specifying the SHAs of</p> <code>script_flush</code> <p>Flush all scripts from the script cache.</p> <code>script_kill</code> <p>Kill the currently executing Lua script</p> <code>script_load</code> <p>Load a Lua <code>script</code> into the script cache. Returns the SHA.</p> <code>sdiff</code> <p>Return the difference of sets specified by <code>keys</code></p> <code>sdiffstore</code> <p>Store the difference of sets specified by <code>keys</code> into a new</p> <code>select</code> <p>Select the Redis logical database at index.</p> <code>set</code> <p>Set the value at key <code>name</code> to <code>value</code></p> <code>setbit</code> <p>Flag the <code>offset</code> in <code>name</code> as <code>value</code>. Returns an integer</p> <code>setex</code> <p>Set the value of key <code>name</code> to <code>value</code> that expires in <code>time</code></p> <code>setitem</code> <p>[Dict] Sets the value for the given key</p> <code>setnx</code> <p>Set the value of key <code>name</code> to <code>value</code> if key doesn't exist</p> <code>setrange</code> <p>Overwrite bytes in the value of <code>name</code> starting at <code>offset</code> with</p> <code>shutdown</code> <p>Shutdown the Redis server.  If Redis has persistence configured,</p> <code>sinter</code> <p>Return the intersection of sets specified by <code>keys</code></p> <code>sintercard</code> <p>Return the cardinality of the intersect of multiple sets specified by <code>`keys</code>.</p> <code>sinterstore</code> <p>Store the intersection of sets specified by <code>keys</code> into a new</p> <code>sismember</code> <p>Return whether <code>value</code> is a member of set <code>name</code>:</p> <code>slaveof</code> <p>Set the server to be a replicated slave of the instance identified</p> <code>slowlog_get</code> <p>Get the entries from the slowlog. If <code>num</code> is specified, get the</p> <code>slowlog_len</code> <p>Get the number of items in the slowlog</p> <code>slowlog_reset</code> <p>Remove all items in the slowlog</p> <code>smembers</code> <p>Return all members of the set <code>name</code></p> <code>smismember</code> <p>Return whether each value in <code>values</code> is a member of the set <code>name</code></p> <code>smove</code> <p>Move <code>value</code> from set <code>src</code> to set <code>dst</code> atomically</p> <code>sort</code> <p>Sort and return the list, set or sorted set at <code>name</code>.</p> <code>sort_ro</code> <p>Returns the elements contained in the list, set or sorted set at key.</p> <code>spop</code> <p>Remove and return a random member of set <code>name</code></p> <code>spublish</code> <p>Posts a message to the given shard channel.</p> <code>srandmember</code> <p>If <code>number</code> is None, returns a random member of set <code>name</code>.</p> <code>srem</code> <p>Remove <code>values</code> from set <code>name</code></p> <code>sscan</code> <p>Incrementally return lists of elements in a set. Also return a cursor</p> <code>sscan_iter</code> <p>Make an iterator using the SSCAN command so that the client doesn't</p> <code>stralgo</code> <p>Implements complex algorithms that operate on strings.</p> <code>strlen</code> <p>Return the number of bytes stored in the value of <code>name</code></p> <code>substr</code> <p>Return a substring of the string at key <code>name</code>. <code>start</code> and <code>end</code></p> <code>sunion</code> <p>Return the union of sets specified by <code>keys</code></p> <code>sunionstore</code> <p>Store the union of sets specified by <code>keys</code> into a new</p> <code>swapdb</code> <p>Swap two databases</p> <code>sync</code> <p>Initiates a replication stream from the master.</p> <code>tfcall</code> <p>Invoke a function.</p> <code>tfcall_async</code> <p>Invoke an async function (coroutine).</p> <code>tfunction_delete</code> <p>Delete a library from RedisGears.</p> <code>tfunction_list</code> <p>List the functions with additional information about each function.</p> <code>tfunction_load</code> <p>Load a new library to RedisGears.</p> <code>time</code> <p>Returns the server time as a 2-item tuple of ints:</p> <code>touch</code> <p>Alters the last access time of a key(s) <code>*args</code>. A key is ignored</p> <code>ttl</code> <p>Returns the number of seconds until the key <code>name</code> will expire</p> <code>type</code> <p>Returns the type of key <code>name</code></p> <code>unlink</code> <p>Unlink one or more keys specified by <code>names</code></p> <code>unwatch</code> <p>Unwatches the value at key <code>name</code>, or None of the key doesn't exist</p> <code>wait</code> <p>Redis synchronous replication</p> <code>waitaof</code> <p>This command blocks the current client until all previous write</p> <code>watch</code> <p>Watches the values at keys <code>names</code>, or None if the key doesn't exist</p> <code>xack</code> <p>Acknowledges the successful processing of one or more messages.</p> <code>xadd</code> <p>Add to a stream.</p> <code>xautoclaim</code> <p>Transfers ownership of pending stream entries that match the specified</p> <code>xclaim</code> <p>Changes the ownership of a pending message.</p> <code>xdel</code> <p>Deletes one or more messages from a stream.</p> <code>xgroup_create</code> <p>Create a new consumer group associated with a stream.</p> <code>xgroup_createconsumer</code> <p>Consumers in a consumer group are auto-created every time a new</p> <code>xgroup_delconsumer</code> <p>Remove a specific consumer from a consumer group.</p> <code>xgroup_destroy</code> <p>Destroy a consumer group.</p> <code>xgroup_setid</code> <p>Set the consumer group last delivered ID to something else.</p> <code>xinfo_consumers</code> <p>Returns general information about the consumers in the group.</p> <code>xinfo_groups</code> <p>Returns general information about the consumer groups of the stream.</p> <code>xinfo_stream</code> <p>Returns general information about the stream.</p> <code>xlen</code> <p>Returns the number of elements in a given stream.</p> <code>xpending</code> <p>Returns information about pending messages of a group.</p> <code>xpending_range</code> <p>Returns information about pending messages, in a range.</p> <code>xrange</code> <p>Read stream values within an interval.</p> <code>xread</code> <p>Block and monitor multiple streams for new data.</p> <code>xreadgroup</code> <p>Read from a stream via a consumer group.</p> <code>xrevrange</code> <p>Read stream values within an interval, in reverse order.</p> <code>xtrim</code> <p>Trims old messages from a stream.</p> <code>zadd</code> <p>Set any number of element-name, score pairs to the key <code>name</code>. Pairs</p> <code>zcard</code> <p>Return the number of elements in the sorted set <code>name</code></p> <code>zcount</code> <p>Returns the number of elements in the sorted set at key <code>name</code> with</p> <code>zdiff</code> <p>Returns the difference between the first and all successive input</p> <code>zdiffstore</code> <p>Computes the difference between the first and all successive input</p> <code>zincrby</code> <p>Increment the score of <code>value</code> in sorted set <code>name</code> by <code>amount</code></p> <code>zinter</code> <p>Return the intersect of multiple sorted sets specified by <code>keys</code>.</p> <code>zintercard</code> <p>Return the cardinality of the intersect of multiple sorted sets</p> <code>zinterstore</code> <p>Intersect multiple sorted sets specified by <code>keys</code> into a new</p> <code>zlexcount</code> <p>Return the number of items in the sorted set <code>name</code> between the</p> <code>zmpop</code> <p>Pop <code>count</code> values (default 1) off of the first non-empty sorted set</p> <code>zmscore</code> <p>Returns the scores associated with the specified members</p> <code>zpopmax</code> <p>Remove and return up to <code>count</code> members with the highest scores</p> <code>zpopmin</code> <p>Remove and return up to <code>count</code> members with the lowest scores</p> <code>zrandmember</code> <p>Return a random element from the sorted set value stored at key.</p> <code>zrange</code> <p>Return a range of values from sorted set <code>name</code> between</p> <code>zrangebylex</code> <p>Return the lexicographical range of values from sorted set <code>name</code></p> <code>zrangebyscore</code> <p>Return a range of values from the sorted set <code>name</code> with scores</p> <code>zrangestore</code> <p>Stores in <code>dest</code> the result of a range of values from sorted set</p> <code>zrank</code> <p>Returns a 0-based value indicating the rank of <code>value</code> in sorted set</p> <code>zrem</code> <p>Remove member <code>values</code> from sorted set <code>name</code></p> <code>zremrangebylex</code> <p>Remove all elements in the sorted set <code>name</code> between the</p> <code>zremrangebyrank</code> <p>Remove all elements in the sorted set <code>name</code> with ranks between</p> <code>zremrangebyscore</code> <p>Remove all elements in the sorted set <code>name</code> with scores</p> <code>zrevrange</code> <p>Return a range of values from sorted set <code>name</code> between</p> <code>zrevrangebylex</code> <p>Return the reversed lexicographical range of values from sorted set</p> <code>zrevrangebyscore</code> <p>Return a range of values from the sorted set <code>name</code> with scores</p> <code>zrevrank</code> <p>Returns a 0-based value indicating the descending rank of</p> <code>zscan</code> <p>Incrementally return lists of elements in a sorted set. Also return a</p> <code>zscan_iter</code> <p>Make an iterator using the ZSCAN command so that the client doesn't</p> <code>zscore</code> <p>Return the score of element <code>value</code> in sorted set <code>name</code></p> <code>zunion</code> <p>Return the union of multiple sorted sets specified by <code>keys</code>.</p> <code>zunionstore</code> <p>Union multiple sorted sets specified by <code>keys</code> into</p> ATTRIBUTE DESCRIPTION <code>aclient</code> <p>[Async] The KVDB client</p> <p> TYPE: <code>kvdb.components.client.AsyncKVDB</code> </p> <code>client</code> <p>[Sync] The KVDB client</p> <p> TYPE: <code>kvdb.components.client.KVDB</code> </p> <code>db_id</code> <p>Returns the database ID</p> <p> TYPE: <code>typing.Optional[int]</code> </p> <code>persistence</code> <p>Returns the <code>PersistentDict</code> instance</p> <p> TYPE: <code>lzl.io.persistence.PersistentDict</code> </p> <code>session_serialization_enabled</code> <p>Returns whether session serialization is enabled</p> <p> TYPE: <code>bool</code> </p> <code>version</code> <p>Returns the version</p> <p> TYPE: <code>str</code> </p> Source code in <code>kvdb/components/session.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    url: Union[str, KVDBUrl],\n    *,\n    pool: SessionPools,\n    db_id: Optional[int] = None,\n    serializer: Optional[Union['SerializerT', str]] = None,\n    encoder: Optional['Encoder'] = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Initializes the KVDB Session\n    \"\"\"\n    if isinstance(url, str): url = KVDBUrl(url)\n    self.name = name\n    self.url = url\n    self.pool = pool\n    if db_id is not None and db_id != self.url.db_id:\n        self.url = self.url.with_db_id(db_id)\n    self.settings = settings\n    self.logger = settings.logger\n    self.autologger = settings.autologger\n    self.init_serializer(serializer, **kwargs)\n    self.init_encoder(encoder, **kwargs)\n    self.init_cache_config(**kwargs)\n    self.init_state(**kwargs)\n    self._version: Optional[str] = None\n    self._persistence: Optional['PersistentDict'] = None\n    self._persistence_ctx: Dict[str, 'PersistentDict'] = {}\n    self._kwargs = kwargs\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession--the-command-controls-whether-commands-sent-by-the-client-will-alter","title":"The command controls whether commands sent by the client will alter","text":""},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession--the-command-controls-whether-commands-sent-by-the-client-will-alter","title":"The command controls whether commands sent by the client will alter","text":""},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient","title":"aclient  <code>property</code>","text":"<pre><code>aclient: kvdb.components.client.AsyncKVDB\n</code></pre> <p>[Async] The KVDB client</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client","title":"client  <code>property</code>","text":"<pre><code>client: kvdb.components.client.KVDB\n</code></pre> <p>[Sync] The KVDB client</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.db_id","title":"db_id  <code>property</code>","text":"<pre><code>db_id: typing.Optional[int]\n</code></pre> <p>Returns the database ID</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.persistence","title":"persistence  <code>property</code>","text":"<pre><code>persistence: lzl.io.persistence.PersistentDict\n</code></pre> <p>Returns the <code>PersistentDict</code> instance that utilizes the session's client</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.session_serialization_enabled","title":"session_serialization_enabled  <code>property</code>","text":"<pre><code>session_serialization_enabled: bool\n</code></pre> <p>Returns whether session serialization is enabled which is determined by the pool's encoder serialization to be enabled</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.version","title":"version  <code>property</code>","text":"<pre><code>version: str\n</code></pre> <p>Returns the version</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Enter the runtime context related to this object.</p> Source code in <code>kvdb/components/session.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"\n    Enter the runtime context related to this object.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Close the session</p> Source code in <code>kvdb/components/session.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"\n    Close the session\n    \"\"\"\n    await self.aclose()\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.__contains__","title":"__contains__","text":"<pre><code>__contains__(key: kvdb.types.generic.KeyT) -&gt; bool\n</code></pre> <p>[Dict] Returns whether the key exists</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def __contains__(self, key: KeyT) -&gt; bool:\n    \"\"\"\n    [Dict] Returns whether the key exists\n    \"\"\"\n    return self.persistence.contains(key)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: kvdb.types.generic.KeyT) -&gt; None\n</code></pre> <p>[Dict] Deletes the key</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def __delitem__(self, key: KeyT) -&gt; None:\n    \"\"\"\n    [Dict] Deletes the key\n    \"\"\"\n    if settings.is_in_async_loop():\n        return ThreadPooler.create_background_task(self.adelitem, key)\n    return self.delitem(key)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Enter the runtime context related to this object.</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def __enter__(self):\n    \"\"\"\n    Enter the runtime context related to this object.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.__exit__","title":"__exit__","text":"<pre><code>__exit__(\n    exc_type: (\n        kvdb.components.session.KVDBSession.type[\n            BaseException\n        ]\n        | None\n    ),\n    exc_val: BaseException | None,\n    exc_tb: types.TracebackType | None,\n)\n</code></pre> <p>On exit, close the session</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"\n    On exit, close the session\n    \"\"\"\n    self.close()\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(\n    key: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ReturnT\n</code></pre> <p>[Dict] Returns the value for the given key</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def __getitem__(self, key: KeyT) -&gt; ResponseT:\n    \"\"\"\n    [Dict] Returns the value for the given key\n    \"\"\"\n    return self.getitem(key)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    key: kvdb.types.generic.KeyT, value: typing.Any\n) -&gt; None\n</code></pre> <p>[Dict] Sets the value for the given key</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def __setitem__(self, key: KeyT, value: Any) -&gt; None:\n    \"\"\"\n    [Dict] Sets the value for the given key\n    \"\"\"\n    if settings.is_in_async_loop():\n        return ThreadPooler.create_background_task(\n            self.asetitem, key, value,\n        )\n    return self.setitem(key, value)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aacl_cat","title":"aacl_cat  <code>async</code>","text":"<pre><code>aacl_cat(\n    category: typing.Union[str, None] = None, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a list of categories or commands within a category.</p> <p>If <code>category</code> is not supplied, returns a list of all categories. If <code>category</code> is supplied, returns a list of all commands within that category.</p> <p>For more information see https://redis.io/commands/acl-cat</p> Source code in <code>kvdb/components/session.py</code> <pre><code>Returns the `PersistentDict` instance\nthat utilizes the session's client\n\"\"\"\nif self._persistence is None:\n    from .persistence import KVDBStatefulBackend\n    persistence_config = self.settings.persistence.model_dump(exclude_none = True)\n    persistence_kwargs = self.settings.persistence.extract_kwargs(_prefix = 'persistence_', _exclude_none = True, **self._kwargs)\n    if persistence_kwargs: persistence_config.update(persistence_kwargs)\n    if 'name' not in persistence_config: persistence_config['name'] = self.name\n    self._persistence = KVDBStatefulBackend.as_persistent_dict(\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aacl_deluser","title":"aacl_deluser  <code>async</code>","text":"<pre><code>aacl_deluser(\n    *username: str, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Delete the ACL for the specified <code>username</code>s</p> <p>For more information see https://redis.io/commands/acl-deluser</p> Source code in <code>kvdb/components/session.py</code> <pre><code>    \"\"\"\n    Execute a command and return a parsed response\n    \"\"\"\n    return self.client.execute_command(*args, **options)\n\nasync def aexecute_command(self, *args: Any, **options: Any) -&gt; Any:\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aacl_dryrun","title":"aacl_dryrun  <code>async</code>","text":"<pre><code>aacl_dryrun(username, *args, **kwargs)\n</code></pre> <p>Simulate the execution of a given command by a given <code>username</code>.</p> <p>For more information see https://redis.io/commands/acl-dryrun</p> Source code in <code>kvdb/components/session.py</code> <pre><code>            session = self,\n            **persistence_config,\n        )\n    return self._persistence\n\ndef execute_command(self, *args: Any, **options: Any) -&gt; Any:\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aacl_genpass","title":"aacl_genpass  <code>async</code>","text":"<pre><code>aacl_genpass(\n    bits: typing.Union[int, None] = None, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Generate a random password value. If <code>bits</code> is supplied then use this number of bits, rounded to the next multiple of 4. See: https://redis.io/commands/acl-genpass</p> Source code in <code>kvdb/components/session.py</code> <pre><code>    \"\"\"\n    Execute a command and return a parsed response\n    \"\"\"\n    return await self.aclient.execute_command(*args, **options)\n\n\"\"\"\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aacl_getuser","title":"aacl_getuser  <code>async</code>","text":"<pre><code>aacl_getuser(\n    username: str, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Get the ACL details for the specified <code>username</code>.</p> <p>If <code>username</code> does not exist, return None</p> <p>For more information see https://redis.io/commands/acl-getuser</p> Source code in <code>kvdb/components/session.py</code> <pre><code>Component Methods\n\"\"\"\n\ndef create_persistence(\n    self,\n    name: Optional[str] = None,\n    base_key: Optional[str] = None,\n    **kwargs,\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aacl_help","title":"aacl_help  <code>async</code>","text":"<pre><code>aacl_help(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>The ACL HELP command returns helpful text describing the different subcommands.</p> <p>For more information see https://redis.io/commands/acl-help</p> Source code in <code>kvdb/components/session.py</code> <pre><code>) -&gt; 'PersistentDict':\n    \"\"\"\n    Create a new persistence instance\n    \"\"\"\n    # name = name or self.name\n    # if name in self._persistence_ctx:\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aacl_list","title":"aacl_list  <code>async</code>","text":"<pre><code>aacl_list(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a list of all ACLs on the server</p> <p>For more information see https://redis.io/commands/acl-list</p> Source code in <code>kvdb/components/session.py</code> <pre><code>#     return self._persistence_ctx[name]\n\nfrom .persistence import KVDBStatefulBackend\npersistence_config = self.settings.persistence.model_dump(exclude_none = True)\npersistence_kwargs = self.settings.persistence.extract_kwargs(_prefix = 'persistence_', _exclude_none = True, **self._kwargs)\nif persistence_kwargs: persistence_config.update(persistence_kwargs)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aacl_load","title":"aacl_load  <code>async</code>","text":"<pre><code>aacl_load(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Load ACL rules from the configured <code>aclfile</code>.</p> <p>Note that the server must be configured with the <code>aclfile</code> directive to be able to load ACL rules from an aclfile.</p> <p>For more information see https://redis.io/commands/acl-load</p> Source code in <code>kvdb/components/session.py</code> <pre><code>    retryable: Optional[bool] = None,\n    **kwargs\n) -&gt; PubSubT:\n    \"\"\"\n    Return a Publish/Subscribe object. With this object, you can\n    subscribe to channels and listen for messages that get published to\n    \"\"\"\n    if retryable is None: retryable = self.settings.retry.pubsub_enabled\n    return self.client.pubsub(retryable = retryable, **kwargs)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aacl_log","title":"aacl_log  <code>async</code>","text":"<pre><code>aacl_log(\n    count: typing.Union[int, None] = None, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Get ACL logs as a list. :param int count: Get logs[0:count]. :rtype: List.</p> <p>For more information see https://redis.io/commands/acl-log</p> Source code in <code>kvdb/components/session.py</code> <pre><code>if 'name' not in persistence_config: persistence_config['name'] = self.name\nif base_key is not None: persistence_config['base_key'] = base_key\npersistence_config.update(kwargs)\nbase_key = persistence_config.get('base_key')\nif base_key in self._persistence_ctx:\n    return self._persistence_ctx[base_key]\np = KVDBStatefulBackend.as_persistent_dict(\n    session = self,\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aacl_log_reset","title":"aacl_log_reset  <code>async</code>","text":"<pre><code>aacl_log_reset(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Reset ACL logs. :rtype: Boolean.</p> <p>For more information see https://redis.io/commands/acl-log</p> Source code in <code>kvdb/components/session.py</code> <pre><code>        **persistence_config,\n    )\n    self._persistence_ctx[base_key] = p\n    return p\n\ndef pubsub(\n    self, \n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aacl_save","title":"aacl_save  <code>async</code>","text":"<pre><code>aacl_save(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Save ACL rules to the configured <code>aclfile</code>.</p> <p>Note that the server must be configured with the <code>aclfile</code> directive to be able to save ACL rules to an aclfile.</p> <p>For more information see https://redis.io/commands/acl-save</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def apubsub(\n    self, \n    retryable: Optional[bool] = None,\n    **kwargs\n) -&gt; AsyncPubSubT:\n    \"\"\"\n    Return a Publish/Subscribe object. With this object, you can\n    subscribe to channels and listen for messages that get published to\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aacl_setuser","title":"aacl_setuser  <code>async</code>","text":"<pre><code>aacl_setuser(\n    username: str,\n    enabled: bool = False,\n    nopass: bool = False,\n    passwords: typing.Union[\n        str, typing.Iterable[str], None\n    ] = None,\n    hashed_passwords: typing.Union[\n        str, typing.Iterable[str], None\n    ] = None,\n    categories: typing.Optional[\n        typing.Iterable[str]\n    ] = None,\n    commands: typing.Optional[typing.Iterable[str]] = None,\n    keys: typing.Optional[\n        typing.Iterable[kvdb.types.generic.KeyT]\n    ] = None,\n    channels: typing.Optional[\n        typing.Iterable[redis.typing.ChannelT]\n    ] = None,\n    selectors: typing.Optional[\n        typing.Iterable[\n            typing.Tuple[str, kvdb.types.generic.KeyT]\n        ]\n    ] = None,\n    reset: bool = False,\n    reset_keys: bool = False,\n    reset_channels: bool = False,\n    reset_passwords: bool = False,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Create or update an ACL user.</p> <p>Create or update the ACL for <code>username</code>. If the user already exists, the existing ACL is completely overwritten and replaced with the specified values.</p> <p><code>enabled</code> is a boolean indicating whether the user should be allowed to authenticate or not. Defaults to <code>False</code>.</p> <p><code>nopass</code> is a boolean indicating whether the can authenticate without a password. This cannot be True if <code>passwords</code> are also specified.</p> <p><code>passwords</code> if specified is a list of plain text passwords to add to or remove from the user. Each password must be prefixed with a '+' to add or a '-' to remove. For convenience, the value of <code>passwords</code> can be a simple prefixed string when adding or removing a single password.</p> <p><code>hashed_passwords</code> if specified is a list of SHA-256 hashed passwords to add to or remove from the user. Each hashed password must be prefixed with a '+' to add or a '-' to remove. For convenience, the value of <code>hashed_passwords</code> can be a simple prefixed string when adding or removing a single password.</p> <p><code>categories</code> if specified is a list of strings representing category permissions. Each string must be prefixed with either a '+' to add the category permission or a '-' to remove the category permission.</p> <p><code>commands</code> if specified is a list of strings representing command permissions. Each string must be prefixed with either a '+' to add the command permission or a '-' to remove the command permission.</p> <p><code>keys</code> if specified is a list of key patterns to grant the user access to. Keys patterns allow '' to support wildcard matching. For example, '' grants access to all keys while 'cache:*' grants access to all keys that are prefixed with 'cache:'. <code>keys</code> should not be prefixed with a '~'.</p> <p><code>reset</code> is a boolean indicating whether the user should be fully reset prior to applying the new ACL. Setting this to True will remove all existing passwords, flags and privileges from the user and then apply the specified rules. If this is False, the user's existing passwords, flags and privileges will be kept and any new specified rules will be applied on top.</p> <p><code>reset_keys</code> is a boolean indicating whether the user's key permissions should be reset prior to applying any new key permissions specified in <code>keys</code>. If this is False, the user's existing key permissions will be kept and any new specified key permissions will be applied on top.</p> <p><code>reset_channels</code> is a boolean indicating whether the user's channel permissions should be reset prior to applying any new channel permissions specified in <code>channels</code>.If this is False, the user's existing channel permissions will be kept and any new specified channel permissions will be applied on top.</p> <p><code>reset_passwords</code> is a boolean indicating whether to remove all existing passwords and the 'nopass' flag from the user prior to applying any new passwords specified in 'passwords' or 'hashed_passwords'. If this is False, the user's existing passwords and 'nopass' status will be kept and any new specified passwords or hashed_passwords will be applied on top.</p> <p>For more information see https://redis.io/commands/acl-setuser</p> Source code in <code>kvdb/components/session.py</code> <pre><code>    \"\"\"\n    if retryable is None: retryable = self.settings.retry.pubsub_enabled\n    return self.aclient.pubsub(retryable = retryable, **kwargs)\n\n\"\"\"\nPubSub Utility Methods\n\"\"\"\n\ndef pipeline(\n    self, \n    transaction: Optional[bool] = True, \n    shard_hint: Optional[str] = None, \n    retryable: Optional[bool] = None,\n    **kwargs\n) -&gt; PipelineT:\n    \"\"\"\n    Return a new pipeline object that can queue multiple commands for\n    later execution. ``transaction`` indicates whether all commands\n    should be executed atomically. Apart from making a group of operations\n    atomic, pipelines are useful for reducing the back-and-forth overhead\n    between the client and server.\n    \"\"\"\n    if retryable is None: retryable = self.settings.retry.pipeline_enabled\n    return self.client.pipeline(transaction = transaction, shard_hint = shard_hint, retryable = retryable)\n\ndef apipeline(\n    self, \n    transaction: Optional[bool] = True, \n    shard_hint: Optional[str] = None, \n    retryable: Optional[bool] = None,\n    **kwargs\n) -&gt; AsyncPipelineT:\n    \"\"\"\n    Return a new pipeline object that can queue multiple commands for\n    later execution. ``transaction`` indicates whether all commands\n    should be executed atomically. Apart from making a group of operations\n    atomic, pipelines are useful for reducing the back-and-forth overhead\n    between the client and server.\n    \"\"\"\n    if retryable is None: retryable = self.settings.retry.pipeline_enabled\n    return self.aclient.pipeline(transaction = transaction, shard_hint = shard_hint, retryable = retryable)\n\ndef lock(\n    self, \n    name: str, \n    timeout: Optional[Number] = None,\n    sleep: Optional[Number] = 0.1,\n    blocking: Optional[bool] = True,\n    blocking_timeout: Optional[Number] = None,\n    thread_local: Optional[bool] = True,\n    force_unlock: Optional[bool] = None,\n    **kwargs,\n) -&gt; Lock:\n    \"\"\"\n    Create a new Lock instance named ``name`` using the Redis client\n    supplied by ``keydb``.\n\n    ``timeout`` indicates a maximum life for the lock in seconds.\n    By default, it will remain locked until release() is called.\n    ``timeout`` can be specified as a float or integer, both representing\n    the number of seconds to wait.\n\n    ``sleep`` indicates the amount of time to sleep in seconds per loop\n    iteration when the lock is in blocking mode and another client is\n    currently holding the lock.\n\n    ``blocking`` indicates whether calling ``acquire`` should block until\n    the lock has been acquired or to fail immediately, causing ``acquire``\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aacl_users","title":"aacl_users  <code>async</code>","text":"<pre><code>aacl_users(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a list of all registered users on the server.</p> <p>For more information see https://redis.io/commands/acl-users</p> Source code in <code>kvdb/components/session.py</code> <pre><code>to return False and the lock not being acquired. Defaults to True.\nNote this value can be overridden by passing a ``blocking``\nargument to ``acquire``.\n\n``blocking_timeout`` indicates the maximum amount of time in seconds to\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aacl_whoami","title":"aacl_whoami  <code>async</code>","text":"<pre><code>aacl_whoami(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Get the username for the current connection</p> <p>For more information see https://redis.io/commands/acl-whoami</p> Source code in <code>kvdb/components/session.py</code> <pre><code>spend trying to acquire the lock. A value of ``None`` indicates\ncontinue trying forever. ``blocking_timeout`` can be specified as a\nfloat or integer, both representing the number of seconds to wait.\n\n``thread_local`` indicates whether the lock token is placed in\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aappend","title":"aappend  <code>async</code>","text":"<pre><code>aappend(\n    key: kvdb.types.generic.KeyT,\n    value: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Appends the string <code>value</code> to the value at <code>key</code>. If <code>key</code> doesn't already exist, create it with a value of <code>value</code>. Returns the new length of the value at <code>key</code>.</p> <p>For more information see https://redis.io/commands/append</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aauth","title":"aauth  <code>async</code>","text":"<pre><code>aauth(\n    password: str,\n    username: typing.Optional[str] = None,\n    **kwargs\n)\n</code></pre> <p>Authenticates the user. If you do not pass username, Redis will try to authenticate for the \"default\" user. If you do pass username, it will authenticate for the given user. For more information see https://redis.io/commands/auth</p> Source code in <code>kvdb/components/session.py</code> <pre><code>if name not in self.state.locks:\n    self.state.locks[name] = Lock(\n        self.client, \n        name = name, \n        timeout = timeout, \n        sleep = sleep, \n        blocking = blocking, \n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.abgrewriteaof","title":"abgrewriteaof  <code>async</code>","text":"<pre><code>abgrewriteaof(**kwargs)\n</code></pre> <p>Tell the Redis server to rewrite the AOF file from data in memory.</p> <p>For more information see https://redis.io/commands/bgrewriteaof</p> Source code in <code>kvdb/components/session.py</code> <pre><code>        blocking_timeout = blocking_timeout, \n        thread_local = thread_local,\n        force_unlock = force_unlock,\n    )\nif self.state.lock is None: self.state.lock = self.state.locks[name]\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.abgsave","title":"abgsave  <code>async</code>","text":"<pre><code>abgsave(\n    schedule: bool = True, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Tell the Redis server to save its data to disk.  Unlike save(), this method is asynchronous and returns immediately.</p> <p>For more information see https://redis.io/commands/bgsave</p> Source code in <code>kvdb/components/session.py</code> <pre><code>    return self.state.locks[name]\n\ndef alock(\n    self, \n    name: str, \n    timeout: Optional[Number] = None,\n    sleep: Number = 0.1,\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.abitcount","title":"abitcount  <code>async</code>","text":"<pre><code>abitcount(\n    key: kvdb.types.generic.KeyT,\n    start: typing.Union[int, None] = None,\n    end: typing.Union[int, None] = None,\n    mode: typing.Optional[str] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the count of set bits in the value of <code>key</code>.  Optional <code>start</code> and <code>end</code> parameters indicate which bytes to consider</p> <p>For more information see https://redis.io/commands/bitcount</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.abitfield","title":"abitfield  <code>async</code>","text":"<pre><code>abitfield(\n    key: kvdb.types.generic.KeyT,\n    default_overflow: typing.Union[str, None] = None,\n) -&gt; redis.commands.core.BitFieldOperation\n</code></pre> <p>Return a BitFieldOperation instance to conveniently construct one or more bitfield operations on <code>key</code>.</p> <p>For more information see https://redis.io/commands/bitfield</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.abitfield_ro","title":"abitfield_ro  <code>async</code>","text":"<pre><code>abitfield_ro(\n    key: kvdb.types.generic.KeyT,\n    encoding: str,\n    offset: redis.typing.BitfieldOffsetT,\n    items: typing.Optional[list] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return an array of the specified bitfield values where the first value is found using <code>encoding</code> and <code>offset</code> parameters and remaining values are result of corresponding encoding/offset pairs in optional list <code>items</code> Read-only variant of the BITFIELD command.</p> <p>For more information see https://redis.io/commands/bitfield_ro</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.abitop","title":"abitop  <code>async</code>","text":"<pre><code>abitop(\n    operation: str,\n    dest: kvdb.types.generic.KeyT,\n    *keys: kvdb.types.generic.KeyT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Perform a bitwise operation using <code>operation</code> between <code>keys</code> and store the result in <code>dest</code>.</p> <p>For more information see https://redis.io/commands/bitop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.abitpos","title":"abitpos  <code>async</code>","text":"<pre><code>abitpos(\n    key: kvdb.types.generic.KeyT,\n    bit: int,\n    start: typing.Union[int, None] = None,\n    end: typing.Union[int, None] = None,\n    mode: typing.Optional[str] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the position of the first bit set to 1 or 0 in a string. <code>start</code> and <code>end</code> defines search range. The range is interpreted as a range of bytes and not a range of bits, so start=0 and end=2 means to look at the first three bytes.</p> <p>For more information see https://redis.io/commands/bitpos</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ablmove","title":"ablmove  <code>async</code>","text":"<pre><code>ablmove(\n    first_list: str,\n    second_list: str,\n    timeout: int,\n    src: str = \"LEFT\",\n    dest: str = \"RIGHT\",\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Blocking version of lmove.</p> <p>For more information see https://redis.io/commands/blmove</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ablmpop","title":"ablmpop  <code>async</code>","text":"<pre><code>ablmpop(\n    timeout: float,\n    numkeys: int,\n    *args: typing.List[str],\n    direction: str,\n    count: typing.Optional[int] = 1\n) -&gt; typing.Optional[list]\n</code></pre> <p>Pop <code>count</code> values (default 1) from first non-empty in the list of provided key names.</p> <p>When all lists are empty this command blocks the connection until another client pushes to it or until the timeout, timeout of 0 blocks indefinitely</p> <p>For more information see https://redis.io/commands/blmpop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ablpop","title":"ablpop  <code>async</code>","text":"<pre><code>ablpop(\n    keys: typing.List, timeout: typing.Optional[int] = 0\n) -&gt; typing.Union[typing.Awaitable[list], list]\n</code></pre> <p>LPOP a value off of the first non-empty list named in the <code>keys</code> list.</p> <p>If none of the lists in <code>keys</code> has a value to LPOP, then block for <code>timeout</code> seconds, or until a value gets pushed on to one of the lists.</p> <p>If timeout is 0, then block indefinitely.</p> <p>For more information see https://redis.io/commands/blpop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.abrpop","title":"abrpop  <code>async</code>","text":"<pre><code>abrpop(\n    keys: typing.List, timeout: typing.Optional[int] = 0\n) -&gt; typing.Union[typing.Awaitable[list], list]\n</code></pre> <p>RPOP a value off of the first non-empty list named in the <code>keys</code> list.</p> <p>If none of the lists in <code>keys</code> has a value to RPOP, then block for <code>timeout</code> seconds, or until a value gets pushed on to one of the lists.</p> <p>If timeout is 0, then block indefinitely.</p> <p>For more information see https://redis.io/commands/brpop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.abrpoplpush","title":"abrpoplpush  <code>async</code>","text":"<pre><code>abrpoplpush(\n    src: str, dst: str, timeout: typing.Optional[int] = 0\n) -&gt; typing.Union[\n    typing.Awaitable[typing.Optional[str]],\n    typing.Optional[str],\n]\n</code></pre> <p>Pop a value off the tail of <code>src</code>, push it on the head of <code>dst</code> and then return it.</p> <p>This command blocks until a value is in <code>src</code> or until <code>timeout</code> seconds elapse, whichever is first. A <code>timeout</code> value of 0 blocks forever.</p> <p>For more information see https://redis.io/commands/brpoplpush</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.abzmpop","title":"abzmpop  <code>async</code>","text":"<pre><code>abzmpop(\n    timeout: float,\n    numkeys: int,\n    keys: typing.List[str],\n    min: typing.Optional[bool] = False,\n    max: typing.Optional[bool] = False,\n    count: typing.Optional[int] = 1,\n) -&gt; typing.Optional[list]\n</code></pre> <p>Pop <code>count</code> values (default 1) off of the first non-empty sorted set named in the <code>keys</code> list.</p> <p>If none of the sorted sets in <code>keys</code> has a value to pop, then block for <code>timeout</code> seconds, or until a member gets added to one of the sorted sets.</p> <p>If timeout is 0, then block indefinitely.</p> <p>For more information see https://redis.io/commands/bzmpop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.abzpopmax","title":"abzpopmax  <code>async</code>","text":"<pre><code>abzpopmax(\n    keys: redis.typing.KeysT,\n    timeout: redis.typing.TimeoutSecT = 0,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>ZPOPMAX a value off of the first non-empty sorted set named in the <code>keys</code> list.</p> <p>If none of the sorted sets in <code>keys</code> has a value to ZPOPMAX, then block for <code>timeout</code> seconds, or until a member gets added to one of the sorted sets.</p> <p>If timeout is 0, then block indefinitely.</p> <p>For more information see https://redis.io/commands/bzpopmax</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.abzpopmin","title":"abzpopmin  <code>async</code>","text":"<pre><code>abzpopmin(\n    keys: redis.typing.KeysT,\n    timeout: redis.typing.TimeoutSecT = 0,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>ZPOPMIN a value off of the first non-empty sorted set named in the <code>keys</code> list.</p> <p>If none of the sorted sets in <code>keys</code> has a value to ZPOPMIN, then block for <code>timeout</code> seconds, or until a member gets added to one of the sorted sets.</p> <p>If timeout is 0, then block indefinitely.</p> <p>For more information see https://redis.io/commands/bzpopmin</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acl_cat","title":"acl_cat","text":"<pre><code>acl_cat(\n    category: typing.Union[str, None] = None, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a list of categories or commands within a category.</p> <p>If <code>category</code> is not supplied, returns a list of all categories. If <code>category</code> is supplied, returns a list of all commands within that category.</p> <p>For more information see https://redis.io/commands/acl-cat</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acl_deluser","title":"acl_deluser","text":"<pre><code>acl_deluser(\n    *username: str, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Delete the ACL for the specified <code>username</code>s</p> <p>For more information see https://redis.io/commands/acl-deluser</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acl_dryrun","title":"acl_dryrun","text":"<pre><code>acl_dryrun(username, *args, **kwargs)\n</code></pre> <p>Simulate the execution of a given command by a given <code>username</code>.</p> <p>For more information see https://redis.io/commands/acl-dryrun</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acl_genpass","title":"acl_genpass","text":"<pre><code>acl_genpass(\n    bits: typing.Union[int, None] = None, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Generate a random password value. If <code>bits</code> is supplied then use this number of bits, rounded to the next multiple of 4. See: https://redis.io/commands/acl-genpass</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acl_getuser","title":"acl_getuser","text":"<pre><code>acl_getuser(\n    username: str, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Get the ACL details for the specified <code>username</code>.</p> <p>If <code>username</code> does not exist, return None</p> <p>For more information see https://redis.io/commands/acl-getuser</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acl_help","title":"acl_help","text":"<pre><code>acl_help(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>The ACL HELP command returns helpful text describing the different subcommands.</p> <p>For more information see https://redis.io/commands/acl-help</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acl_list","title":"acl_list","text":"<pre><code>acl_list(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a list of all ACLs on the server</p> <p>For more information see https://redis.io/commands/acl-list</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acl_load","title":"acl_load","text":"<pre><code>acl_load(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Load ACL rules from the configured <code>aclfile</code>.</p> <p>Note that the server must be configured with the <code>aclfile</code> directive to be able to load ACL rules from an aclfile.</p> <p>For more information see https://redis.io/commands/acl-load</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acl_log","title":"acl_log","text":"<pre><code>acl_log(\n    count: typing.Union[int, None] = None, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Get ACL logs as a list. :param int count: Get logs[0:count]. :rtype: List.</p> <p>For more information see https://redis.io/commands/acl-log</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acl_log_reset","title":"acl_log_reset","text":"<pre><code>acl_log_reset(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Reset ACL logs. :rtype: Boolean.</p> <p>For more information see https://redis.io/commands/acl-log</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acl_save","title":"acl_save","text":"<pre><code>acl_save(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Save ACL rules to the configured <code>aclfile</code>.</p> <p>Note that the server must be configured with the <code>aclfile</code> directive to be able to save ACL rules to an aclfile.</p> <p>For more information see https://redis.io/commands/acl-save</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acl_setuser","title":"acl_setuser","text":"<pre><code>acl_setuser(\n    username: str,\n    enabled: bool = False,\n    nopass: bool = False,\n    passwords: typing.Union[\n        str, typing.Iterable[str], None\n    ] = None,\n    hashed_passwords: typing.Union[\n        str, typing.Iterable[str], None\n    ] = None,\n    categories: typing.Optional[\n        typing.Iterable[str]\n    ] = None,\n    commands: typing.Optional[typing.Iterable[str]] = None,\n    keys: typing.Optional[\n        typing.Iterable[kvdb.types.generic.KeyT]\n    ] = None,\n    channels: typing.Optional[\n        typing.Iterable[redis.typing.ChannelT]\n    ] = None,\n    selectors: typing.Optional[\n        typing.Iterable[\n            typing.Tuple[str, kvdb.types.generic.KeyT]\n        ]\n    ] = None,\n    reset: bool = False,\n    reset_keys: bool = False,\n    reset_channels: bool = False,\n    reset_passwords: bool = False,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Create or update an ACL user.</p> <p>Create or update the ACL for <code>username</code>. If the user already exists, the existing ACL is completely overwritten and replaced with the specified values.</p> <p><code>enabled</code> is a boolean indicating whether the user should be allowed to authenticate or not. Defaults to <code>False</code>.</p> <p><code>nopass</code> is a boolean indicating whether the can authenticate without a password. This cannot be True if <code>passwords</code> are also specified.</p> <p><code>passwords</code> if specified is a list of plain text passwords to add to or remove from the user. Each password must be prefixed with a '+' to add or a '-' to remove. For convenience, the value of <code>passwords</code> can be a simple prefixed string when adding or removing a single password.</p> <p><code>hashed_passwords</code> if specified is a list of SHA-256 hashed passwords to add to or remove from the user. Each hashed password must be prefixed with a '+' to add or a '-' to remove. For convenience, the value of <code>hashed_passwords</code> can be a simple prefixed string when adding or removing a single password.</p> <p><code>categories</code> if specified is a list of strings representing category permissions. Each string must be prefixed with either a '+' to add the category permission or a '-' to remove the category permission.</p> <p><code>commands</code> if specified is a list of strings representing command permissions. Each string must be prefixed with either a '+' to add the command permission or a '-' to remove the command permission.</p> <p><code>keys</code> if specified is a list of key patterns to grant the user access to. Keys patterns allow '' to support wildcard matching. For example, '' grants access to all keys while 'cache:*' grants access to all keys that are prefixed with 'cache:'. <code>keys</code> should not be prefixed with a '~'.</p> <p><code>reset</code> is a boolean indicating whether the user should be fully reset prior to applying the new ACL. Setting this to True will remove all existing passwords, flags and privileges from the user and then apply the specified rules. If this is False, the user's existing passwords, flags and privileges will be kept and any new specified rules will be applied on top.</p> <p><code>reset_keys</code> is a boolean indicating whether the user's key permissions should be reset prior to applying any new key permissions specified in <code>keys</code>. If this is False, the user's existing key permissions will be kept and any new specified key permissions will be applied on top.</p> <p><code>reset_channels</code> is a boolean indicating whether the user's channel permissions should be reset prior to applying any new channel permissions specified in <code>channels</code>.If this is False, the user's existing channel permissions will be kept and any new specified channel permissions will be applied on top.</p> <p><code>reset_passwords</code> is a boolean indicating whether to remove all existing passwords and the 'nopass' flag from the user prior to applying any new passwords specified in 'passwords' or 'hashed_passwords'. If this is False, the user's existing passwords and 'nopass' status will be kept and any new specified passwords or hashed_passwords will be applied on top.</p> <p>For more information see https://redis.io/commands/acl-setuser</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acl_users","title":"acl_users","text":"<pre><code>acl_users(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a list of all registered users on the server.</p> <p>For more information see https://redis.io/commands/acl-users</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acl_whoami","title":"acl_whoami","text":"<pre><code>acl_whoami(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Get the username for the current connection</p> <p>For more information see https://redis.io/commands/acl-whoami</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclear","title":"aclear  <code>async</code>","text":"<pre><code>aclear()\n</code></pre> <p>Clears the current database</p> Source code in <code>kvdb/components/session.py</code> <pre><code>async def aclear(self):\n    \"\"\"\n    Clears the current database\n    \"\"\"\n    return await self.aclient.flushdb()\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_getname","title":"aclient_getname  <code>async</code>","text":"<pre><code>aclient_getname(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the current connection name</p> <p>For more information see https://redis.io/commands/client-getname</p> Source code in <code>kvdb/components/session.py</code> <pre><code>            force_unlock = force_unlock,\n        )\n    if self.state.alock is None: self.state.alock = self.state.alocks[name]\n    return self.state.alocks[name]\n\n\"\"\"\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_getredir","title":"aclient_getredir  <code>async</code>","text":"<pre><code>aclient_getredir(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the ID (an integer) of the client to whom we are redirecting tracking notifications.</p> <p>see: https://redis.io/commands/client-getredir</p> Source code in <code>kvdb/components/session.py</code> <pre><code>Lock Utility Methods\n\"\"\"\n\ndef close_locks(\n    self, \n    names: Optional[Union[List[str], str]] = None,\n    force: Optional[bool] = False,\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_id","title":"aclient_id  <code>async</code>","text":"<pre><code>aclient_id(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the current connection id</p> <p>For more information see https://redis.io/commands/client-id</p> Source code in <code>kvdb/components/session.py</code> <pre><code>):\n    \"\"\"\n    Closes the locks that are currently managed by the session\n    \"\"\"\n    if names is None: names = list(self.state.alocks.keys())\n    if isinstance(names, str): names = [names]\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_info","title":"aclient_info  <code>async</code>","text":"<pre><code>aclient_info(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns information and statistics about the current client connection.</p> <p>For more information see https://redis.io/commands/client-info</p> Source code in <code>kvdb/components/session.py</code> <pre><code>spend trying to acquire the lock. A value of ``None`` indicates\ncontinue trying forever. ``blocking_timeout`` can be specified as a\nfloat or integer, both representing the number of seconds to wait.\n\n``thread_local`` indicates whether the lock token is placed in\nthread-local storage. By default, the token is placed in thread local\nstorage so that a thread only sees its token, not a token set by\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_kill","title":"aclient_kill  <code>async</code>","text":"<pre><code>aclient_kill(\n    address: str, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Disconnects the client at <code>address</code> (ip:port)</p> <p>For more information see https://redis.io/commands/client-kill</p> Source code in <code>kvdb/components/session.py</code> <pre><code>supplied by ``keydb``.\n\n``timeout`` indicates a maximum life for the lock in seconds.\nBy default, it will remain locked until release() is called.\n``timeout`` can be specified as a float or integer, both representing\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_kill_filter","title":"aclient_kill_filter  <code>async</code>","text":"<pre><code>aclient_kill_filter(\n    _id: typing.Union[str, None] = None,\n    _type: typing.Union[str, None] = None,\n    addr: typing.Union[str, None] = None,\n    skipme: typing.Union[bool, None] = None,\n    laddr: typing.Union[bool, None] = None,\n    user: str = None,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Disconnects client(s) using a variety of filter options :param _id: Kills a client by its unique ID field :param _type: Kills a client by type where type is one of 'normal', 'master', 'slave' or 'pubsub' :param addr: Kills a client by its 'address:port' :param skipme: If True, then the client calling the command will not get killed even if it is identified by one of the filter options. If skipme is not provided, the server defaults to skipme=True :param laddr: Kills a client by its 'local (bind) address:port' :param user: Kills a client for a specific user name</p> Source code in <code>kvdb/components/session.py</code> <pre><code>the number of seconds to wait.\n\n``sleep`` indicates the amount of time to sleep in seconds per loop\niteration when the lock is in blocking mode and another client is\ncurrently holding the lock.\n\n``blocking`` indicates whether calling ``acquire`` should block until\nthe lock has been acquired or to fail immediately, causing ``acquire``\nto return False and the lock not being acquired. Defaults to True.\nNote this value can be overridden by passing a ``blocking``\nargument to ``acquire``.\n\n``blocking_timeout`` indicates the maximum amount of time in seconds to\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_list","title":"aclient_list  <code>async</code>","text":"<pre><code>aclient_list(\n    _type: typing.Union[str, None] = None,\n    client_id: typing.List[redis.typing.EncodableT] = [],\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a list of currently connected clients. If type of client specified, only that type will be returned.</p> <p>:param _type: optional. one of the client types (normal, master,  replica, pubsub) :param client_id: optional. a list of client ids</p> <p>For more information see https://redis.io/commands/client-list</p> Source code in <code>kvdb/components/session.py</code> <pre><code>another thread. \n\"\"\"\nif name not in self.state.alocks:\n    self.state.alocks[name] = AsyncLock(\n        self.aclient, \n        name = name, \n        timeout = timeout, \n        sleep = sleep, \n        blocking = blocking, \n        blocking_timeout = blocking_timeout, \n        thread_local = thread_local,\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_no_evict","title":"aclient_no_evict  <code>async</code>","text":"<pre><code>aclient_no_evict(\n    mode: str,\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Sets the client eviction mode for the current connection.</p> <p>For more information see https://redis.io/commands/client-no-evict</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def __getitem__(self, key: KeyT) -&gt; ResponseT:\n    \"\"\"\n    [Dict] Returns the value for the given key\n    \"\"\"\n    return self.getitem(key)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_no_touch","title":"aclient_no_touch  <code>async</code>","text":"<pre><code>aclient_no_touch(\n    mode: str,\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_no_touch--the-command-controls-whether-commands-sent-by-the-client-will-alter","title":"The command controls whether commands sent by the client will alter","text":""},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_no_touch--the-lrulfu-of-the-keys-they-access","title":"the LRU/LFU of the keys they access.","text":""},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_no_touch--when-turned-on-the-current-client-will-not-change-lfulru-stats","title":"When turned on, the current client will not change LFU/LRU stats,","text":""},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_no_touch--unless-it-sends-the-touch-command","title":"unless it sends the TOUCH command.","text":"<p>For more information see https://redis.io/commands/client-no-touch</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def __delitem__(self, key: KeyT) -&gt; None:\n    \"\"\"\n    [Dict] Deletes the key\n    \"\"\"\n    if settings.is_in_async_loop():\n        return ThreadPooler.create_background_task(self.adelitem, key)\n    return self.delitem(key)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_pause","title":"aclient_pause  <code>async</code>","text":"<pre><code>aclient_pause(\n    timeout: int, all: bool = True, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Suspend all the Redis clients for the specified amount of time.</p> <p>For more information see https://redis.io/commands/client-pause</p> <p>:param timeout: milliseconds to pause clients :param all: If true (default) all client commands are blocked. otherwise, clients are only blocked if they attempt to execute a write command. For the WRITE mode, some commands have special behavior: EVAL/EVALSHA: Will block client for all scripts. PUBLISH: Will block client. PFCOUNT: Will block client. WAIT: Acknowledgments will be delayed, so this command will appear blocked.</p> Source code in <code>kvdb/components/session.py</code> <pre><code>    \"\"\"\n    return self.client.flushdb()\n\nasync def aclear(self):\n    \"\"\"\n    Clears the current database\n    \"\"\"\n    return await self.aclient.flushdb()\n\n\n\"\"\"\nDict-Like Interface\n\"\"\"\n\ndef __setitem__(self, key: KeyT, value: Any) -&gt; None:\n    \"\"\"\n    [Dict] Sets the value for the given key\n    \"\"\"\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_reply","title":"aclient_reply  <code>async</code>","text":"<pre><code>aclient_reply(\n    reply: typing.Union[\n        typing.Literal[\"ON\"],\n        typing.Literal[\"OFF\"],\n        typing.Literal[\"SKIP\"],\n    ],\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Enable and disable redis server replies.</p> <p><code>reply</code> Must be ON OFF or SKIP, ON - The default most with server replies to commands OFF - Disable server responses to commands SKIP - Skip the response of the immediately following command.</p> <p>Note: When setting OFF or SKIP replies, you will need a client object with a timeout specified in seconds, and will need to catch the TimeoutError. The test_client_reply unit test illustrates this, and conftest.py has a client with a timeout.</p> <p>See https://redis.io/commands/client-reply</p> Source code in <code>kvdb/components/session.py</code> <pre><code>    raise_errors: Optional[bool] = False,\n):\n    \"\"\"\n    Closes the locks that are currently managed by the session\n    \"\"\"\n    if names is None: names = list(self.state.locks.keys())\n    if isinstance(names, str): names = [names]\n    for name in names:\n        if name in self.state.locks:\n            self.state.locks[name].release(force = force, raise_errors = raise_errors)\n            del self.state.locks[name]\n\nasync def aclose_locks(\n    self, \n    names: Optional[Union[List[str], str]] = None,\n    force: Optional[bool] = False,\n    raise_errors: Optional[bool] = False,\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_setinfo","title":"aclient_setinfo  <code>async</code>","text":"<pre><code>aclient_setinfo(\n    attr: str, value: str, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Sets the current connection library name or version For mor information see https://redis.io/commands/client-setinfo</p> Source code in <code>kvdb/components/session.py</code> <pre><code>    return self.persistence.delete(key)\n\nasync def adelitem(\n    self,\n    key: KeyT,\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_setname","title":"aclient_setname  <code>async</code>","text":"<pre><code>aclient_setname(\n    name: str, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Sets the current connection name</p> <p>For more information see https://redis.io/commands/client-setname</p> <p>.. note::    This method sets client name only for current connection.</p> <p>If you want to set a common name for all connections managed    by this client, use <code>client_name</code> constructor argument.</p> Source code in <code>kvdb/components/session.py</code> <pre><code>    \"\"\"\n    [Dict] Sets the value for the given key\n    \"\"\"\n    return await self.persistence.aset(key, value, ex = ex, **kwargs)\n\ndef delitem(\n    self,\n    key: KeyT,\n) -&gt; None:\n    \"\"\"\n    [Dict] Deletes the key\n    \"\"\"\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_tracking","title":"aclient_tracking  <code>async</code>","text":"<pre><code>aclient_tracking(\n    on: bool = True,\n    clientid: typing.Union[int, None] = None,\n    prefix: typing.Sequence[kvdb.types.generic.KeyT] = [],\n    bcast: bool = False,\n    optin: bool = False,\n    optout: bool = False,\n    noloop: bool = False,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Enables the tracking feature of the Redis server, that is used for server assisted client side caching.</p> <p><code>on</code> indicate for tracking on or tracking off. The dafualt is on.</p> <p><code>clientid</code> send invalidation messages to the connection with the specified ID.</p> <p><code>bcast</code> enable tracking in broadcasting mode. In this mode invalidation messages are reported for all the prefixes specified, regardless of the keys requested by the connection.</p> <p><code>optin</code>  when broadcasting is NOT active, normally don't track keys in read only commands, unless they are called immediately after a CLIENT CACHING yes command.</p> <p><code>optout</code> when broadcasting is NOT active, normally track keys in read only commands, unless they are called immediately after a CLIENT CACHING no command.</p> <p><code>noloop</code> don't send notifications about keys modified by this connection itself.</p> <p><code>prefix</code>  for broadcasting, register a given key prefix, so that notifications will be provided only for keys starting with this string.</p> <p>See https://redis.io/commands/client-tracking</p> Source code in <code>kvdb/components/session.py</code> <pre><code>) -&gt; ResponseT:\n    \"\"\"\n    [Dict] Returns the value for the given key\n    \"\"\"\n    return self.persistence.get(key, default)\n\n\nasync def agetitem(\n    self,\n    key: KeyT,\n    default: Optional[Any] = None,\n) -&gt; ResponseT:\n    \"\"\"\n    [Dict] Returns the value for the given key\n    \"\"\"\n    return await self.persistence.aget(key, default)\n\n\ndef setitem(\n    self,\n    key: KeyT,\n    value: Any,\n    ex: Optional[ExpiryT] = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    [Dict] Sets the value for the given key\n    \"\"\"\n    return self.persistence.set(key, value, ex = ex, **kwargs)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_tracking_off","title":"aclient_tracking_off  <code>async</code>","text":"<pre><code>aclient_tracking_off(\n    clientid: typing.Union[int, None] = None,\n    prefix: typing.Sequence[kvdb.types.generic.KeyT] = [],\n    bcast: bool = False,\n    optin: bool = False,\n    optout: bool = False,\n    noloop: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Turn off the tracking mode. For more information about the options look at client_tracking func.</p> <p>See https://redis.io/commands/client-tracking</p> Source code in <code>kvdb/components/session.py</code> <pre><code>Dict-Like Interface Powered by `PersistentDict`\n\"\"\"\n\ndef getitem(\n    self,\n    key: KeyT,\n    default: Optional[Any] = None,\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_tracking_on","title":"aclient_tracking_on  <code>async</code>","text":"<pre><code>aclient_tracking_on(\n    clientid: typing.Union[int, None] = None,\n    prefix: typing.Sequence[kvdb.types.generic.KeyT] = [],\n    bcast: bool = False,\n    optin: bool = False,\n    optout: bool = False,\n    noloop: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Turn on the tracking mode. For more information about the options look at client_tracking func.</p> <p>See https://redis.io/commands/client-tracking</p> Source code in <code>kvdb/components/session.py</code> <pre><code>    for name in names:\n        if name in self.state.alocks:\n            await self.state.alocks[name].release(force = force, raise_errors = raise_errors)\n            del self.state.alocks[name]\n\n\n\"\"\"\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_trackinginfo","title":"aclient_trackinginfo  <code>async</code>","text":"<pre><code>aclient_trackinginfo(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the information about the current client connection's use of the server assisted client side cache.</p> <p>See https://redis.io/commands/client-trackinginfo</p> Source code in <code>kvdb/components/session.py</code> <pre><code>async def asetitem(\n    self,\n    key: KeyT,\n    value: Any,\n    ex: Optional[ExpiryT] = None,\n    **kwargs: Any,\n) -&gt; None:\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_unblock","title":"aclient_unblock  <code>async</code>","text":"<pre><code>aclient_unblock(\n    client_id: int, error: bool = False, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Unblocks a connection by its client id. If <code>error</code> is True, unblocks the client with a special error message. If <code>error</code> is False (default), the client is unblocked using the regular timeout mechanism.</p> <p>For more information see https://redis.io/commands/client-unblock</p> Source code in <code>kvdb/components/session.py</code> <pre><code>) -&gt; None:\n    \"\"\"\n    [Dict] Deletes the key\n    \"\"\"\n    return await self.persistence.adelete(key)\n\ndef clear(self):\n    \"\"\"\n    Clears the current database\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclient_unpause","title":"aclient_unpause  <code>async</code>","text":"<pre><code>aclient_unpause(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Unpause all redis clients</p> <p>For more information see https://redis.io/commands/client-unpause</p> Source code in <code>kvdb/components/session.py</code> <pre><code>if settings.is_in_async_loop():\n    return ThreadPooler.create_background_task(\n        self.asetitem, key, value,\n    )\nreturn self.setitem(key, value)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclose","title":"aclose  <code>async</code>","text":"<pre><code>aclose(\n    close_pool: bool = False,\n    force: typing.Optional[bool] = None,\n    raise_errors: bool = False,\n)\n</code></pre> <p>Close the session</p> Source code in <code>kvdb/components/session.py</code> <pre><code>async def aclose(self, close_pool: bool = False, force: Optional[bool] = None, raise_errors: bool = False):\n    \"\"\"\n    Close the session\n    \"\"\"\n    await self.aclose_locks(force=force, raise_errors=raise_errors)\n    if self.state.apubsub is not None:\n        await self.state.apubsub.close()\n        self.state.apubsub = None\n\n    if self.state.aclient is not None:\n        await self.state.aclient.close()\n        if close_pool: await self.state.aclient.connection_pool.disconnect(raise_errors = raise_errors)\n        self.state.aclient = None\n\n    if self.state.client is not None:\n        self.state.client.close()\n        if close_pool: self.state.client.connection_pool.disconnect(raise_errors = raise_errors)\n        self.state.client = None\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aclose_locks","title":"aclose_locks  <code>async</code>","text":"<pre><code>aclose_locks(\n    names: typing.Optional[\n        typing.Union[typing.List[str], str]\n    ] = None,\n    force: typing.Optional[bool] = False,\n    raise_errors: typing.Optional[bool] = False,\n)\n</code></pre> <p>Closes the locks that are currently managed by the session</p> Source code in <code>kvdb/components/session.py</code> <pre><code>async def aclose_locks(\n    self, \n    names: Optional[Union[List[str], str]] = None,\n    force: Optional[bool] = False,\n    raise_errors: Optional[bool] = False,\n):\n    \"\"\"\n    Closes the locks that are currently managed by the session\n    \"\"\"\n    if names is None: names = list(self.state.alocks.keys())\n    if isinstance(names, str): names = [names]\n    for name in names:\n        if name in self.state.alocks:\n            await self.state.alocks[name].release(force = force, raise_errors = raise_errors)\n            del self.state.alocks[name]\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acommand_docs","title":"acommand_docs  <code>async</code>","text":"<pre><code>acommand_docs(*args) -&gt; None\n</code></pre> <p>This function throws a NotImplementedError since it is intentionally not supported.</p> Source code in <code>kvdb/components/session.py</code> <pre><code>            self.state.client.connection_pool.disconnect(raise_errors = raise_errors)\n        self.state.client = None\n\nasync def aclose(self, close_pool: bool = False, force: Optional[bool] = None, raise_errors: bool = False):\n    \"\"\"\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acommand_getkeysandflags","title":"acommand_getkeysandflags  <code>async</code>","text":"<pre><code>acommand_getkeysandflags(\n    *args: typing.List[str],\n) -&gt; typing.List[typing.Union[str, typing.List[str]]]\n</code></pre> <p>Returns array of keys from a full Redis command and their usage flags.</p> <p>For more information see https://redis.io/commands/command-getkeysandflags</p> Source code in <code>kvdb/components/session.py</code> <pre><code>    self.state.pubsub.close()\n    self.state.pubsub = None\n\nif self.state.client is not None:\n    self.state.client.close()\n    if close_pool:\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acommand_list","title":"acommand_list  <code>async</code>","text":"<pre><code>acommand_list(\n    module: typing.Optional[str] = None,\n    category: typing.Optional[str] = None,\n    pattern: typing.Optional[str] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return an array of the server's command names. You can use one of the following filters: <code>module</code>: get the commands that belong to the module <code>category</code>: get the commands in the ACL category <code>pattern</code>: get the commands that match the given pattern</p> <p>For more information see https://redis.io/commands/command-list/</p> Source code in <code>kvdb/components/session.py</code> <pre><code>\"\"\"\nClass Object Methods\n\"\"\"\n\ndef close(self, close_pool: bool = False, force: Optional[bool] = None, raise_errors: bool = False):\n    \"\"\"\n    Close the session\n    \"\"\"\n    self.close_locks(force=force, raise_errors=raise_errors)\n    if self.state.pubsub is not None:\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aconfig_get","title":"aconfig_get  <code>async</code>","text":"<pre><code>aconfig_get(\n    pattern: kvdb.types.generic.PatternT = \"*\",\n    *args: typing.List[kvdb.types.generic.PatternT],\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a dictionary of configuration based on the <code>pattern</code></p> <p>For more information see https://redis.io/commands/config-get</p> Source code in <code>kvdb/components/session.py</code> <pre><code>Close the session\n\"\"\"\nawait self.aclose_locks(force=force, raise_errors=raise_errors)\nif self.state.apubsub is not None:\n    await self.state.apubsub.close()\n    self.state.apubsub = None\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aconfig_resetstat","title":"aconfig_resetstat  <code>async</code>","text":"<pre><code>aconfig_resetstat(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Reset runtime statistics</p> <p>For more information see https://redis.io/commands/config-resetstat</p> Source code in <code>kvdb/components/session.py</code> <pre><code>if self.state.client is not None:\n    self.state.client.close()\n    if close_pool: self.state.client.connection_pool.disconnect(raise_errors = raise_errors)\n    self.state.client = None\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aconfig_rewrite","title":"aconfig_rewrite  <code>async</code>","text":"<pre><code>aconfig_rewrite(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Rewrite config file with the minimal change to reflect running config.</p> <p>For more information see https://redis.io/commands/config-rewrite</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def __enter__(self):\n    \"\"\"\n    Enter the runtime context related to this object.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aconfig_set","title":"aconfig_set  <code>async</code>","text":"<pre><code>aconfig_set(\n    name: kvdb.types.generic.KeyT,\n    value: redis.typing.EncodableT,\n    *args: typing.List[\n        typing.Union[\n            kvdb.types.generic.KeyT, redis.typing.EncodableT\n        ]\n    ],\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set config item <code>name</code> with <code>value</code></p> <p>For more information see https://redis.io/commands/config-set</p> Source code in <code>kvdb/components/session.py</code> <pre><code>if self.state.aclient is not None:\n    await self.state.aclient.close()\n    if close_pool: await self.state.aclient.connection_pool.disconnect(raise_errors = raise_errors)\n    self.state.aclient = None\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.acopy","title":"acopy  <code>async</code>","text":"<pre><code>acopy(\n    source: str,\n    destination: str,\n    destination_db: typing.Union[str, None] = None,\n    replace: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Copy the value stored in the <code>source</code> key to the <code>destination</code> key.</p> <p><code>destination_db</code> an alternative destination database. By default, the <code>destination</code> key is created in the source Redis database.</p> <p><code>replace</code> whether the <code>destination</code> key should be removed before copying the value to it. By default, the value is not copied if the <code>destination</code> key already exists.</p> <p>For more information see https://redis.io/commands/copy</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.adbsize","title":"adbsize  <code>async</code>","text":"<pre><code>adbsize(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the number of keys in the current database</p> <p>For more information see https://redis.io/commands/dbsize</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"\n    On exit, close the session\n    \"\"\"\n    self.close()\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.adebug_object","title":"adebug_object  <code>async</code>","text":"<pre><code>adebug_object(\n    key: kvdb.types.generic.KeyT, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns version specific meta information about a given key</p> <p>For more information see https://redis.io/commands/debug-object</p> Source code in <code>kvdb/components/session.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"\n    Enter the runtime context related to this object.\n    \"\"\"\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.adecrby","title":"adecrby  <code>async</code>","text":"<pre><code>adecrby(\n    name: kvdb.types.generic.KeyT, amount: int = 1\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Decrements the value of <code>key</code> by <code>amount</code>.  If no key exists, the value will be initialized as 0 - <code>amount</code></p> <p>For more information see https://redis.io/commands/decrby</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.adelete","title":"adelete  <code>async</code>","text":"<pre><code>adelete(\n    *names: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Delete one or more keys specified by <code>names</code></p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.adelitem","title":"adelitem  <code>async</code>","text":"<pre><code>adelitem(key: kvdb.types.generic.KeyT) -&gt; None\n</code></pre> <p>[Dict] Deletes the key</p> Source code in <code>kvdb/components/session.py</code> <pre><code>async def adelitem(\n    self,\n    key: KeyT,\n) -&gt; None:\n    \"\"\"\n    [Dict] Deletes the key\n    \"\"\"\n    return await self.persistence.adelete(key)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.adump","title":"adump  <code>async</code>","text":"<pre><code>adump(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a serialized version of the value stored at the specified key. If key does not exist a nil bulk reply is returned.</p> <p>For more information see https://redis.io/commands/dump</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aecho","title":"aecho  <code>async</code>","text":"<pre><code>aecho(\n    value: redis.typing.EncodableT, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Echo the string back from the server</p> <p>For more information see https://redis.io/commands/echo</p> Source code in <code>kvdb/components/session.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"\n    Close the session\n    \"\"\"\n    await self.aclose()\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aeval","title":"aeval  <code>async</code>","text":"<pre><code>aeval(\n    script: str, numkeys: int, *keys_and_args: list\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Execute the Lua <code>script</code>, specifying the <code>numkeys</code> the script will touch and the key names and argument values in <code>keys_and_args</code>. Returns the result of the script.</p> <p>In practice, use the object returned by <code>register_script</code>. This function exists purely for Redis API completion.</p> <p>For more information see  https://redis.io/commands/eval</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aeval_ro","title":"aeval_ro  <code>async</code>","text":"<pre><code>aeval_ro(\n    script: str, numkeys: int, *keys_and_args: list\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>The read-only variant of the EVAL command</p> <p>Execute the read-only Lua <code>script</code> specifying the <code>numkeys</code> the script will touch and the key names and argument values in <code>keys_and_args</code>. Returns the result of the script.</p> <p>For more information see  https://redis.io/commands/eval_ro</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aevalsha","title":"aevalsha  <code>async</code>","text":"<pre><code>aevalsha(\n    sha: str, numkeys: int, *keys_and_args: list\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Use the <code>sha</code> to execute a Lua script already registered via EVAL or SCRIPT LOAD. Specify the <code>numkeys</code> the script will touch and the key names and argument values in <code>keys_and_args</code>. Returns the result of the script.</p> <p>In practice, use the object returned by <code>register_script</code>. This function exists purely for Redis API completion.</p> <p>For more information see  https://redis.io/commands/evalsha</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aevalsha_ro","title":"aevalsha_ro  <code>async</code>","text":"<pre><code>aevalsha_ro(\n    sha: str, numkeys: int, *keys_and_args: list\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>The read-only variant of the EVALSHA command</p> <p>Use the <code>sha</code> to execute a read-only Lua script already registered via EVAL or SCRIPT LOAD. Specify the <code>numkeys</code> the script will touch and the key names and argument values in <code>keys_and_args</code>. Returns the result of the script.</p> <p>For more information see  https://redis.io/commands/evalsha_ro</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aexecute_command","title":"aexecute_command  <code>async</code>","text":"<pre><code>aexecute_command(\n    *args: typing.Any, **options: typing.Any\n) -&gt; typing.Any\n</code></pre> <p>Execute a command and return a parsed response</p> Source code in <code>kvdb/components/session.py</code> <pre><code>async def aexecute_command(self, *args: Any, **options: Any) -&gt; Any:\n    \"\"\"\n    Execute a command and return a parsed response\n    \"\"\"\n    return await self.aclient.execute_command(*args, **options)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aexists","title":"aexists  <code>async</code>","text":"<pre><code>aexists(\n    *names: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the number of <code>names</code> that exist</p> <p>For more information see https://redis.io/commands/exists</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aexpire","title":"aexpire  <code>async</code>","text":"<pre><code>aexpire(\n    name: kvdb.types.generic.KeyT,\n    time: kvdb.types.generic.ExpiryT,\n    nx: bool = False,\n    xx: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set an expire flag on key <code>name</code> for <code>time</code> seconds with given <code>option</code>. <code>time</code> can be represented by an integer or a Python timedelta object.</p> Valid options are <p>NX -&gt; Set expiry only when the key has no expiry XX -&gt; Set expiry only when the key has an existing expiry GT -&gt; Set expiry only when the new expiry is greater than current one LT -&gt; Set expiry only when the new expiry is less than current one</p> <p>For more information see https://redis.io/commands/expire</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aexpireat","title":"aexpireat  <code>async</code>","text":"<pre><code>aexpireat(\n    name: kvdb.types.generic.KeyT,\n    when: kvdb.types.generic.AbsExpiryT,\n    nx: bool = False,\n    xx: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set an expire flag on key <code>name</code> with given <code>option</code>. <code>when</code> can be represented as an integer indicating unix time or a Python datetime object.</p> Valid options are <p>-&gt; NX -- Set expiry only when the key has no expiry -&gt; XX -- Set expiry only when the key has an existing expiry -&gt; GT -- Set expiry only when the new expiry is greater than current one -&gt; LT -- Set expiry only when the new expiry is less than current one</p> <p>For more information see https://redis.io/commands/expireat</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aexpiretime","title":"aexpiretime  <code>async</code>","text":"<pre><code>aexpiretime(key: str) -&gt; int\n</code></pre> <p>Returns the absolute Unix timestamp (since January 1, 1970) in seconds at which the given key will expire.</p> <p>For more information see https://redis.io/commands/expiretime</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.afailover","title":"afailover  <code>async</code>","text":"<pre><code>afailover() -&gt; None\n</code></pre> <p>This function throws a NotImplementedError since it is intentionally not supported.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.afcall","title":"afcall  <code>async</code>","text":"<pre><code>afcall(\n    function,\n    numkeys: int,\n    *keys_and_args: typing.Optional[typing.List]\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Invoke a function.</p> <p>For more information see https://redis.io/commands/fcall</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.afcall_ro","title":"afcall_ro  <code>async</code>","text":"<pre><code>afcall_ro(\n    function,\n    numkeys: int,\n    *keys_and_args: typing.Optional[typing.List]\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>This is a read-only variant of the FCALL command that cannot execute commands that modify data.</p> <p>For more information see https://redis.io/commands/fcal_ro</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aflushall","title":"aflushall  <code>async</code>","text":"<pre><code>aflushall(\n    asynchronous: bool = False, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Delete all keys in all databases on the current host.</p> <p><code>asynchronous</code> indicates whether the operation is executed asynchronously by the server.</p> <p>For more information see https://redis.io/commands/flushall</p> Source code in <code>kvdb/components/session.py</code> <pre><code>\"\"\"\nClass Wrap Methods\n\"\"\"\n\ndef _client_function(self, *args, _function: Optional[str] = None, **kwargs) -&gt; ResponseT:\n    \"\"\"\n    [Sync] Wraps the client function\n    \"\"\"\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aflushdb","title":"aflushdb  <code>async</code>","text":"<pre><code>aflushdb(\n    asynchronous: bool = False, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Delete all keys in the current database.</p> <p><code>asynchronous</code> indicates whether the operation is executed asynchronously by the server.</p> <p>For more information see https://redis.io/commands/flushdb</p> Source code in <code>kvdb/components/session.py</code> <pre><code>    return getattr(self.client, _function)(*args, **kwargs)\n\ndef _aclient_function(self, *args, _function: Optional[str] = None, **kwargs) -&gt; Awaitable[ResponseT]:\n    \"\"\"\n    [Async] Wraps the client function\n    \"\"\"\n    return getattr(self.aclient, _function)(*args, **kwargs)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.afunction_delete","title":"afunction_delete  <code>async</code>","text":"<pre><code>afunction_delete(\n    library: str,\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Delete the library called <code>library</code> and all its functions.</p> <p>For more information see https://redis.io/commands/function-delete</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.afunction_dump","title":"afunction_dump  <code>async</code>","text":"<pre><code>afunction_dump() -&gt; (\n    typing.Union[typing.Awaitable[str], str]\n)\n</code></pre> <p>Return the serialized payload of loaded libraries.</p> <p>For more information see https://redis.io/commands/function-dump</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.afunction_flush","title":"afunction_flush  <code>async</code>","text":"<pre><code>afunction_flush(\n    mode: str = \"SYNC\",\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Deletes all the libraries.</p> <p>For more information see https://redis.io/commands/function-flush</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.afunction_kill","title":"afunction_kill  <code>async</code>","text":"<pre><code>afunction_kill() -&gt; (\n    typing.Union[typing.Awaitable[str], str]\n)\n</code></pre> <p>Kill a function that is currently executing.</p> <p>For more information see https://redis.io/commands/function-kill</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.afunction_list","title":"afunction_list  <code>async</code>","text":"<pre><code>afunction_list(\n    library: typing.Optional[str] = \"*\",\n    withcode: typing.Optional[bool] = False,\n) -&gt; typing.Union[\n    typing.Awaitable[typing.List], typing.List\n]\n</code></pre> <p>Return information about the functions and libraries. :param library: pecify a pattern for matching library names :param withcode: cause the server to include the libraries source  implementation in the reply</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.afunction_load","title":"afunction_load  <code>async</code>","text":"<pre><code>afunction_load(\n    code: str, replace: typing.Optional[bool] = False\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Load a library to Redis. :param code: the source code (must start with Shebang statement that provides a metadata about the library) :param replace: changes the behavior to overwrite the existing library with the new contents. Return the library name that was loaded.</p> <p>For more information see https://redis.io/commands/function-load</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.afunction_restore","title":"afunction_restore  <code>async</code>","text":"<pre><code>afunction_restore(\n    payload: str, policy: typing.Optional[str] = \"APPEND\"\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Restore libraries from the serialized <code>payload</code>. You can use the optional policy argument to provide a policy for handling existing libraries.</p> <p>For more information see https://redis.io/commands/function-restore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.afunction_stats","title":"afunction_stats  <code>async</code>","text":"<pre><code>afunction_stats() -&gt; (\n    typing.Union[typing.Awaitable[typing.List], typing.List]\n)\n</code></pre> <p>Return information about the function that's currently running and information about the available execution engines.</p> <p>For more information see https://redis.io/commands/function-stats</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ageoadd","title":"ageoadd  <code>async</code>","text":"<pre><code>ageoadd(\n    name: kvdb.types.generic.KeyT,\n    values: typing.Sequence[redis.typing.EncodableT],\n    nx: bool = False,\n    xx: bool = False,\n    ch: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Add the specified geospatial items to the specified key identified by the <code>name</code> argument. The Geospatial items are given as ordered members of the <code>values</code> argument, each item or place is formed by the triad longitude, latitude and name.</p> <p>Note: You can use ZREM to remove elements.</p> <p><code>nx</code> forces ZADD to only create new elements and not to update scores for elements that already exist.</p> <p><code>xx</code> forces ZADD to only update scores of elements that already exist. New elements will not be added.</p> <p><code>ch</code> modifies the return value to be the numbers of elements changed. Changed elements include new elements that were added and elements whose scores changed.</p> <p>For more information see https://redis.io/commands/geoadd</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ageodist","title":"ageodist  <code>async</code>","text":"<pre><code>ageodist(\n    name: kvdb.types.generic.KeyT,\n    place1: redis.typing.FieldT,\n    place2: redis.typing.FieldT,\n    unit: typing.Union[str, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the distance between <code>place1</code> and <code>place2</code> members of the <code>name</code> key. The units must be one of the following : m, km mi, ft. By default meters are used.</p> <p>For more information see https://redis.io/commands/geodist</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ageohash","title":"ageohash  <code>async</code>","text":"<pre><code>ageohash(\n    name: kvdb.types.generic.KeyT,\n    *values: redis.typing.FieldT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the geo hash string for each item of <code>values</code> members of the specified key identified by the <code>name</code> argument.</p> <p>For more information see https://redis.io/commands/geohash</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ageopos","title":"ageopos  <code>async</code>","text":"<pre><code>ageopos(\n    name: kvdb.types.generic.KeyT,\n    *values: redis.typing.FieldT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the positions of each item of <code>values</code> as members of the specified key identified by the <code>name</code> argument. Each position is represented by the pairs lon and lat.</p> <p>For more information see https://redis.io/commands/geopos</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ageoradius","title":"ageoradius  <code>async</code>","text":"<pre><code>ageoradius(\n    name: kvdb.types.generic.KeyT,\n    longitude: float,\n    latitude: float,\n    radius: float,\n    unit: typing.Union[str, None] = None,\n    withdist: bool = False,\n    withcoord: bool = False,\n    withhash: bool = False,\n    count: typing.Union[int, None] = None,\n    sort: typing.Union[str, None] = None,\n    store: typing.Union[\n        kvdb.types.generic.KeyT, None\n    ] = None,\n    store_dist: typing.Union[\n        kvdb.types.generic.KeyT, None\n    ] = None,\n    any: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the members of the specified key identified by the <code>name</code> argument which are within the borders of the area specified with the <code>latitude</code> and <code>longitude</code> location and the maximum distance from the center specified by the <code>radius</code> value.</p> <p>The units must be one of the following : m, km mi, ft. By default</p> <p><code>withdist</code> indicates to return the distances of each place.</p> <p><code>withcoord</code> indicates to return the latitude and longitude of each place.</p> <p><code>withhash</code> indicates to return the geohash string of each place.</p> <p><code>count</code> indicates to return the number of elements up to N.</p> <p><code>sort</code> indicates to return the places in a sorted way, ASC for nearest to fairest and DESC for fairest to nearest.</p> <p><code>store</code> indicates to save the places names in a sorted set named with a specific key, each element of the destination sorted set is populated with the score got from the original geo sorted set.</p> <p><code>store_dist</code> indicates to save the places names in a sorted set named with a specific key, instead of <code>store</code> the sorted set destination score is set with the distance.</p> <p>For more information see https://redis.io/commands/georadius</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ageoradiusbymember","title":"ageoradiusbymember  <code>async</code>","text":"<pre><code>ageoradiusbymember(\n    name: kvdb.types.generic.KeyT,\n    member: redis.typing.FieldT,\n    radius: float,\n    unit: typing.Union[str, None] = None,\n    withdist: bool = False,\n    withcoord: bool = False,\n    withhash: bool = False,\n    count: typing.Union[int, None] = None,\n    sort: typing.Union[str, None] = None,\n    store: typing.Union[\n        kvdb.types.generic.KeyT, None\n    ] = None,\n    store_dist: typing.Union[\n        kvdb.types.generic.KeyT, None\n    ] = None,\n    any: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>This command is exactly like <code>georadius</code> with the sole difference that instead of taking, as the center of the area to query, a longitude and latitude value, it takes the name of a member already existing inside the geospatial index represented by the sorted set.</p> <p>For more information see https://redis.io/commands/georadiusbymember</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ageosearch","title":"ageosearch  <code>async</code>","text":"<pre><code>ageosearch(\n    name: kvdb.types.generic.KeyT,\n    member: typing.Union[redis.typing.FieldT, None] = None,\n    longitude: typing.Union[float, None] = None,\n    latitude: typing.Union[float, None] = None,\n    unit: str = \"m\",\n    radius: typing.Union[float, None] = None,\n    width: typing.Union[float, None] = None,\n    height: typing.Union[float, None] = None,\n    sort: typing.Union[str, None] = None,\n    count: typing.Union[int, None] = None,\n    any: bool = False,\n    withcoord: bool = False,\n    withdist: bool = False,\n    withhash: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the members of specified key identified by the <code>name</code> argument, which are within the borders of the area specified by a given shape. This command extends the GEORADIUS command, so in addition to searching within circular areas, it supports searching within rectangular areas.</p> <p>This command should be used in place of the deprecated GEORADIUS and GEORADIUSBYMEMBER commands.</p> <p><code>member</code> Use the position of the given existing  member in the sorted set. Can't be given with <code>longitude</code>  and <code>latitude</code>.</p> <p><code>longitude</code> and <code>latitude</code> Use the position given by this coordinates. Can't be given with <code>member</code> <code>radius</code> Similar to GEORADIUS, search inside circular area according the given radius. Can't be given with <code>height</code> and <code>width</code>. <code>height</code> and <code>width</code> Search inside an axis-aligned rectangle, determined by the given height and width. Can't be given with <code>radius</code></p> <p><code>unit</code> must be one of the following : m, km, mi, ft. <code>m</code> for meters (the default value), <code>km</code> for kilometers, <code>mi</code> for miles and <code>ft</code> for feet.</p> <p><code>sort</code> indicates to return the places in a sorted way, ASC for nearest to furthest and DESC for furthest to nearest.</p> <p><code>count</code> limit the results to the first count matching items.</p> <p><code>any</code> is set to True, the command will return as soon as enough matches are found. Can't be provided without <code>count</code></p> <p><code>withdist</code> indicates to return the distances of each place. <code>withcoord</code> indicates to return the latitude and longitude of each place.</p> <p><code>withhash</code> indicates to return the geohash string of each place.</p> <p>For more information see https://redis.io/commands/geosearch</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ageosearchstore","title":"ageosearchstore  <code>async</code>","text":"<pre><code>ageosearchstore(\n    dest: kvdb.types.generic.KeyT,\n    name: kvdb.types.generic.KeyT,\n    member: typing.Union[redis.typing.FieldT, None] = None,\n    longitude: typing.Union[float, None] = None,\n    latitude: typing.Union[float, None] = None,\n    unit: str = \"m\",\n    radius: typing.Union[float, None] = None,\n    width: typing.Union[float, None] = None,\n    height: typing.Union[float, None] = None,\n    sort: typing.Union[str, None] = None,\n    count: typing.Union[int, None] = None,\n    any: bool = False,\n    storedist: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>This command is like GEOSEARCH, but stores the result in <code>dest</code>. By default, it stores the results in the destination sorted set with their geospatial information. if <code>store_dist</code> set to True, the command will stores the items in a sorted set populated with their distance from the center of the circle or box, as a floating-point number.</p> <p>For more information see https://redis.io/commands/geosearchstore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aget","title":"aget  <code>async</code>","text":"<pre><code>aget(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the value at key <code>name</code>, or None if the key doesn't exist</p> <p>For more information see https://redis.io/commands/get</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.agetbit","title":"agetbit  <code>async</code>","text":"<pre><code>agetbit(\n    name: kvdb.types.generic.KeyT, offset: int\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns an integer indicating the value of <code>offset</code> in <code>name</code></p> <p>For more information see https://redis.io/commands/getbit</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.agetdel","title":"agetdel  <code>async</code>","text":"<pre><code>agetdel(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Get the value at key <code>name</code> and delete the key. This command is similar to GET, except for the fact that it also deletes the key on success (if and only if the key's value type is a string).</p> <p>For more information see https://redis.io/commands/getdel</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.agetex","title":"agetex  <code>async</code>","text":"<pre><code>agetex(\n    name: kvdb.types.generic.KeyT,\n    ex: typing.Union[\n        kvdb.types.generic.ExpiryT, None\n    ] = None,\n    px: typing.Union[\n        kvdb.types.generic.ExpiryT, None\n    ] = None,\n    exat: typing.Union[\n        kvdb.types.generic.AbsExpiryT, None\n    ] = None,\n    pxat: typing.Union[\n        kvdb.types.generic.AbsExpiryT, None\n    ] = None,\n    persist: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Get the value of key and optionally set its expiration. GETEX is similar to GET, but is a write command with additional options. All time parameters can be given as datetime.timedelta or integers.</p> <p><code>ex</code> sets an expire flag on key <code>name</code> for <code>ex</code> seconds.</p> <p><code>px</code> sets an expire flag on key <code>name</code> for <code>px</code> milliseconds.</p> <p><code>exat</code> sets an expire flag on key <code>name</code> for <code>ex</code> seconds, specified in unix time.</p> <p><code>pxat</code> sets an expire flag on key <code>name</code> for <code>ex</code> milliseconds, specified in unix time.</p> <p><code>persist</code> remove the time to live associated with <code>name</code>.</p> <p>For more information see https://redis.io/commands/getex</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.agetitem","title":"agetitem  <code>async</code>","text":"<pre><code>agetitem(\n    key: kvdb.types.generic.KeyT,\n    default: typing.Optional[typing.Any] = None,\n) -&gt; kvdb.components.session.ReturnT\n</code></pre> <p>[Dict] Returns the value for the given key</p> Source code in <code>kvdb/components/session.py</code> <pre><code>async def agetitem(\n    self,\n    key: KeyT,\n    default: Optional[Any] = None,\n) -&gt; ResponseT:\n    \"\"\"\n    [Dict] Returns the value for the given key\n    \"\"\"\n    return await self.persistence.aget(key, default)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.agetrange","title":"agetrange  <code>async</code>","text":"<pre><code>agetrange(\n    key: kvdb.types.generic.KeyT, start: int, end: int\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the substring of the string value stored at <code>key</code>, determined by the offsets <code>start</code> and <code>end</code> (both are inclusive)</p> <p>For more information see https://redis.io/commands/getrange</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.agetset","title":"agetset  <code>async</code>","text":"<pre><code>agetset(\n    name: kvdb.types.generic.KeyT,\n    value: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Sets the value at key <code>name</code> to <code>value</code> and returns the old value at key <code>name</code> atomically.</p> <p>As per Redis 6.2, GETSET is considered deprecated. Please use SET with GET parameter in new code.</p> <p>For more information see https://redis.io/commands/getset</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahdel","title":"ahdel  <code>async</code>","text":"<pre><code>ahdel(\n    name: str, *keys: typing.List\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Delete <code>keys</code> from hash <code>name</code></p> <p>For more information see https://redis.io/commands/hdel</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahello","title":"ahello  <code>async</code>","text":"<pre><code>ahello() -&gt; None\n</code></pre> <p>This function throws a NotImplementedError since it is intentionally not supported.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahexists","title":"ahexists  <code>async</code>","text":"<pre><code>ahexists(\n    name: str, key: str\n) -&gt; typing.Union[typing.Awaitable[bool], bool]\n</code></pre> <p>Returns a boolean indicating if <code>key</code> exists within hash <code>name</code></p> <p>For more information see https://redis.io/commands/hexists</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahget","title":"ahget  <code>async</code>","text":"<pre><code>ahget(name: str, key: str) -&gt; typing.Union[\n    typing.Awaitable[typing.Optional[str]],\n    typing.Optional[str],\n]\n</code></pre> <p>Return the value of <code>key</code> within the hash <code>name</code></p> <p>For more information see https://redis.io/commands/hget</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahgetall","title":"ahgetall  <code>async</code>","text":"<pre><code>ahgetall(\n    name: str,\n) -&gt; typing.Union[typing.Awaitable[dict], dict]\n</code></pre> <p>Return a Python dict of the hash's name/value pairs</p> <p>For more information see https://redis.io/commands/hgetall</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahincrby","title":"ahincrby  <code>async</code>","text":"<pre><code>ahincrby(\n    name: str, key: str, amount: int = 1\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Increment the value of <code>key</code> in hash <code>name</code> by <code>amount</code></p> <p>For more information see https://redis.io/commands/hincrby</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahincrbyfloat","title":"ahincrbyfloat  <code>async</code>","text":"<pre><code>ahincrbyfloat(\n    name: str, key: str, amount: float = 1.0\n) -&gt; typing.Union[typing.Awaitable[float], float]\n</code></pre> <p>Increment the value of <code>key</code> in hash <code>name</code> by floating <code>amount</code></p> <p>For more information see https://redis.io/commands/hincrbyfloat</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahkeys","title":"ahkeys  <code>async</code>","text":"<pre><code>ahkeys(\n    name: str,\n) -&gt; typing.Union[\n    typing.Awaitable[typing.List], typing.List\n]\n</code></pre> <p>Return the list of keys within hash <code>name</code></p> <p>For more information see https://redis.io/commands/hkeys</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahlen","title":"ahlen  <code>async</code>","text":"<pre><code>ahlen(\n    name: str,\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Return the number of elements in hash <code>name</code></p> <p>For more information see https://redis.io/commands/hlen</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahmget","title":"ahmget  <code>async</code>","text":"<pre><code>ahmget(\n    name: str, keys: typing.List, *args: typing.List\n) -&gt; typing.Union[\n    typing.Awaitable[typing.List], typing.List\n]\n</code></pre> <p>Returns a list of values ordered identically to <code>keys</code></p> <p>For more information see https://redis.io/commands/hmget</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahmset","title":"ahmset  <code>async</code>","text":"<pre><code>ahmset(\n    name: str, mapping: dict\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Set key to value within hash <code>name</code> for each corresponding key and value from the <code>mapping</code> dict.</p> <p>For more information see https://redis.io/commands/hmset</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahrandfield","title":"ahrandfield  <code>async</code>","text":"<pre><code>ahrandfield(\n    key: str, count: int = None, withvalues: bool = False\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a random field from the hash value stored at key.</p> <p>count: if the argument is positive, return an array of distinct fields. If called with a negative count, the behavior changes and the command is allowed to return the same field multiple times. In this case, the number of returned fields is the absolute value of the specified count. withvalues: The optional WITHVALUES modifier changes the reply so it includes the respective values of the randomly selected hash fields.</p> <p>For more information see https://redis.io/commands/hrandfield</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahscan","title":"ahscan  <code>async</code>","text":"<pre><code>ahscan(\n    name: kvdb.types.generic.KeyT,\n    cursor: int = 0,\n    match: typing.Union[\n        kvdb.types.generic.PatternT, None\n    ] = None,\n    count: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Incrementally return key/value slices in a hash. Also return a cursor indicating the scan position.</p> <p><code>match</code> allows for filtering the keys by pattern</p> <p><code>count</code> allows for hint the minimum number of returns</p> <p>For more information see https://redis.io/commands/hscan</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahscan_iter","title":"ahscan_iter  <code>async</code>","text":"<pre><code>ahscan_iter(\n    name: str,\n    match: typing.Union[\n        kvdb.types.generic.PatternT, None\n    ] = None,\n    count: typing.Union[int, None] = None,\n) -&gt; typing.AsyncIterator\n</code></pre> <p>Make an iterator using the HSCAN command so that the client doesn't need to remember the cursor position.</p> <p><code>match</code> allows for filtering the keys by pattern</p> <p><code>count</code> allows for hint the minimum number of returns</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahset","title":"ahset  <code>async</code>","text":"<pre><code>ahset(\n    name: str,\n    key: typing.Optional[str] = None,\n    value: typing.Optional[str] = None,\n    mapping: typing.Optional[dict] = None,\n    items: typing.Optional[list] = None,\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Set <code>key</code> to <code>value</code> within hash <code>name</code>, <code>mapping</code> accepts a dict of key/value pairs that will be added to hash <code>name</code>. <code>items</code> accepts a list of key/value pairs that will be added to hash <code>name</code>. Returns the number of fields that were added.</p> <p>For more information see https://redis.io/commands/hset</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahsetnx","title":"ahsetnx  <code>async</code>","text":"<pre><code>ahsetnx(\n    name: str, key: str, value: str\n) -&gt; typing.Union[typing.Awaitable[bool], bool]\n</code></pre> <p>Set <code>key</code> to <code>value</code> within hash <code>name</code> if <code>key</code> does not exist.  Returns 1 if HSETNX created a field, otherwise 0.</p> <p>For more information see https://redis.io/commands/hsetnx</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahstrlen","title":"ahstrlen  <code>async</code>","text":"<pre><code>ahstrlen(\n    name: str, key: str\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Return the number of bytes stored in the value of <code>key</code> within hash <code>name</code></p> <p>For more information see https://redis.io/commands/hstrlen</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ahvals","title":"ahvals  <code>async</code>","text":"<pre><code>ahvals(\n    name: str,\n) -&gt; typing.Union[\n    typing.Awaitable[typing.List], typing.List\n]\n</code></pre> <p>Return the list of values within hash <code>name</code></p> <p>For more information see https://redis.io/commands/hvals</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aincrby","title":"aincrby  <code>async</code>","text":"<pre><code>aincrby(\n    name: kvdb.types.generic.KeyT, amount: int = 1\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Increments the value of <code>key</code> by <code>amount</code>.  If no key exists, the value will be initialized as <code>amount</code></p> <p>For more information see https://redis.io/commands/incrby</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aincrbyfloat","title":"aincrbyfloat  <code>async</code>","text":"<pre><code>aincrbyfloat(\n    name: kvdb.types.generic.KeyT, amount: float = 1.0\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Increments the value at key <code>name</code> by floating <code>amount</code>. If no key exists, the value will be initialized as <code>amount</code></p> <p>For more information see https://redis.io/commands/incrbyfloat</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ainfo","title":"ainfo  <code>async</code>","text":"<pre><code>ainfo(\n    section: typing.Union[str, None] = None,\n    *args: typing.List[str],\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a dictionary containing information about the Redis server</p> <p>The <code>section</code> option can be used to select a specific section of information</p> <p>The section option is not supported by older versions of Redis Server, and will generate ResponseError</p> <p>For more information see https://redis.io/commands/info</p> Source code in <code>kvdb/components/session.py</code> <pre><code>    # RedisModuleCommands,\n    SentinelCommands,\n}:\n\n    for name in dir(sync_module):\n        if name.startswith('_'): continue\n        if name in existing_methods: continue\n        # if name in skip_methods: continue\n        existing_func = getattr(sync_module, name)\n        existing_sig = inspect.signature(existing_func)\n        new_func = create_function(\n            existing_sig,\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.akeys","title":"akeys  <code>async</code>","text":"<pre><code>akeys(\n    pattern: kvdb.types.generic.PatternT = \"*\", **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a list of keys matching <code>pattern</code></p> <p>For more information see https://redis.io/commands/keys</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alastsave","title":"alastsave  <code>async</code>","text":"<pre><code>alastsave(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a Python datetime object representing the last time the Redis database was saved to disk</p> <p>For more information see https://redis.io/commands/lastsave</p> Source code in <code>kvdb/components/session.py</code> <pre><code>    functools.partial(cls._client_function, _function = name),\n    func_name = name,\n    module_name = cls.__module__,\n)\nsetattr(cls, name, new_func)\nexisting_methods.add(name)\nadded_methods.add(name)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alatency_doctor","title":"alatency_doctor  <code>async</code>","text":"<pre><code>alatency_doctor() -&gt; None\n</code></pre> <p>Raise a NotImplementedError, as the client will not support LATENCY DOCTOR. This funcion is best used within the redis-cli.</p> <p>For more information see https://redis.io/commands/latency-doctor</p> Source code in <code>kvdb/components/session.py</code> <pre><code># Async Methods\nfor amodule in {\n    AsyncCoreCommands,\n    # AsyncRedisModuleCommands,\n    AsyncSentinelCommands,\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alatency_graph","title":"alatency_graph  <code>async</code>","text":"<pre><code>alatency_graph() -&gt; None\n</code></pre> <p>Raise a NotImplementedError, as the client will not support LATENCY GRAPH. This funcion is best used within the redis-cli.</p> <p>For more information see https://redis.io/commands/latency-graph.</p> Source code in <code>kvdb/components/session.py</code> <pre><code>}:\n    # Core Commands\n    for name in dir(amodule):\n        if name.startswith('_'): continue\n        aname = f'a{name}'\n        # if aname == 'async': aname = 'asyncronize'\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alatency_histogram","title":"alatency_histogram  <code>async</code>","text":"<pre><code>alatency_histogram(*args) -&gt; None\n</code></pre> <p>This function throws a NotImplementedError since it is intentionally not supported.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alatency_history","title":"alatency_history  <code>async</code>","text":"<pre><code>alatency_history(\n    event: str,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the raw data of the <code>event</code>'s latency spikes time series.</p> <p>For more information see https://redis.io/commands/latency-history</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alatency_latest","title":"alatency_latest  <code>async</code>","text":"<pre><code>alatency_latest() -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Reports the latest latency events logged.</p> <p>For more information see https://redis.io/commands/latency-latest</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alatency_reset","title":"alatency_reset  <code>async</code>","text":"<pre><code>alatency_reset(\n    *events: str,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Resets the latency spikes time series of all, or only some, events.</p> <p>For more information see https://redis.io/commands/latency-reset</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alcs","title":"alcs  <code>async</code>","text":"<pre><code>alcs(\n    key1: str,\n    key2: str,\n    len: typing.Optional[bool] = False,\n    idx: typing.Optional[bool] = False,\n    minmatchlen: typing.Optional[int] = 0,\n    withmatchlen: typing.Optional[bool] = False,\n) -&gt; typing.Union[str, int, list]\n</code></pre> <p>Find the longest common subsequence between <code>key1</code> and <code>key2</code>. If <code>len</code> is true the length of the match will will be returned. If <code>idx</code> is true the match position in each strings will be returned. <code>minmatchlen</code> restrict the list of matches to the ones of the given <code>minmatchlen</code>. If <code>withmatchlen</code> the length of the match also will be returned. For more information see https://redis.io/commands/lcs</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alindex","title":"alindex  <code>async</code>","text":"<pre><code>alindex(name: str, index: int) -&gt; typing.Union[\n    typing.Awaitable[typing.Optional[str]],\n    typing.Optional[str],\n]\n</code></pre> <p>Return the item from list <code>name</code> at position <code>index</code></p> <p>Negative indexes are supported and will return an item at the end of the list</p> <p>For more information see https://redis.io/commands/lindex</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alinsert","title":"alinsert  <code>async</code>","text":"<pre><code>alinsert(\n    name: str, where: str, refvalue: str, value: str\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Insert <code>value</code> in list <code>name</code> either immediately before or after [<code>where</code>] <code>refvalue</code></p> <p>Returns the new length of the list on success or -1 if <code>refvalue</code> is not in the list.</p> <p>For more information see https://redis.io/commands/linsert</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.allen","title":"allen  <code>async</code>","text":"<pre><code>allen(\n    name: str,\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Return the length of the list <code>name</code></p> <p>For more information see https://redis.io/commands/llen</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.almove","title":"almove  <code>async</code>","text":"<pre><code>almove(\n    first_list: str,\n    second_list: str,\n    src: str = \"LEFT\",\n    dest: str = \"RIGHT\",\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Atomically returns and removes the first/last element of a list, pushing it as the first/last element on the destination list. Returns the element being popped and pushed.</p> <p>For more information see https://redis.io/commands/lmove</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.almpop","title":"almpop  <code>async</code>","text":"<pre><code>almpop(\n    num_keys: int,\n    *args: typing.List[str],\n    direction: str,\n    count: typing.Optional[int] = 1\n) -&gt; typing.Union[typing.Awaitable[list], list]\n</code></pre> <p>Pop <code>count</code> values (default 1) first non-empty list key from the list of args provided key names.</p> <p>For more information see https://redis.io/commands/lmpop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alock","title":"alock","text":"<pre><code>alock(\n    name: str,\n    timeout: typing.Optional[\n        kvdb.types.generic.Number\n    ] = None,\n    sleep: kvdb.types.generic.Number = 0.1,\n    blocking: bool = True,\n    blocking_timeout: typing.Optional[\n        kvdb.types.generic.Number\n    ] = None,\n    thread_local: bool = True,\n    force_unlock: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; kvdb.components.lock.AsyncLock\n</code></pre> <p>Create a new Lock instance named <code>name</code> using the Redis client supplied by <code>keydb</code>.</p> <p><code>timeout</code> indicates a maximum life for the lock in seconds. By default, it will remain locked until release() is called. <code>timeout</code> can be specified as a float or integer, both representing the number of seconds to wait.</p> <p><code>sleep</code> indicates the amount of time to sleep in seconds per loop iteration when the lock is in blocking mode and another client is currently holding the lock.</p> <p><code>blocking</code> indicates whether calling <code>acquire</code> should block until the lock has been acquired or to fail immediately, causing <code>acquire</code> to return False and the lock not being acquired. Defaults to True. Note this value can be overridden by passing a <code>blocking</code> argument to <code>acquire</code>.</p> <p><code>blocking_timeout</code> indicates the maximum amount of time in seconds to spend trying to acquire the lock. A value of <code>None</code> indicates continue trying forever. <code>blocking_timeout</code> can be specified as a float or integer, both representing the number of seconds to wait.</p> <p><code>thread_local</code> indicates whether the lock token is placed in thread-local storage. By default, the token is placed in thread local storage so that a thread only sees its token, not a token set by another thread.</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def alock(\n    self, \n    name: str, \n    timeout: Optional[Number] = None,\n    sleep: Number = 0.1,\n    blocking: bool = True,\n    blocking_timeout: Optional[Number] = None,\n    thread_local: bool = True,\n    force_unlock: Optional[bool] = None,\n    **kwargs,\n) -&gt; AsyncLock:\n    \"\"\"\n    Create a new Lock instance named ``name`` using the Redis client\n    supplied by ``keydb``.\n\n    ``timeout`` indicates a maximum life for the lock in seconds.\n    By default, it will remain locked until release() is called.\n    ``timeout`` can be specified as a float or integer, both representing\n    the number of seconds to wait.\n\n    ``sleep`` indicates the amount of time to sleep in seconds per loop\n    iteration when the lock is in blocking mode and another client is\n    currently holding the lock.\n\n    ``blocking`` indicates whether calling ``acquire`` should block until\n    the lock has been acquired or to fail immediately, causing ``acquire``\n    to return False and the lock not being acquired. Defaults to True.\n    Note this value can be overridden by passing a ``blocking``\n    argument to ``acquire``.\n\n    ``blocking_timeout`` indicates the maximum amount of time in seconds to\n    spend trying to acquire the lock. A value of ``None`` indicates\n    continue trying forever. ``blocking_timeout`` can be specified as a\n    float or integer, both representing the number of seconds to wait.\n\n    ``thread_local`` indicates whether the lock token is placed in\n    thread-local storage. By default, the token is placed in thread local\n    storage so that a thread only sees its token, not a token set by\n    another thread. \n    \"\"\"\n    if name not in self.state.alocks:\n        self.state.alocks[name] = AsyncLock(\n            self.aclient, \n            name = name, \n            timeout = timeout, \n            sleep = sleep, \n            blocking = blocking, \n            blocking_timeout = blocking_timeout, \n            thread_local = thread_local,\n            force_unlock = force_unlock,\n        )\n    if self.state.alock is None: self.state.alock = self.state.alocks[name]\n    return self.state.alocks[name]\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alolwut","title":"alolwut  <code>async</code>","text":"<pre><code>alolwut(\n    *version_numbers: typing.Union[str, float], **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Get the Redis version and a piece of generative computer art</p> <p>See: https://redis.io/commands/lolwut</p> Source code in <code>kvdb/components/session.py</code> <pre><code>if aname in {\n    'async', 'await'\n}:\n    aname = f'{aname}_'\nif aname in existing_methods: continue\n# if name in skip_methods: continue\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alpop","title":"alpop  <code>async</code>","text":"<pre><code>alpop(\n    name: str, count: typing.Optional[int] = None\n) -&gt; typing.Union[\n    typing.Awaitable[typing.Union[str, typing.List, None]],\n    typing.Union[str, typing.List, None],\n]\n</code></pre> <p>Removes and returns the first elements of the list <code>name</code>.</p> <p>By default, the command pops a single element from the beginning of the list. When provided with the optional <code>count</code> argument, the reply will consist of up to count elements, depending on the list's length.</p> <p>For more information see https://redis.io/commands/lpop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alpos","title":"alpos  <code>async</code>","text":"<pre><code>alpos(\n    name: str,\n    value: str,\n    rank: typing.Optional[int] = None,\n    count: typing.Optional[int] = None,\n    maxlen: typing.Optional[int] = None,\n) -&gt; typing.Union[str, typing.List, None]\n</code></pre> <p>Get position of <code>value</code> within the list <code>name</code></p> <p>If specified, <code>rank</code> indicates the \"rank\" of the first element to  return in case there are multiple copies of <code>value</code> in the list.  By default, LPOS returns the position of the first occurrence of  <code>value</code> in the list. When <code>rank</code> 2, LPOS returns the position of  the second <code>value</code> in the list. If <code>rank</code> is negative, LPOS  searches the list in reverse. For example, -1 would return the  position of the last occurrence of <code>value</code> and -2 would return the  position of the next to last occurrence of <code>value</code>.</p> <p>If specified, <code>count</code> indicates that LPOS should return a list of  up to <code>count</code> positions. A <code>count</code> of 2 would return a list of  up to 2 positions. A <code>count</code> of 0 returns a list of all positions  matching <code>value</code>. When <code>count</code> is specified and but <code>value</code>  does not exist in the list, an empty list is returned.</p> <p>If specified, <code>maxlen</code> indicates the maximum number of list  elements to scan. A <code>maxlen</code> of 1000 will only return the  position(s) of items within the first 1000 entries in the list.  A <code>maxlen</code> of 0 (the default) will scan the entire list.</p> <p>For more information see https://redis.io/commands/lpos</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alpush","title":"alpush  <code>async</code>","text":"<pre><code>alpush(\n    name: str, *values: redis.typing.FieldT\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Push <code>values</code> onto the head of the list <code>name</code></p> <p>For more information see https://redis.io/commands/lpush</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alpushx","title":"alpushx  <code>async</code>","text":"<pre><code>alpushx(\n    name: str, *values: redis.typing.FieldT\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Push <code>value</code> onto the head of the list <code>name</code> if <code>name</code> exists</p> <p>For more information see https://redis.io/commands/lpushx</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alrange","title":"alrange  <code>async</code>","text":"<pre><code>alrange(\n    name: str, start: int, end: int\n) -&gt; typing.Union[typing.Awaitable[list], list]\n</code></pre> <p>Return a slice of the list <code>name</code> between position <code>start</code> and <code>end</code></p> <p><code>start</code> and <code>end</code> can be negative numbers just like Python slicing notation</p> <p>For more information see https://redis.io/commands/lrange</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alrem","title":"alrem  <code>async</code>","text":"<pre><code>alrem(\n    name: str, count: int, value: str\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Remove the first <code>count</code> occurrences of elements equal to <code>value</code> from the list stored at <code>name</code>.</p> The count argument influences the operation in the following ways <p>count &gt; 0: Remove elements equal to value moving from head to tail. count &lt; 0: Remove elements equal to value moving from tail to head. count = 0: Remove all elements equal to value.</p> <p>For more information see https://redis.io/commands/lrem</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.alset","title":"alset  <code>async</code>","text":"<pre><code>alset(\n    name: str, index: int, value: str\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Set element at <code>index</code> of list <code>name</code> to <code>value</code></p> <p>For more information see https://redis.io/commands/lset</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.altrim","title":"altrim  <code>async</code>","text":"<pre><code>altrim(\n    name: str, start: int, end: int\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Trim the list <code>name</code>, removing all values not within the slice between <code>start</code> and <code>end</code></p> <p><code>start</code> and <code>end</code> can be negative numbers just like Python slicing notation</p> <p>For more information see https://redis.io/commands/ltrim</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.amemory_malloc_stats","title":"amemory_malloc_stats  <code>async</code>","text":"<pre><code>amemory_malloc_stats(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return an internal statistics report from the memory allocator.</p> <p>See: https://redis.io/commands/memory-malloc-stats</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.amemory_purge","title":"amemory_purge  <code>async</code>","text":"<pre><code>amemory_purge(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Attempts to purge dirty pages for reclamation by allocator</p> <p>For more information see https://redis.io/commands/memory-purge</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.amemory_stats","title":"amemory_stats  <code>async</code>","text":"<pre><code>amemory_stats(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a dictionary of memory stats</p> <p>For more information see https://redis.io/commands/memory-stats</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.amemory_usage","title":"amemory_usage  <code>async</code>","text":"<pre><code>amemory_usage(\n    key: kvdb.types.generic.KeyT,\n    samples: typing.Union[int, None] = None,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the total memory usage for key, its value and associated administrative overheads.</p> <p>For nested data structures, <code>samples</code> is the number of elements to sample. If left unspecified, the server's default is 5. Use 0 to sample all elements.</p> <p>For more information see https://redis.io/commands/memory-usage</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.amget","title":"amget  <code>async</code>","text":"<pre><code>amget(\n    keys: redis.typing.KeysT, *args: redis.typing.EncodableT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a list of values ordered identically to <code>keys</code></p> <p>For more information see https://redis.io/commands/mget</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.amigrate","title":"amigrate  <code>async</code>","text":"<pre><code>amigrate(\n    host: str,\n    port: int,\n    keys: redis.typing.KeysT,\n    destination_db: int,\n    timeout: int,\n    copy: bool = False,\n    replace: bool = False,\n    auth: typing.Union[str, None] = None,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Migrate 1 or more keys from the current Redis server to a different server specified by the <code>host</code>, <code>port</code> and <code>destination_db</code>.</p> <p>The <code>timeout</code>, specified in milliseconds, indicates the maximum time the connection between the two servers can be idle before the command is interrupted.</p> <p>If <code>copy</code> is True, the specified <code>keys</code> are NOT deleted from the source server.</p> <p>If <code>replace</code> is True, this operation will overwrite the keys on the destination server if they exist.</p> <p>If <code>auth</code> is specified, authenticate to the destination server with the password provided.</p> <p>For more information see https://redis.io/commands/migrate</p> Source code in <code>kvdb/components/session.py</code> <pre><code>                        functools.partial(cls._aclient_function, _function = name),\n                        func_name = aname,\n                        module_name = cls.__module__,\n                    )\n                    setattr(cls, aname, new_func)\n                    existing_methods.add(aname)\n                    added_methods.add(aname)\n                except Exception as e:\n                    print(f\"Error adding method: {name} -&gt; {aname}\")\n                    raise e\n\n        # print('Added Methods: ', added_methods)\n\n\nKVDBSession.initialize_class_functions()\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.amodule_list","title":"amodule_list  <code>async</code>","text":"<pre><code>amodule_list() -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a list of dictionaries containing the name and version of all loaded modules.</p> <p>For more information see https://redis.io/commands/module-list</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.amodule_load","title":"amodule_load  <code>async</code>","text":"<pre><code>amodule_load(\n    path, *args\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Loads the module from <code>path</code>. Passes all <code>*args</code> to the module, during loading. Raises <code>ModuleError</code> if a module is not found at <code>path</code>.</p> <p>For more information see https://redis.io/commands/module-load</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.amodule_loadex","title":"amodule_loadex  <code>async</code>","text":"<pre><code>amodule_loadex(\n    path: str,\n    options: typing.Optional[typing.List[str]] = None,\n    args: typing.Optional[typing.List[str]] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Loads a module from a dynamic library at runtime with configuration directives.</p> <p>For more information see https://redis.io/commands/module-loadex</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.amodule_unload","title":"amodule_unload  <code>async</code>","text":"<pre><code>amodule_unload(name) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Unloads the module <code>name</code>. Raises <code>ModuleError</code> if <code>name</code> is not in loaded modules.</p> <p>For more information see https://redis.io/commands/module-unload</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.amove","title":"amove  <code>async</code>","text":"<pre><code>amove(\n    name: kvdb.types.generic.KeyT, db: int\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Moves the key <code>name</code> to a different Redis database <code>db</code></p> <p>For more information see https://redis.io/commands/move</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.amset","title":"amset  <code>async</code>","text":"<pre><code>amset(\n    mapping: typing.Mapping[\n        redis.typing.AnyKeyT, redis.typing.EncodableT\n    ],\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Sets key/values based on a mapping. Mapping is a dictionary of key/value pairs. Both keys and values should be strings or types that can be cast to a string via str().</p> <p>For more information see https://redis.io/commands/mset</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.amsetnx","title":"amsetnx  <code>async</code>","text":"<pre><code>amsetnx(\n    mapping: typing.Mapping[\n        redis.typing.AnyKeyT, redis.typing.EncodableT\n    ],\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Sets key/values based on a mapping if none of the keys are already set. Mapping is a dictionary of key/value pairs. Both keys and values should be strings or types that can be cast to a string via str(). Returns a boolean indicating if the operation was successful.</p> <p>For more information see https://redis.io/commands/msetnx</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aobject","title":"aobject  <code>async</code>","text":"<pre><code>aobject(\n    infotype: str, key: kvdb.types.generic.KeyT, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the encoding, idletime, or refcount about the key</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aoverflow","title":"aoverflow  <code>async</code>","text":"<pre><code>aoverflow(overflow: str)\n</code></pre> <p>Update the overflow algorithm of successive INCRBY operations :param overflow: Overflow algorithm, one of WRAP, SAT, FAIL. See the     Redis docs for descriptions of these algorithmsself. :returns: a :py:class:<code>BitFieldOperation</code> instance.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apersist","title":"apersist  <code>async</code>","text":"<pre><code>apersist(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Removes an expiration on <code>name</code></p> <p>For more information see https://redis.io/commands/persist</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apexpire","title":"apexpire  <code>async</code>","text":"<pre><code>apexpire(\n    name: kvdb.types.generic.KeyT,\n    time: kvdb.types.generic.ExpiryT,\n    nx: bool = False,\n    xx: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set an expire flag on key <code>name</code> for <code>time</code> milliseconds with given <code>option</code>. <code>time</code> can be represented by an integer or a Python timedelta object.</p> Valid options are <p>NX -&gt; Set expiry only when the key has no expiry XX -&gt; Set expiry only when the key has an existing expiry GT -&gt; Set expiry only when the new expiry is greater than current one LT -&gt; Set expiry only when the new expiry is less than current one</p> <p>For more information see https://redis.io/commands/pexpire</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apexpireat","title":"apexpireat  <code>async</code>","text":"<pre><code>apexpireat(\n    name: kvdb.types.generic.KeyT,\n    when: kvdb.types.generic.AbsExpiryT,\n    nx: bool = False,\n    xx: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set an expire flag on key <code>name</code> with given <code>option</code>. <code>when</code> can be represented as an integer representing unix time in milliseconds (unix time * 1000) or a Python datetime object.</p> Valid options are <p>NX -&gt; Set expiry only when the key has no expiry XX -&gt; Set expiry only when the key has an existing expiry GT -&gt; Set expiry only when the new expiry is greater than current one LT -&gt; Set expiry only when the new expiry is less than current one</p> <p>For more information see https://redis.io/commands/pexpireat</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apexpiretime","title":"apexpiretime  <code>async</code>","text":"<pre><code>apexpiretime(key: str) -&gt; int\n</code></pre> <p>Returns the absolute Unix timestamp (since January 1, 1970) in milliseconds at which the given key will expire.</p> <p>For more information see https://redis.io/commands/pexpiretime</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apfadd","title":"apfadd  <code>async</code>","text":"<pre><code>apfadd(\n    name: kvdb.types.generic.KeyT,\n    *values: redis.typing.FieldT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Adds the specified elements to the specified HyperLogLog.</p> <p>For more information see https://redis.io/commands/pfadd</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apfcount","title":"apfcount  <code>async</code>","text":"<pre><code>apfcount(\n    *sources: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the approximated cardinality of the set observed by the HyperLogLog at key(s).</p> <p>For more information see https://redis.io/commands/pfcount</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apfmerge","title":"apfmerge  <code>async</code>","text":"<pre><code>apfmerge(\n    dest: kvdb.types.generic.KeyT,\n    *sources: kvdb.types.generic.KeyT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Merge N different HyperLogLogs into a single one.</p> <p>For more information see https://redis.io/commands/pfmerge</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aping","title":"aping  <code>async</code>","text":"<pre><code>aping(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Ping the Redis server</p> <p>For more information see https://redis.io/commands/ping</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apipeline","title":"apipeline","text":"<pre><code>apipeline(\n    transaction: typing.Optional[bool] = True,\n    shard_hint: typing.Optional[str] = None,\n    retryable: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; kvdb.components.pipeline.AsyncPipelineT\n</code></pre> <p>Return a new pipeline object that can queue multiple commands for later execution. <code>transaction</code> indicates whether all commands should be executed atomically. Apart from making a group of operations atomic, pipelines are useful for reducing the back-and-forth overhead between the client and server.</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def apipeline(\n    self, \n    transaction: Optional[bool] = True, \n    shard_hint: Optional[str] = None, \n    retryable: Optional[bool] = None,\n    **kwargs\n) -&gt; AsyncPipelineT:\n    \"\"\"\n    Return a new pipeline object that can queue multiple commands for\n    later execution. ``transaction`` indicates whether all commands\n    should be executed atomically. Apart from making a group of operations\n    atomic, pipelines are useful for reducing the back-and-forth overhead\n    between the client and server.\n    \"\"\"\n    if retryable is None: retryable = self.settings.retry.pipeline_enabled\n    return self.aclient.pipeline(transaction = transaction, shard_hint = shard_hint, retryable = retryable)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.append","title":"append","text":"<pre><code>append(\n    key: kvdb.types.generic.KeyT,\n    value: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Appends the string <code>value</code> to the value at <code>key</code>. If <code>key</code> doesn't already exist, create it with a value of <code>value</code>. Returns the new length of the value at <code>key</code>.</p> <p>For more information see https://redis.io/commands/append</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apsetex","title":"apsetex  <code>async</code>","text":"<pre><code>apsetex(\n    name: kvdb.types.generic.KeyT,\n    time_ms: kvdb.types.generic.ExpiryT,\n    value: redis.typing.EncodableT,\n)\n</code></pre> <p>Set the value of key <code>name</code> to <code>value</code> that expires in <code>time_ms</code> milliseconds. <code>time_ms</code> can be represented by an integer or a Python timedelta object</p> <p>For more information see https://redis.io/commands/psetex</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apsync","title":"apsync  <code>async</code>","text":"<pre><code>apsync(replicationid: str, offset: int)\n</code></pre> <p>Initiates a replication stream from the master. Newer version for <code>sync</code>.</p> <p>For more information see https://redis.io/commands/sync</p> Source code in <code>kvdb/components/session.py</code> <pre><code>import inspect\nfrom makefun import create_function\nfrom redis.commands import (\n    CoreCommands,\n    # RedisModuleCommands,\n    SentinelCommands,\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apttl","title":"apttl  <code>async</code>","text":"<pre><code>apttl(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the number of milliseconds until the key <code>name</code> will expire</p> <p>For more information see https://redis.io/commands/pttl</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apublish","title":"apublish  <code>async</code>","text":"<pre><code>apublish(\n    channel: redis.typing.ChannelT,\n    message: redis.typing.EncodableT,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Publish <code>message</code> on <code>channel</code>. Returns the number of subscribers the message was delivered to.</p> <p>For more information see https://redis.io/commands/publish</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apubsub","title":"apubsub","text":"<pre><code>apubsub(\n    retryable: typing.Optional[bool] = None, **kwargs\n) -&gt; kvdb.components.pubsub.AsyncPubSubT\n</code></pre> <p>Return a Publish/Subscribe object. With this object, you can subscribe to channels and listen for messages that get published to</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def apubsub(\n    self, \n    retryable: Optional[bool] = None,\n    **kwargs\n) -&gt; AsyncPubSubT:\n    \"\"\"\n    Return a Publish/Subscribe object. With this object, you can\n    subscribe to channels and listen for messages that get published to\n    \"\"\"\n    if retryable is None: retryable = self.settings.retry.pubsub_enabled\n    return self.aclient.pubsub(retryable = retryable, **kwargs)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apubsub_channels","title":"apubsub_channels  <code>async</code>","text":"<pre><code>apubsub_channels(\n    pattern: kvdb.types.generic.PatternT = \"*\", **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a list of channels that have at least one subscriber</p> <p>For more information see https://redis.io/commands/pubsub-channels</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apubsub_numpat","title":"apubsub_numpat  <code>async</code>","text":"<pre><code>apubsub_numpat(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the number of subscriptions to patterns</p> <p>For more information see https://redis.io/commands/pubsub-numpat</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apubsub_numsub","title":"apubsub_numsub  <code>async</code>","text":"<pre><code>apubsub_numsub(\n    *args: redis.typing.ChannelT, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a list of (channel, number of subscribers) tuples for each channel given in <code>*args</code></p> <p>For more information see https://redis.io/commands/pubsub-numsub</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apubsub_shardchannels","title":"apubsub_shardchannels  <code>async</code>","text":"<pre><code>apubsub_shardchannels(\n    pattern: kvdb.types.generic.PatternT = \"*\", **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a list of shard_channels that have at least one subscriber</p> <p>For more information see https://redis.io/commands/pubsub-shardchannels</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.apubsub_shardnumsub","title":"apubsub_shardnumsub  <code>async</code>","text":"<pre><code>apubsub_shardnumsub(\n    *args: redis.typing.ChannelT, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a list of (shard_channel, number of subscribers) tuples for each channel given in <code>*args</code></p> <p>For more information see https://redis.io/commands/pubsub-shardnumsub</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aquit","title":"aquit  <code>async</code>","text":"<pre><code>aquit(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Ask the server to close the connection.</p> <p>For more information see https://redis.io/commands/quit</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.arandomkey","title":"arandomkey  <code>async</code>","text":"<pre><code>arandomkey(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the name of a random key</p> <p>For more information see https://redis.io/commands/randomkey</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.areadonly","title":"areadonly  <code>async</code>","text":"<pre><code>areadonly(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Enables read queries for a connection to a Redis Cluster replica node.</p> <p>For more information see https://redis.io/commands/readonly</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.areadwrite","title":"areadwrite  <code>async</code>","text":"<pre><code>areadwrite(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Disables read queries for a connection to a Redis Cluster slave node.</p> <p>For more information see https://redis.io/commands/readwrite</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aregister_script","title":"aregister_script  <code>async</code>","text":"<pre><code>aregister_script(\n    script: redis.typing.ScriptTextT,\n) -&gt; redis.commands.core.Script\n</code></pre> <p>Register a Lua <code>script</code> specifying the <code>keys</code> it will touch. Returns a Script object that is callable and hides the complexity of deal with scripts, keys, and shas. This is the preferred way to work with Lua scripts.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.arename","title":"arename  <code>async</code>","text":"<pre><code>arename(\n    src: kvdb.types.generic.KeyT,\n    dst: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Rename key <code>src</code> to <code>dst</code></p> <p>For more information see https://redis.io/commands/rename</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.arenamenx","title":"arenamenx  <code>async</code>","text":"<pre><code>arenamenx(\n    src: kvdb.types.generic.KeyT,\n    dst: kvdb.types.generic.KeyT,\n)\n</code></pre> <p>Rename key <code>src</code> to <code>dst</code> if <code>dst</code> doesn't already exist</p> <p>For more information see https://redis.io/commands/renamenx</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.areplicaof","title":"areplicaof  <code>async</code>","text":"<pre><code>areplicaof(\n    *args, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Update the replication settings of a redis replica, on the fly.</p> <p>Examples of valid arguments include:</p> <p>NO ONE (set no replication) host port (set to the host and port of a redis server)</p> <p>For more information see  https://redis.io/commands/replicaof</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.areset","title":"areset  <code>async</code>","text":"<pre><code>areset() -&gt; None\n</code></pre> <p>Reset the state of the instance to when it was constructed</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.arestore","title":"arestore  <code>async</code>","text":"<pre><code>arestore(\n    name: kvdb.types.generic.KeyT,\n    ttl: float,\n    value: redis.typing.EncodableT,\n    replace: bool = False,\n    absttl: bool = False,\n    idletime: typing.Union[int, None] = None,\n    frequency: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Create a key using the provided serialized value, previously obtained using DUMP.</p> <p><code>replace</code> allows an existing key on <code>name</code> to be overridden. If it's not specified an error is raised on collision.</p> <p><code>absttl</code> if True, specified <code>ttl</code> should represent an absolute Unix timestamp in milliseconds in which the key will expire. (Redis 5.0 or greater).</p> <p><code>idletime</code> Used for eviction, this is the number of seconds the key must be idle, prior to execution.</p> <p><code>frequency</code> Used for eviction, this is the frequency counter of the object stored at the key, prior to execution.</p> <p>For more information see https://redis.io/commands/restore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.arole","title":"arole  <code>async</code>","text":"<pre><code>arole() -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Provide information on the role of a Redis instance in the context of replication, by returning if the instance is currently a master, slave, or sentinel.</p> <p>For more information see https://redis.io/commands/role</p> Source code in <code>kvdb/components/session.py</code> <pre><code>    blocking: bool = True,\n    blocking_timeout: Optional[Number] = None,\n    thread_local: bool = True,\n    force_unlock: Optional[bool] = None,\n    **kwargs,\n) -&gt; AsyncLock:\n    \"\"\"\n    Create a new Lock instance named ``name`` using the Redis client\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.arpop","title":"arpop  <code>async</code>","text":"<pre><code>arpop(\n    name: str, count: typing.Optional[int] = None\n) -&gt; typing.Union[\n    typing.Awaitable[typing.Union[str, typing.List, None]],\n    typing.Union[str, typing.List, None],\n]\n</code></pre> <p>Removes and returns the last elements of the list <code>name</code>.</p> <p>By default, the command pops a single element from the end of the list. When provided with the optional <code>count</code> argument, the reply will consist of up to count elements, depending on the list's length.</p> <p>For more information see https://redis.io/commands/rpop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.arpoplpush","title":"arpoplpush  <code>async</code>","text":"<pre><code>arpoplpush(\n    src: str, dst: str\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>RPOP a value off of the <code>src</code> list and atomically LPUSH it on to the <code>dst</code> list.  Returns the value.</p> <p>For more information see https://redis.io/commands/rpoplpush</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.arpush","title":"arpush  <code>async</code>","text":"<pre><code>arpush(\n    name: str, *values: redis.typing.FieldT\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Push <code>values</code> onto the tail of the list <code>name</code></p> <p>For more information see https://redis.io/commands/rpush</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.arpushx","title":"arpushx  <code>async</code>","text":"<pre><code>arpushx(\n    name: str, *values: str\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Push <code>value</code> onto the tail of the list <code>name</code> if <code>name</code> exists</p> <p>For more information see https://redis.io/commands/rpushx</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asadd","title":"asadd  <code>async</code>","text":"<pre><code>asadd(\n    name: str, *values: redis.typing.FieldT\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Add <code>value(s)</code> to set <code>name</code></p> <p>For more information see https://redis.io/commands/sadd</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asave","title":"asave  <code>async</code>","text":"<pre><code>asave(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Tell the Redis server to save its data to disk, blocking until the save is complete</p> <p>For more information see https://redis.io/commands/save</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ascan","title":"ascan  <code>async</code>","text":"<pre><code>ascan(\n    cursor: int = 0,\n    match: typing.Union[\n        kvdb.types.generic.PatternT, None\n    ] = None,\n    count: typing.Union[int, None] = None,\n    _type: typing.Union[str, None] = None,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Incrementally return lists of key names. Also return a cursor indicating the scan position.</p> <p><code>match</code> allows for filtering the keys by pattern</p> <p><code>count</code> provides a hint to Redis about the number of keys to     return per batch.</p> <p><code>_type</code> filters the returned values by a particular Redis type.     Stock Redis instances allow for the following types:     HASH, LIST, SET, STREAM, STRING, ZSET     Additionally, Redis modules can expose other types as well.</p> <p>For more information see https://redis.io/commands/scan</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ascan_iter","title":"ascan_iter  <code>async</code>","text":"<pre><code>ascan_iter(\n    match: typing.Union[\n        kvdb.types.generic.PatternT, None\n    ] = None,\n    count: typing.Union[int, None] = None,\n    _type: typing.Union[str, None] = None,\n    **kwargs\n) -&gt; typing.AsyncIterator\n</code></pre> <p>Make an iterator using the SCAN command so that the client doesn't need to remember the cursor position.</p> <p><code>match</code> allows for filtering the keys by pattern</p> <p><code>count</code> provides a hint to Redis about the number of keys to     return per batch.</p> <p><code>_type</code> filters the returned values by a particular Redis type.     Stock Redis instances allow for the following types:     HASH, LIST, SET, STREAM, STRING, ZSET     Additionally, Redis modules can expose other types as well.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ascard","title":"ascard  <code>async</code>","text":"<pre><code>ascard(\n    name: str,\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Return the number of elements in set <code>name</code></p> <p>For more information see https://redis.io/commands/scard</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ascript_exists","title":"ascript_exists  <code>async</code>","text":"<pre><code>ascript_exists(\n    *args: str,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Check if a script exists in the script cache by specifying the SHAs of each script as <code>args</code>. Returns a list of boolean values indicating if if each already script exists in the cache.</p> <p>For more information see  https://redis.io/commands/script-exists</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ascript_flush","title":"ascript_flush  <code>async</code>","text":"<pre><code>ascript_flush(\n    sync_type: typing.Union[\n        typing.Literal[\"SYNC\"], typing.Literal[\"ASYNC\"]\n    ] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Flush all scripts from the script cache.</p> <p><code>sync_type</code> is by default SYNC (synchronous) but it can also be               ASYNC.</p> <p>For more information see  https://redis.io/commands/script-flush</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ascript_kill","title":"ascript_kill  <code>async</code>","text":"<pre><code>ascript_kill() -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Kill the currently executing Lua script</p> <p>For more information see https://redis.io/commands/script-kill</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ascript_load","title":"ascript_load  <code>async</code>","text":"<pre><code>ascript_load(\n    script: redis.typing.ScriptTextT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Load a Lua <code>script</code> into the script cache. Returns the SHA.</p> <p>For more information see https://redis.io/commands/script-load</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asdiff","title":"asdiff  <code>async</code>","text":"<pre><code>asdiff(\n    keys: typing.List, *args: typing.List\n) -&gt; typing.Union[typing.Awaitable[list], list]\n</code></pre> <p>Return the difference of sets specified by <code>keys</code></p> <p>For more information see https://redis.io/commands/sdiff</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asdiffstore","title":"asdiffstore  <code>async</code>","text":"<pre><code>asdiffstore(\n    dest: str, keys: typing.List, *args: typing.List\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Store the difference of sets specified by <code>keys</code> into a new set named <code>dest</code>.  Returns the number of keys in the new set.</p> <p>For more information see https://redis.io/commands/sdiffstore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aselect","title":"aselect  <code>async</code>","text":"<pre><code>aselect(\n    index: int, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Select the Redis logical database at index.</p> <p>See: https://redis.io/commands/select</p> Source code in <code>kvdb/components/session.py</code> <pre><code>added_methods = set()\n\n# Sync Methods\nfor sync_module in {\n    CoreCommands,\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aset","title":"aset  <code>async</code>","text":"<pre><code>aset(\n    name: kvdb.types.generic.KeyT,\n    value: redis.typing.EncodableT,\n    ex: typing.Union[\n        kvdb.types.generic.ExpiryT, None\n    ] = None,\n    px: typing.Union[\n        kvdb.types.generic.ExpiryT, None\n    ] = None,\n    nx: bool = False,\n    xx: bool = False,\n    keepttl: bool = False,\n    get: bool = False,\n    exat: typing.Union[\n        kvdb.types.generic.AbsExpiryT, None\n    ] = None,\n    pxat: typing.Union[\n        kvdb.types.generic.AbsExpiryT, None\n    ] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set the value at key <code>name</code> to <code>value</code></p> <p><code>ex</code> sets an expire flag on key <code>name</code> for <code>ex</code> seconds.</p> <p><code>px</code> sets an expire flag on key <code>name</code> for <code>px</code> milliseconds.</p> <p><code>nx</code> if set to True, set the value at key <code>name</code> to <code>value</code> only     if it does not exist.</p> <p><code>xx</code> if set to True, set the value at key <code>name</code> to <code>value</code> only     if it already exists.</p> <p><code>keepttl</code> if True, retain the time to live associated with the key.     (Available since Redis 6.0)</p> <p><code>get</code> if True, set the value at key <code>name</code> to <code>value</code> and return     the old value stored at key, or None if the key did not exist.     (Available since Redis 6.2)</p> <p><code>exat</code> sets an expire flag on key <code>name</code> for <code>ex</code> seconds,     specified in unix time.</p> <p><code>pxat</code> sets an expire flag on key <code>name</code> for <code>ex</code> milliseconds,     specified in unix time.</p> <p>For more information see https://redis.io/commands/set</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asetbit","title":"asetbit  <code>async</code>","text":"<pre><code>asetbit(\n    name: kvdb.types.generic.KeyT, offset: int, value: int\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Flag the <code>offset</code> in <code>name</code> as <code>value</code>. Returns an integer indicating the previous value of <code>offset</code>.</p> <p>For more information see https://redis.io/commands/setbit</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asetex","title":"asetex  <code>async</code>","text":"<pre><code>asetex(\n    name: kvdb.types.generic.KeyT,\n    time: kvdb.types.generic.ExpiryT,\n    value: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set the value of key <code>name</code> to <code>value</code> that expires in <code>time</code> seconds. <code>time</code> can be represented by an integer or a Python timedelta object.</p> <p>For more information see https://redis.io/commands/setex</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asetitem","title":"asetitem  <code>async</code>","text":"<pre><code>asetitem(\n    key: kvdb.types.generic.KeyT,\n    value: typing.Any,\n    ex: typing.Optional[kvdb.types.generic.ExpiryT] = None,\n    **kwargs: typing.Any\n) -&gt; None\n</code></pre> <p>[Dict] Sets the value for the given key</p> Source code in <code>kvdb/components/session.py</code> <pre><code>async def asetitem(\n    self,\n    key: KeyT,\n    value: Any,\n    ex: Optional[ExpiryT] = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    [Dict] Sets the value for the given key\n    \"\"\"\n    return await self.persistence.aset(key, value, ex = ex, **kwargs)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asetnx","title":"asetnx  <code>async</code>","text":"<pre><code>asetnx(\n    name: kvdb.types.generic.KeyT,\n    value: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set the value of key <code>name</code> to <code>value</code> if key doesn't exist</p> <p>For more information see https://redis.io/commands/setnx</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asetrange","title":"asetrange  <code>async</code>","text":"<pre><code>asetrange(\n    name: kvdb.types.generic.KeyT,\n    offset: int,\n    value: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Overwrite bytes in the value of <code>name</code> starting at <code>offset</code> with <code>value</code>. If <code>offset</code> plus the length of <code>value</code> exceeds the length of the original value, the new value will be larger than before. If <code>offset</code> exceeds the length of the original value, null bytes will be used to pad between the end of the previous value and the start of what's being injected.</p> <p>Returns the length of the new string.</p> <p>For more information see https://redis.io/commands/setrange</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ashutdown","title":"ashutdown  <code>async</code>","text":"<pre><code>ashutdown(\n    save: bool = False,\n    nosave: bool = False,\n    now: bool = False,\n    force: bool = False,\n    abort: bool = False,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Shutdown the Redis server.  If Redis has persistence configured, data will be flushed before shutdown. It is possible to specify modifiers to alter the behavior of the command: <code>save</code> will force a DB saving operation even if no save points are configured. <code>nosave</code> will prevent a DB saving operation even if one or more save points are configured. <code>now</code> skips waiting for lagging replicas, i.e. it bypasses the first step in the shutdown sequence. <code>force</code> ignores any errors that would normally prevent the server from exiting <code>abort</code> cancels an ongoing shutdown and cannot be combined with other flags.</p> <p>For more information see https://redis.io/commands/shutdown</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asinter","title":"asinter  <code>async</code>","text":"<pre><code>asinter(\n    keys: typing.List, *args: typing.List\n) -&gt; typing.Union[typing.Awaitable[list], list]\n</code></pre> <p>Return the intersection of sets specified by <code>keys</code></p> <p>For more information see https://redis.io/commands/sinter</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asintercard","title":"asintercard  <code>async</code>","text":"<pre><code>asintercard(\n    numkeys: int, keys: typing.List[str], limit: int = 0\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Return the cardinality of the intersect of multiple sets specified by <code>`keys</code>.</p> <p>When LIMIT provided (defaults to 0 and means unlimited), if the intersection cardinality reaches limit partway through the computation, the algorithm will exit and yield limit as the cardinality</p> <p>For more information see https://redis.io/commands/sintercard</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asinterstore","title":"asinterstore  <code>async</code>","text":"<pre><code>asinterstore(\n    dest: str, keys: typing.List, *args: typing.List\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Store the intersection of sets specified by <code>keys</code> into a new set named <code>dest</code>.  Returns the number of keys in the new set.</p> <p>For more information see https://redis.io/commands/sinterstore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asismember","title":"asismember  <code>async</code>","text":"<pre><code>asismember(name: str, value: str) -&gt; typing.Union[\n    typing.Awaitable[\n        typing.Union[typing.Literal[0], typing.Literal[1]]\n    ],\n    typing.Union[typing.Literal[0], typing.Literal[1]],\n]\n</code></pre> <p>Return whether <code>value</code> is a member of set <code>name</code>: - 1 if the value is a member of the set. - 0 if the value is not a member of the set or if key does not exist.</p> <p>For more information see https://redis.io/commands/sismember</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aslaveof","title":"aslaveof  <code>async</code>","text":"<pre><code>aslaveof(\n    host: typing.Union[str, None] = None,\n    port: typing.Union[int, None] = None,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set the server to be a replicated slave of the instance identified by the <code>host</code> and <code>port</code>. If called without arguments, the instance is promoted to a master instead.</p> <p>For more information see https://redis.io/commands/slaveof</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aslowlog_get","title":"aslowlog_get  <code>async</code>","text":"<pre><code>aslowlog_get(\n    num: typing.Union[int, None] = None, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Get the entries from the slowlog. If <code>num</code> is specified, get the most recent <code>num</code> items.</p> <p>For more information see https://redis.io/commands/slowlog-get</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aslowlog_len","title":"aslowlog_len  <code>async</code>","text":"<pre><code>aslowlog_len(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Get the number of items in the slowlog</p> <p>For more information see https://redis.io/commands/slowlog-len</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aslowlog_reset","title":"aslowlog_reset  <code>async</code>","text":"<pre><code>aslowlog_reset(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Remove all items in the slowlog</p> <p>For more information see https://redis.io/commands/slowlog-reset</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asmembers","title":"asmembers  <code>async</code>","text":"<pre><code>asmembers(\n    name: str,\n) -&gt; typing.Union[typing.Awaitable[typing.Set], typing.Set]\n</code></pre> <p>Return all members of the set <code>name</code></p> <p>For more information see https://redis.io/commands/smembers</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asmismember","title":"asmismember  <code>async</code>","text":"<pre><code>asmismember(\n    name: str, values: typing.List, *args: typing.List\n) -&gt; typing.Union[\n    typing.Awaitable[\n        typing.List[\n            typing.Union[\n                typing.Literal[0], typing.Literal[1]\n            ]\n        ]\n    ],\n    typing.List[\n        typing.Union[typing.Literal[0], typing.Literal[1]]\n    ],\n]\n</code></pre> <p>Return whether each value in <code>values</code> is a member of the set <code>name</code> as a list of <code>int</code> in the order of <code>values</code>: - 1 if the value is a member of the set. - 0 if the value is not a member of the set or if key does not exist.</p> <p>For more information see https://redis.io/commands/smismember</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asmove","title":"asmove  <code>async</code>","text":"<pre><code>asmove(\n    src: str, dst: str, value: str\n) -&gt; typing.Union[typing.Awaitable[bool], bool]\n</code></pre> <p>Move <code>value</code> from set <code>src</code> to set <code>dst</code> atomically</p> <p>For more information see https://redis.io/commands/smove</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asort","title":"asort  <code>async</code>","text":"<pre><code>asort(\n    name: str,\n    start: typing.Optional[int] = None,\n    num: typing.Optional[int] = None,\n    by: typing.Optional[str] = None,\n    get: typing.Optional[typing.List[str]] = None,\n    desc: bool = False,\n    alpha: bool = False,\n    store: typing.Optional[str] = None,\n    groups: typing.Optional[bool] = False,\n) -&gt; typing.Union[typing.List, int]\n</code></pre> <p>Sort and return the list, set or sorted set at <code>name</code>.</p> <p><code>start</code> and <code>num</code> allow for paging through the sorted data</p> <p><code>by</code> allows using an external key to weight and sort the items.     Use an \"*\" to indicate where in the key the item value is located</p> <p><code>get</code> allows for returning items from external keys rather than the     sorted data itself.  Use an \"*\" to indicate where in the key     the item value is located</p> <p><code>desc</code> allows for reversing the sort</p> <p><code>alpha</code> allows for sorting lexicographically rather than numerically</p> <p><code>store</code> allows for storing the result of the sort into     the key <code>store</code></p> <p><code>groups</code> if set to True and if <code>get</code> contains at least two     elements, sort will return a list of tuples, each containing the     values fetched from the arguments to <code>get</code>.</p> <p>For more information see https://redis.io/commands/sort</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asort_ro","title":"asort_ro  <code>async</code>","text":"<pre><code>asort_ro(\n    key: str,\n    start: typing.Optional[int] = None,\n    num: typing.Optional[int] = None,\n    by: typing.Optional[str] = None,\n    get: typing.Optional[typing.List[str]] = None,\n    desc: bool = False,\n    alpha: bool = False,\n) -&gt; list\n</code></pre> <p>Returns the elements contained in the list, set or sorted set at key. (read-only variant of the SORT command)</p> <p><code>start</code> and <code>num</code> allow for paging through the sorted data</p> <p><code>by</code> allows using an external key to weight and sort the items.     Use an \"*\" to indicate where in the key the item value is located</p> <p><code>get</code> allows for returning items from external keys rather than the     sorted data itself.  Use an \"*\" to indicate where in the key     the item value is located</p> <p><code>desc</code> allows for reversing the sort</p> <p><code>alpha</code> allows for sorting lexicographically rather than numerically</p> <p>For more information see https://redis.io/commands/sort_ro</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aspop","title":"aspop  <code>async</code>","text":"<pre><code>aspop(\n    name: str, count: typing.Optional[int] = None\n) -&gt; typing.Union[str, typing.List, None]\n</code></pre> <p>Remove and return a random member of set <code>name</code></p> <p>For more information see https://redis.io/commands/spop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aspublish","title":"aspublish  <code>async</code>","text":"<pre><code>aspublish(\n    shard_channel: redis.typing.ChannelT,\n    message: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Posts a message to the given shard channel. Returns the number of clients that received the message</p> <p>For more information see https://redis.io/commands/spublish</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asrandmember","title":"asrandmember  <code>async</code>","text":"<pre><code>asrandmember(\n    name: str, number: typing.Optional[int] = None\n) -&gt; typing.Union[str, typing.List, None]\n</code></pre> <p>If <code>number</code> is None, returns a random member of set <code>name</code>.</p> <p>If <code>number</code> is supplied, returns a list of <code>number</code> random members of set <code>name</code>. Note this is only available when running Redis 2.6+.</p> <p>For more information see https://redis.io/commands/srandmember</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asrem","title":"asrem  <code>async</code>","text":"<pre><code>asrem(\n    name: str, *values: redis.typing.FieldT\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Remove <code>values</code> from set <code>name</code></p> <p>For more information see https://redis.io/commands/srem</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asscan","title":"asscan  <code>async</code>","text":"<pre><code>asscan(\n    name: kvdb.types.generic.KeyT,\n    cursor: int = 0,\n    match: typing.Union[\n        kvdb.types.generic.PatternT, None\n    ] = None,\n    count: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Incrementally return lists of elements in a set. Also return a cursor indicating the scan position.</p> <p><code>match</code> allows for filtering the keys by pattern</p> <p><code>count</code> allows for hint the minimum number of returns</p> <p>For more information see https://redis.io/commands/sscan</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asscan_iter","title":"asscan_iter  <code>async</code>","text":"<pre><code>asscan_iter(\n    name: kvdb.types.generic.KeyT,\n    match: typing.Union[\n        kvdb.types.generic.PatternT, None\n    ] = None,\n    count: typing.Union[int, None] = None,\n) -&gt; typing.AsyncIterator\n</code></pre> <p>Make an iterator using the SSCAN command so that the client doesn't need to remember the cursor position.</p> <p><code>match</code> allows for filtering the keys by pattern</p> <p><code>count</code> allows for hint the minimum number of returns</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.astralgo","title":"astralgo  <code>async</code>","text":"<pre><code>astralgo(\n    algo: typing.Literal[\"LCS\"],\n    value1: kvdb.types.generic.KeyT,\n    value2: kvdb.types.generic.KeyT,\n    specific_argument: typing.Union[\n        typing.Literal[\"strings\"], typing.Literal[\"keys\"]\n    ] = \"strings\",\n    len: bool = False,\n    idx: bool = False,\n    minmatchlen: typing.Union[int, None] = None,\n    withmatchlen: bool = False,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Implements complex algorithms that operate on strings. Right now the only algorithm implemented is the LCS algorithm (longest common substring). However new algorithms could be implemented in the future.</p> <p><code>algo</code> Right now must be LCS <code>value1</code> and <code>value2</code> Can be two strings or two keys <code>specific_argument</code> Specifying if the arguments to the algorithm will be keys or strings. strings is the default. <code>len</code> Returns just the len of the match. <code>idx</code> Returns the match positions in each string. <code>minmatchlen</code> Restrict the list of matches to the ones of a given minimal length. Can be provided only when <code>idx</code> set to True. <code>withmatchlen</code> Returns the matches with the len of the match. Can be provided only when <code>idx</code> set to True.</p> <p>For more information see https://redis.io/commands/stralgo</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.astrlen","title":"astrlen  <code>async</code>","text":"<pre><code>astrlen(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the number of bytes stored in the value of <code>name</code></p> <p>For more information see https://redis.io/commands/strlen</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asubstr","title":"asubstr  <code>async</code>","text":"<pre><code>asubstr(\n    name: kvdb.types.generic.KeyT, start: int, end: int = -1\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a substring of the string at key <code>name</code>. <code>start</code> and <code>end</code> are 0-based integers specifying the portion of the string to return.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asunion","title":"asunion  <code>async</code>","text":"<pre><code>asunion(\n    keys: typing.List, *args: typing.List\n) -&gt; typing.Union[\n    typing.Awaitable[typing.List], typing.List\n]\n</code></pre> <p>Return the union of sets specified by <code>keys</code></p> <p>For more information see https://redis.io/commands/sunion</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.asunionstore","title":"asunionstore  <code>async</code>","text":"<pre><code>asunionstore(\n    dest: str, keys: typing.List, *args: typing.List\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Store the union of sets specified by <code>keys</code> into a new set named <code>dest</code>.  Returns the number of keys in the new set.</p> <p>For more information see https://redis.io/commands/sunionstore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aswapdb","title":"aswapdb  <code>async</code>","text":"<pre><code>aswapdb(\n    first: int, second: int, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Swap two databases</p> <p>For more information see https://redis.io/commands/swapdb</p> Source code in <code>kvdb/components/session.py</code> <pre><code>    AsyncCoreCommands, \n    # AsyncRedisModuleCommands,\n    AsyncSentinelCommands,\n)\n\nexisting_methods = set(dir(cls))\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.async_","title":"async_  <code>async</code>","text":"<pre><code>async_() -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Initiates a replication stream from the master.</p> <p>For more information see https://redis.io/commands/sync</p> Source code in <code>kvdb/components/session.py</code> <pre><code>@classmethod\ndef initialize_class_functions(cls):\n    \"\"\"\n    Initializes the class methods\n    and sets them based on both the async and sync methods\n    \"\"\"\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.atfcall","title":"atfcall  <code>async</code>","text":"<pre><code>atfcall(\n    lib_name: str,\n    func_name: str,\n    keys: redis.typing.KeysT = None,\n    *args: typing.List\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Invoke a function.</p> <p><code>lib_name</code> - the library name contains the function. <code>func_name</code> - the function name to run. <code>keys</code> - the keys that will be touched by the function. <code>args</code> - Additional argument to pass to the function.</p> <p>For more information see https://redis.io/commands/tfcall/</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.atfcall_async","title":"atfcall_async  <code>async</code>","text":"<pre><code>atfcall_async(\n    lib_name: str,\n    func_name: str,\n    keys: redis.typing.KeysT = None,\n    *args: typing.List\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Invoke an async function (coroutine).</p> <p><code>lib_name</code> - the library name contains the function. <code>func_name</code> - the function name to run. <code>keys</code> - the keys that will be touched by the function. <code>args</code> - Additional argument to pass to the function.</p> <p>For more information see https://redis.io/commands/tfcall/</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.atfunction_delete","title":"atfunction_delete  <code>async</code>","text":"<pre><code>atfunction_delete(\n    lib_name: str,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Delete a library from RedisGears.</p> <p><code>lib_name</code> the library name to delete.</p> <p>For more information see https://redis.io/commands/tfunction-delete/</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.atfunction_list","title":"atfunction_list  <code>async</code>","text":"<pre><code>atfunction_list(\n    with_code: bool = False,\n    verbose: int = 0,\n    lib_name: typing.Union[str, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>List the functions with additional information about each function.</p> <p><code>with_code</code> Show libraries code. <code>verbose</code> output verbosity level, higher number will increase verbosity level <code>lib_name</code> specifying a library name (can be used multiple times to show multiple libraries in a single command) # noqa</p> <p>For more information see https://redis.io/commands/tfunction-list/</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.atfunction_load","title":"atfunction_load  <code>async</code>","text":"<pre><code>atfunction_load(\n    lib_code: str,\n    replace: bool = False,\n    config: typing.Union[str, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Load a new library to RedisGears.</p> <p><code>lib_code</code> - the library code. <code>config</code> - a string representation of a JSON object that will be provided to the library on load time, for more information refer to https://github.com/RedisGears/RedisGears/blob/master/docs/function_advance_topics.md#library-configuration <code>replace</code> - an optional argument, instructs RedisGears to replace the function if its already exists</p> <p>For more information see https://redis.io/commands/tfunction-load/</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.atime","title":"atime  <code>async</code>","text":"<pre><code>atime(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the server time as a 2-item tuple of ints: (seconds since epoch, microseconds into this second).</p> <p>For more information see https://redis.io/commands/time</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.atouch","title":"atouch  <code>async</code>","text":"<pre><code>atouch(\n    *args: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Alters the last access time of a key(s) <code>*args</code>. A key is ignored if it does not exist.</p> <p>For more information see https://redis.io/commands/touch</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.attl","title":"attl  <code>async</code>","text":"<pre><code>attl(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the number of seconds until the key <code>name</code> will expire</p> <p>For more information see https://redis.io/commands/ttl</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.atype","title":"atype  <code>async</code>","text":"<pre><code>atype(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the type of key <code>name</code></p> <p>For more information see https://redis.io/commands/type</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aunlink","title":"aunlink  <code>async</code>","text":"<pre><code>aunlink(\n    *names: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Unlink one or more keys specified by <code>names</code></p> <p>For more information see https://redis.io/commands/unlink</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.aunwatch","title":"aunwatch  <code>async</code>","text":"<pre><code>aunwatch() -&gt; None\n</code></pre> <p>Unwatches the value at key <code>name</code>, or None of the key doesn't exist</p> <p>For more information see https://redis.io/commands/unwatch</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.auth","title":"auth","text":"<pre><code>auth(\n    password: str,\n    username: typing.Optional[str] = None,\n    **kwargs\n)\n</code></pre> <p>Authenticates the user. If you do not pass username, Redis will try to authenticate for the \"default\" user. If you do pass username, it will authenticate for the given user. For more information see https://redis.io/commands/auth</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.await_","title":"await_  <code>async</code>","text":"<pre><code>await_(\n    num_replicas: int, timeout: int, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Redis synchronous replication That returns the number of replicas that processed the query when we finally have at least <code>num_replicas</code>, or when the <code>timeout</code> was reached.</p> <p>For more information see https://redis.io/commands/wait</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.awaitaof","title":"awaitaof  <code>async</code>","text":"<pre><code>awaitaof(\n    num_local: int,\n    num_replicas: int,\n    timeout: int,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>This command blocks the current client until all previous write commands by that client are acknowledged as having been fsynced to the AOF of the local Redis and/or at least the specified number of replicas.</p> <p>For more information see https://redis.io/commands/waitaof</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.awatch","title":"awatch  <code>async</code>","text":"<pre><code>awatch(*names: kvdb.types.generic.KeyT) -&gt; None\n</code></pre> <p>Watches the values at keys <code>names</code>, or None if the key doesn't exist</p> <p>For more information see https://redis.io/commands/watch</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axack","title":"axack  <code>async</code>","text":"<pre><code>axack(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n    *ids: redis.typing.StreamIdT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Acknowledges the successful processing of one or more messages. name: name of the stream. groupname: name of the consumer group. *ids: message ids to acknowledge.</p> <p>For more information see https://redis.io/commands/xack</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axadd","title":"axadd  <code>async</code>","text":"<pre><code>axadd(\n    name: kvdb.types.generic.KeyT,\n    fields: typing.Dict[\n        redis.typing.FieldT, redis.typing.EncodableT\n    ],\n    id: redis.typing.StreamIdT = \"*\",\n    maxlen: typing.Union[int, None] = None,\n    approximate: bool = True,\n    nomkstream: bool = False,\n    minid: typing.Union[\n        redis.typing.StreamIdT, None\n    ] = None,\n    limit: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Add to a stream. name: name of the stream fields: dict of field/value pairs to insert into the stream id: Location to insert this record. By default it is appended. maxlen: truncate old stream members beyond this size. Can't be specified with minid. approximate: actual stream length may be slightly more than maxlen nomkstream: When set to true, do not make a stream minid: the minimum id in the stream to query. Can't be specified with maxlen. limit: specifies the maximum number of entries to retrieve</p> <p>For more information see https://redis.io/commands/xadd</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axautoclaim","title":"axautoclaim  <code>async</code>","text":"<pre><code>axautoclaim(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n    consumername: redis.typing.ConsumerT,\n    min_idle_time: int,\n    start_id: redis.typing.StreamIdT = \"0-0\",\n    count: typing.Union[int, None] = None,\n    justid: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Transfers ownership of pending stream entries that match the specified criteria. Conceptually, equivalent to calling XPENDING and then XCLAIM, but provides a more straightforward way to deal with message delivery failures via SCAN-like semantics. name: name of the stream. groupname: name of the consumer group. consumername: name of a consumer that claims the message. min_idle_time: filter messages that were idle less than this amount of milliseconds. start_id: filter messages with equal or greater ID. count: optional integer, upper limit of the number of entries that the command attempts to claim. Set to 100 by default. justid: optional boolean, false by default. Return just an array of IDs of messages successfully claimed, without returning the actual message</p> <p>For more information see https://redis.io/commands/xautoclaim</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axclaim","title":"axclaim  <code>async</code>","text":"<pre><code>axclaim(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n    consumername: redis.typing.ConsumerT,\n    min_idle_time: int,\n    message_ids: typing.Union[\n        typing.List[redis.typing.StreamIdT],\n        typing.Tuple[redis.typing.StreamIdT],\n    ],\n    idle: typing.Union[int, None] = None,\n    time: typing.Union[int, None] = None,\n    retrycount: typing.Union[int, None] = None,\n    force: bool = False,\n    justid: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Changes the ownership of a pending message.</p> <p>name: name of the stream.</p> <p>groupname: name of the consumer group.</p> <p>consumername: name of a consumer that claims the message.</p> <p>min_idle_time: filter messages that were idle less than this amount of milliseconds</p> <p>message_ids: non-empty list or tuple of message IDs to claim</p> <p>idle: optional. Set the idle time (last time it was delivered) of the message in ms</p> <p>time: optional integer. This is the same as idle but instead of a relative amount of milliseconds, it sets the idle time to a specific Unix time (in milliseconds).</p> <p>retrycount: optional integer. set the retry counter to the specified value. This counter is incremented every time a message is delivered again.</p> <p>force: optional boolean, false by default. Creates the pending message entry in the PEL even if certain specified IDs are not already in the PEL assigned to a different client.</p> <p>justid: optional boolean, false by default. Return just an array of IDs of messages successfully claimed, without returning the actual message</p> <p>For more information see https://redis.io/commands/xclaim</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axdel","title":"axdel  <code>async</code>","text":"<pre><code>axdel(\n    name: kvdb.types.generic.KeyT,\n    *ids: redis.typing.StreamIdT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Deletes one or more messages from a stream. name: name of the stream. *ids: message ids to delete.</p> <p>For more information see https://redis.io/commands/xdel</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axgroup_create","title":"axgroup_create  <code>async</code>","text":"<pre><code>axgroup_create(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n    id: redis.typing.StreamIdT = \"$\",\n    mkstream: bool = False,\n    entries_read: typing.Optional[int] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Create a new consumer group associated with a stream. name: name of the stream. groupname: name of the consumer group. id: ID of the last item in the stream to consider already delivered.</p> <p>For more information see https://redis.io/commands/xgroup-create</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axgroup_createconsumer","title":"axgroup_createconsumer  <code>async</code>","text":"<pre><code>axgroup_createconsumer(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n    consumername: redis.typing.ConsumerT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Consumers in a consumer group are auto-created every time a new consumer name is mentioned by some command. They can be explicitly created by using this command. name: name of the stream. groupname: name of the consumer group. consumername: name of consumer to create.</p> <p>See: https://redis.io/commands/xgroup-createconsumer</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axgroup_delconsumer","title":"axgroup_delconsumer  <code>async</code>","text":"<pre><code>axgroup_delconsumer(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n    consumername: redis.typing.ConsumerT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Remove a specific consumer from a consumer group. Returns the number of pending messages that the consumer had before it was deleted. name: name of the stream. groupname: name of the consumer group. consumername: name of consumer to delete</p> <p>For more information see https://redis.io/commands/xgroup-delconsumer</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axgroup_destroy","title":"axgroup_destroy  <code>async</code>","text":"<pre><code>axgroup_destroy(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Destroy a consumer group. name: name of the stream. groupname: name of the consumer group.</p> <p>For more information see https://redis.io/commands/xgroup-destroy</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axgroup_setid","title":"axgroup_setid  <code>async</code>","text":"<pre><code>axgroup_setid(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n    id: redis.typing.StreamIdT,\n    entries_read: typing.Optional[int] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set the consumer group last delivered ID to something else. name: name of the stream. groupname: name of the consumer group. id: ID of the last item in the stream to consider already delivered.</p> <p>For more information see https://redis.io/commands/xgroup-setid</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axinfo_consumers","title":"axinfo_consumers  <code>async</code>","text":"<pre><code>axinfo_consumers(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns general information about the consumers in the group. name: name of the stream. groupname: name of the consumer group.</p> <p>For more information see https://redis.io/commands/xinfo-consumers</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axinfo_groups","title":"axinfo_groups  <code>async</code>","text":"<pre><code>axinfo_groups(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns general information about the consumer groups of the stream. name: name of the stream.</p> <p>For more information see https://redis.io/commands/xinfo-groups</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axinfo_stream","title":"axinfo_stream  <code>async</code>","text":"<pre><code>axinfo_stream(\n    name: kvdb.types.generic.KeyT, full: bool = False\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns general information about the stream. name: name of the stream. full: optional boolean, false by default. Return full summary</p> <p>For more information see https://redis.io/commands/xinfo-stream</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axlen","title":"axlen  <code>async</code>","text":"<pre><code>axlen(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the number of elements in a given stream.</p> <p>For more information see https://redis.io/commands/xlen</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axpending","title":"axpending  <code>async</code>","text":"<pre><code>axpending(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns information about pending messages of a group. name: name of the stream. groupname: name of the consumer group.</p> <p>For more information see https://redis.io/commands/xpending</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axpending_range","title":"axpending_range  <code>async</code>","text":"<pre><code>axpending_range(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n    min: redis.typing.StreamIdT,\n    max: redis.typing.StreamIdT,\n    count: int,\n    consumername: typing.Union[\n        redis.typing.ConsumerT, None\n    ] = None,\n    idle: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns information about pending messages, in a range.</p> <p>name: name of the stream. groupname: name of the consumer group. idle: available from  version 6.2. filter entries by their idle-time, given in milliseconds (optional). min: minimum stream ID. max: maximum stream ID. count: number of messages to return consumername: name of a consumer to filter by (optional).</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axrange","title":"axrange  <code>async</code>","text":"<pre><code>axrange(\n    name: kvdb.types.generic.KeyT,\n    min: redis.typing.StreamIdT = \"-\",\n    max: redis.typing.StreamIdT = \"+\",\n    count: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Read stream values within an interval.</p> <p>name: name of the stream.</p> first stream ID. defaults to '-', <p>meaning the earliest available.</p> last stream ID. defaults to '+', <p>meaning the latest available.</p> if set, only return this many items, beginning with the <p>earliest available.</p> <p>For more information see https://redis.io/commands/xrange</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axread","title":"axread  <code>async</code>","text":"<pre><code>axread(\n    streams: typing.Dict[\n        kvdb.types.generic.KeyT, redis.typing.StreamIdT\n    ],\n    count: typing.Union[int, None] = None,\n    block: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Block and monitor multiple streams for new data.</p> a dict of stream names to stream IDs, where <p>IDs indicate the last ID already seen.</p> if set, only return this many items, beginning with the <p>earliest available.</p> <p>block: number of milliseconds to wait, if nothing already present.</p> <p>For more information see https://redis.io/commands/xread</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axreadgroup","title":"axreadgroup  <code>async</code>","text":"<pre><code>axreadgroup(\n    groupname: str,\n    consumername: str,\n    streams: typing.Dict[\n        kvdb.types.generic.KeyT, redis.typing.StreamIdT\n    ],\n    count: typing.Union[int, None] = None,\n    block: typing.Union[int, None] = None,\n    noack: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Read from a stream via a consumer group.</p> <p>groupname: name of the consumer group.</p> <p>consumername: name of the requesting consumer.</p> a dict of stream names to stream IDs, where <p>IDs indicate the last ID already seen.</p> if set, only return this many items, beginning with the <p>earliest available.</p> <p>block: number of milliseconds to wait, if nothing already present. noack: do not add messages to the PEL</p> <p>For more information see https://redis.io/commands/xreadgroup</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axrevrange","title":"axrevrange  <code>async</code>","text":"<pre><code>axrevrange(\n    name: kvdb.types.generic.KeyT,\n    max: redis.typing.StreamIdT = \"+\",\n    min: redis.typing.StreamIdT = \"-\",\n    count: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Read stream values within an interval, in reverse order.</p> <p>name: name of the stream</p> first stream ID. defaults to '+', <p>meaning the latest available.</p> last stream ID. defaults to '-', <p>meaning the earliest available.</p> if set, only return this many items, beginning with the <p>latest available.</p> <p>For more information see https://redis.io/commands/xrevrange</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.axtrim","title":"axtrim  <code>async</code>","text":"<pre><code>axtrim(\n    name: kvdb.types.generic.KeyT,\n    maxlen: typing.Union[int, None] = None,\n    approximate: bool = True,\n    minid: typing.Union[\n        redis.typing.StreamIdT, None\n    ] = None,\n    limit: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Trims old messages from a stream. name: name of the stream. maxlen: truncate old stream messages beyond this size Can't be specified with minid. approximate: actual stream length may be slightly more than maxlen minid: the minimum id in the stream to query Can't be specified with maxlen. limit: specifies the maximum number of entries to retrieve</p> <p>For more information see https://redis.io/commands/xtrim</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azadd","title":"azadd  <code>async</code>","text":"<pre><code>azadd(\n    name: kvdb.types.generic.KeyT,\n    mapping: typing.Mapping[\n        redis.typing.AnyKeyT, redis.typing.EncodableT\n    ],\n    nx: bool = False,\n    xx: bool = False,\n    ch: bool = False,\n    incr: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set any number of element-name, score pairs to the key <code>name</code>. Pairs are specified as a dict of element-names keys to score values.</p> <p><code>nx</code> forces ZADD to only create new elements and not to update scores for elements that already exist.</p> <p><code>xx</code> forces ZADD to only update scores of elements that already exist. New elements will not be added.</p> <p><code>ch</code> modifies the return value to be the numbers of elements changed. Changed elements include new elements that were added and elements whose scores changed.</p> <p><code>incr</code> modifies ZADD to behave like ZINCRBY. In this mode only a single element/score pair can be specified and the score is the amount the existing score will be incremented by. When using this mode the return value of ZADD will be the new score of the element.</p> <p><code>LT</code> Only update existing elements if the new score is less than the current score. This flag doesn't prevent adding new elements.</p> <p><code>GT</code> Only update existing elements if the new score is greater than the current score. This flag doesn't prevent adding new elements.</p> <p>The return value of ZADD varies based on the mode specified. With no options, ZADD returns the number of new elements added to the sorted set.</p> <p><code>NX</code>, <code>LT</code>, and <code>GT</code> are mutually exclusive options.</p> <p>See: https://redis.io/commands/ZADD</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azcard","title":"azcard  <code>async</code>","text":"<pre><code>azcard(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the number of elements in the sorted set <code>name</code></p> <p>For more information see https://redis.io/commands/zcard</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azcount","title":"azcount  <code>async</code>","text":"<pre><code>azcount(\n    name: kvdb.types.generic.KeyT,\n    min: redis.typing.ZScoreBoundT,\n    max: redis.typing.ZScoreBoundT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the number of elements in the sorted set at key <code>name</code> with a score between <code>min</code> and <code>max</code>.</p> <p>For more information see https://redis.io/commands/zcount</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azdiff","title":"azdiff  <code>async</code>","text":"<pre><code>azdiff(\n    keys: redis.typing.KeysT, withscores: bool = False\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the difference between the first and all successive input sorted sets provided in <code>keys</code>.</p> <p>For more information see https://redis.io/commands/zdiff</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azdiffstore","title":"azdiffstore  <code>async</code>","text":"<pre><code>azdiffstore(\n    dest: kvdb.types.generic.KeyT, keys: redis.typing.KeysT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Computes the difference between the first and all successive input sorted sets provided in <code>keys</code> and stores the result in <code>dest</code>.</p> <p>For more information see https://redis.io/commands/zdiffstore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azincrby","title":"azincrby  <code>async</code>","text":"<pre><code>azincrby(\n    name: kvdb.types.generic.KeyT,\n    amount: float,\n    value: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Increment the score of <code>value</code> in sorted set <code>name</code> by <code>amount</code></p> <p>For more information see https://redis.io/commands/zincrby</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azinter","title":"azinter  <code>async</code>","text":"<pre><code>azinter(\n    keys: redis.typing.KeysT,\n    aggregate: typing.Union[str, None] = None,\n    withscores: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the intersect of multiple sorted sets specified by <code>keys</code>. With the <code>aggregate</code> option, it is possible to specify how the results of the union are aggregated. This option defaults to SUM, where the score of an element is summed across the inputs where it exists. When this option is set to either MIN or MAX, the resulting set will contain the minimum or maximum score of an element across the inputs where it exists.</p> <p>For more information see https://redis.io/commands/zinter</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azintercard","title":"azintercard  <code>async</code>","text":"<pre><code>azintercard(\n    numkeys: int, keys: typing.List[str], limit: int = 0\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Return the cardinality of the intersect of multiple sorted sets specified by <code>`keys</code>. When LIMIT provided (defaults to 0 and means unlimited), if the intersection cardinality reaches limit partway through the computation, the algorithm will exit and yield limit as the cardinality</p> <p>For more information see https://redis.io/commands/zintercard</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azinterstore","title":"azinterstore  <code>async</code>","text":"<pre><code>azinterstore(\n    dest: kvdb.types.generic.KeyT,\n    keys: typing.Union[\n        typing.Sequence[kvdb.types.generic.KeyT],\n        typing.Mapping[redis.typing.AnyKeyT, float],\n    ],\n    aggregate: typing.Union[str, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Intersect multiple sorted sets specified by <code>keys</code> into a new sorted set, <code>dest</code>. Scores in the destination will be aggregated based on the <code>aggregate</code>. This option defaults to SUM, where the score of an element is summed across the inputs where it exists. When this option is set to either MIN or MAX, the resulting set will contain the minimum or maximum score of an element across the inputs where it exists.</p> <p>For more information see https://redis.io/commands/zinterstore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azlexcount","title":"azlexcount  <code>async</code>","text":"<pre><code>azlexcount(name, min, max)\n</code></pre> <p>Return the number of items in the sorted set <code>name</code> between the lexicographical range <code>min</code> and <code>max</code>.</p> <p>For more information see https://redis.io/commands/zlexcount</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azmpop","title":"azmpop  <code>async</code>","text":"<pre><code>azmpop(\n    num_keys: int,\n    keys: typing.List[str],\n    min: typing.Optional[bool] = False,\n    max: typing.Optional[bool] = False,\n    count: typing.Optional[int] = 1,\n) -&gt; typing.Union[typing.Awaitable[list], list]\n</code></pre> <p>Pop <code>count</code> values (default 1) off of the first non-empty sorted set named in the <code>keys</code> list. For more information see https://redis.io/commands/zmpop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azmscore","title":"azmscore  <code>async</code>","text":"<pre><code>azmscore(\n    key: kvdb.types.generic.KeyT, members: typing.List[str]\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the scores associated with the specified members in the sorted set stored at key. <code>members</code> should be a list of the member name. Return type is a list of score. If the member does not exist, a None will be returned in corresponding position.</p> <p>For more information see https://redis.io/commands/zmscore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azpopmax","title":"azpopmax  <code>async</code>","text":"<pre><code>azpopmax(\n    name: kvdb.types.generic.KeyT,\n    count: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Remove and return up to <code>count</code> members with the highest scores from the sorted set <code>name</code>.</p> <p>For more information see https://redis.io/commands/zpopmax</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azpopmin","title":"azpopmin  <code>async</code>","text":"<pre><code>azpopmin(\n    name: kvdb.types.generic.KeyT,\n    count: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Remove and return up to <code>count</code> members with the lowest scores from the sorted set <code>name</code>.</p> <p>For more information see https://redis.io/commands/zpopmin</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azrandmember","title":"azrandmember  <code>async</code>","text":"<pre><code>azrandmember(\n    key: kvdb.types.generic.KeyT,\n    count: int = None,\n    withscores: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a random element from the sorted set value stored at key.</p> <p><code>count</code> if the argument is positive, return an array of distinct fields. If called with a negative count, the behavior changes and the command is allowed to return the same field multiple times. In this case, the number of returned fields is the absolute value of the specified count.</p> <p><code>withscores</code> The optional WITHSCORES modifier changes the reply so it includes the respective scores of the randomly selected elements from the sorted set.</p> <p>For more information see https://redis.io/commands/zrandmember</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azrange","title":"azrange  <code>async</code>","text":"<pre><code>azrange(\n    name: kvdb.types.generic.KeyT,\n    start: int,\n    end: int,\n    desc: bool = False,\n    withscores: bool = False,\n    score_cast_func: typing.Union[\n        kvdb.components.session.KVDBSession.type,\n        typing.Callable,\n    ] = ...,\n    byscore: bool = False,\n    bylex: bool = False,\n    offset: int = None,\n    num: int = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a range of values from sorted set <code>name</code> between <code>start</code> and <code>end</code> sorted in ascending order.</p> <p><code>start</code> and <code>end</code> can be negative, indicating the end of the range.</p> <p><code>desc</code> a boolean indicating whether to sort the results in reversed order.</p> <p><code>withscores</code> indicates to return the scores along with the values. The return type is a list of (value, score) pairs.</p> <p><code>score_cast_func</code> a callable used to cast the score return value.</p> <p><code>byscore</code> when set to True, returns the range of elements from the sorted set having scores equal or between <code>start</code> and <code>end</code>.</p> <p><code>bylex</code> when set to True, returns the range of elements from the sorted set between the <code>start</code> and <code>end</code> lexicographical closed range intervals. Valid <code>start</code> and <code>end</code> must start with ( or [, in order to specify whether the range interval is exclusive or inclusive, respectively.</p> <p><code>offset</code> and <code>num</code> are specified, then return a slice of the range. Can't be provided when using <code>bylex</code>.</p> <p>For more information see https://redis.io/commands/zrange</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azrangebylex","title":"azrangebylex  <code>async</code>","text":"<pre><code>azrangebylex(\n    name: kvdb.types.generic.KeyT,\n    min: redis.typing.EncodableT,\n    max: redis.typing.EncodableT,\n    start: typing.Union[int, None] = None,\n    num: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the lexicographical range of values from sorted set <code>name</code> between <code>min</code> and <code>max</code>.</p> <p>If <code>start</code> and <code>num</code> are specified, then return a slice of the range.</p> <p>For more information see https://redis.io/commands/zrangebylex</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azrangebyscore","title":"azrangebyscore  <code>async</code>","text":"<pre><code>azrangebyscore(\n    name: kvdb.types.generic.KeyT,\n    min: redis.typing.ZScoreBoundT,\n    max: redis.typing.ZScoreBoundT,\n    start: typing.Union[int, None] = None,\n    num: typing.Union[int, None] = None,\n    withscores: bool = False,\n    score_cast_func: typing.Union[\n        kvdb.components.session.KVDBSession.type,\n        typing.Callable,\n    ] = ...,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a range of values from the sorted set <code>name</code> with scores between <code>min</code> and <code>max</code>.</p> <p>If <code>start</code> and <code>num</code> are specified, then return a slice of the range.</p> <p><code>withscores</code> indicates to return the scores along with the values. The return type is a list of (value, score) pairs</p> <p>`score_cast_func`` a callable used to cast the score return value</p> <p>For more information see https://redis.io/commands/zrangebyscore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azrangestore","title":"azrangestore  <code>async</code>","text":"<pre><code>azrangestore(\n    dest: kvdb.types.generic.KeyT,\n    name: kvdb.types.generic.KeyT,\n    start: int,\n    end: int,\n    byscore: bool = False,\n    bylex: bool = False,\n    desc: bool = False,\n    offset: typing.Union[int, None] = None,\n    num: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Stores in <code>dest</code> the result of a range of values from sorted set <code>name</code> between <code>start</code> and <code>end</code> sorted in ascending order.</p> <p><code>start</code> and <code>end</code> can be negative, indicating the end of the range.</p> <p><code>byscore</code> when set to True, returns the range of elements from the sorted set having scores equal or between <code>start</code> and <code>end</code>.</p> <p><code>bylex</code> when set to True, returns the range of elements from the sorted set between the <code>start</code> and <code>end</code> lexicographical closed range intervals. Valid <code>start</code> and <code>end</code> must start with ( or [, in order to specify whether the range interval is exclusive or inclusive, respectively.</p> <p><code>desc</code> a boolean indicating whether to sort the results in reversed order.</p> <p><code>offset</code> and <code>num</code> are specified, then return a slice of the range. Can't be provided when using <code>bylex</code>.</p> <p>For more information see https://redis.io/commands/zrangestore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azrank","title":"azrank  <code>async</code>","text":"<pre><code>azrank(\n    name: kvdb.types.generic.KeyT,\n    value: redis.typing.EncodableT,\n    withscore: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a 0-based value indicating the rank of <code>value</code> in sorted set <code>name</code>. The optional WITHSCORE argument supplements the command's reply with the score of the element returned.</p> <p>For more information see https://redis.io/commands/zrank</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azrem","title":"azrem  <code>async</code>","text":"<pre><code>azrem(\n    name: kvdb.types.generic.KeyT,\n    *values: redis.typing.FieldT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Remove member <code>values</code> from sorted set <code>name</code></p> <p>For more information see https://redis.io/commands/zrem</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azremrangebylex","title":"azremrangebylex  <code>async</code>","text":"<pre><code>azremrangebylex(\n    name: kvdb.types.generic.KeyT,\n    min: redis.typing.EncodableT,\n    max: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Remove all elements in the sorted set <code>name</code> between the lexicographical range specified by <code>min</code> and <code>max</code>.</p> <p>Returns the number of elements removed.</p> <p>For more information see https://redis.io/commands/zremrangebylex</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azremrangebyrank","title":"azremrangebyrank  <code>async</code>","text":"<pre><code>azremrangebyrank(\n    name: kvdb.types.generic.KeyT, min: int, max: int\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Remove all elements in the sorted set <code>name</code> with ranks between <code>min</code> and <code>max</code>. Values are 0-based, ordered from smallest score to largest. Values can be negative indicating the highest scores. Returns the number of elements removed</p> <p>For more information see https://redis.io/commands/zremrangebyrank</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azremrangebyscore","title":"azremrangebyscore  <code>async</code>","text":"<pre><code>azremrangebyscore(\n    name: kvdb.types.generic.KeyT,\n    min: redis.typing.ZScoreBoundT,\n    max: redis.typing.ZScoreBoundT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Remove all elements in the sorted set <code>name</code> with scores between <code>min</code> and <code>max</code>. Returns the number of elements removed.</p> <p>For more information see https://redis.io/commands/zremrangebyscore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azrevrange","title":"azrevrange  <code>async</code>","text":"<pre><code>azrevrange(\n    name: kvdb.types.generic.KeyT,\n    start: int,\n    end: int,\n    withscores: bool = False,\n    score_cast_func: typing.Union[\n        kvdb.components.session.KVDBSession.type,\n        typing.Callable,\n    ] = ...,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a range of values from sorted set <code>name</code> between <code>start</code> and <code>end</code> sorted in descending order.</p> <p><code>start</code> and <code>end</code> can be negative, indicating the end of the range.</p> <p><code>withscores</code> indicates to return the scores along with the values The return type is a list of (value, score) pairs</p> <p><code>score_cast_func</code> a callable used to cast the score return value</p> <p>For more information see https://redis.io/commands/zrevrange</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azrevrangebylex","title":"azrevrangebylex  <code>async</code>","text":"<pre><code>azrevrangebylex(\n    name: kvdb.types.generic.KeyT,\n    max: redis.typing.EncodableT,\n    min: redis.typing.EncodableT,\n    start: typing.Union[int, None] = None,\n    num: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the reversed lexicographical range of values from sorted set <code>name</code> between <code>max</code> and <code>min</code>.</p> <p>If <code>start</code> and <code>num</code> are specified, then return a slice of the range.</p> <p>For more information see https://redis.io/commands/zrevrangebylex</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azrevrangebyscore","title":"azrevrangebyscore  <code>async</code>","text":"<pre><code>azrevrangebyscore(\n    name: kvdb.types.generic.KeyT,\n    max: redis.typing.ZScoreBoundT,\n    min: redis.typing.ZScoreBoundT,\n    start: typing.Union[int, None] = None,\n    num: typing.Union[int, None] = None,\n    withscores: bool = False,\n    score_cast_func: typing.Union[\n        kvdb.components.session.KVDBSession.type,\n        typing.Callable,\n    ] = ...,\n)\n</code></pre> <p>Return a range of values from the sorted set <code>name</code> with scores between <code>min</code> and <code>max</code> in descending order.</p> <p>If <code>start</code> and <code>num</code> are specified, then return a slice of the range.</p> <p><code>withscores</code> indicates to return the scores along with the values. The return type is a list of (value, score) pairs</p> <p><code>score_cast_func</code> a callable used to cast the score return value</p> <p>For more information see https://redis.io/commands/zrevrangebyscore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azrevrank","title":"azrevrank  <code>async</code>","text":"<pre><code>azrevrank(\n    name: kvdb.types.generic.KeyT,\n    value: redis.typing.EncodableT,\n    withscore: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a 0-based value indicating the descending rank of <code>value</code> in sorted set <code>name</code>. The optional <code>withscore</code> argument supplements the command's reply with the score of the element returned.</p> <p>For more information see https://redis.io/commands/zrevrank</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azscan","title":"azscan  <code>async</code>","text":"<pre><code>azscan(\n    name: kvdb.types.generic.KeyT,\n    cursor: int = 0,\n    match: typing.Union[\n        kvdb.types.generic.PatternT, None\n    ] = None,\n    count: typing.Union[int, None] = None,\n    score_cast_func: typing.Union[\n        kvdb.components.session.KVDBSession.type,\n        typing.Callable,\n    ] = ...,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Incrementally return lists of elements in a sorted set. Also return a cursor indicating the scan position.</p> <p><code>match</code> allows for filtering the keys by pattern</p> <p><code>count</code> allows for hint the minimum number of returns</p> <p><code>score_cast_func</code> a callable used to cast the score return value</p> <p>For more information see https://redis.io/commands/zscan</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azscan_iter","title":"azscan_iter  <code>async</code>","text":"<pre><code>azscan_iter(\n    name: kvdb.types.generic.KeyT,\n    match: typing.Union[\n        kvdb.types.generic.PatternT, None\n    ] = None,\n    count: typing.Union[int, None] = None,\n    score_cast_func: typing.Union[\n        kvdb.components.session.KVDBSession.type,\n        typing.Callable,\n    ] = ...,\n) -&gt; typing.AsyncIterator\n</code></pre> <p>Make an iterator using the ZSCAN command so that the client doesn't need to remember the cursor position.</p> <p><code>match</code> allows for filtering the keys by pattern</p> <p><code>count</code> allows for hint the minimum number of returns</p> <p><code>score_cast_func</code> a callable used to cast the score return value</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azscore","title":"azscore  <code>async</code>","text":"<pre><code>azscore(\n    name: kvdb.types.generic.KeyT,\n    value: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the score of element <code>value</code> in sorted set <code>name</code></p> <p>For more information see https://redis.io/commands/zscore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azunion","title":"azunion  <code>async</code>","text":"<pre><code>azunion(\n    keys: typing.Union[\n        typing.Sequence[kvdb.types.generic.KeyT],\n        typing.Mapping[redis.typing.AnyKeyT, float],\n    ],\n    aggregate: typing.Union[str, None] = None,\n    withscores: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the union of multiple sorted sets specified by <code>keys</code>. <code>keys</code> can be provided as dictionary of keys and their weights. Scores will be aggregated based on the <code>aggregate</code>, or SUM if none is provided.</p> <p>For more information see https://redis.io/commands/zunion</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.azunionstore","title":"azunionstore  <code>async</code>","text":"<pre><code>azunionstore(\n    dest: kvdb.types.generic.KeyT,\n    keys: typing.Union[\n        typing.Sequence[kvdb.types.generic.KeyT],\n        typing.Mapping[redis.typing.AnyKeyT, float],\n    ],\n    aggregate: typing.Union[str, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Union multiple sorted sets specified by <code>keys</code> into a new sorted set, <code>dest</code>. Scores in the destination will be aggregated based on the <code>aggregate</code>, or SUM if none is provided.</p> <p>For more information see https://redis.io/commands/zunionstore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.bgrewriteaof","title":"bgrewriteaof","text":"<pre><code>bgrewriteaof(**kwargs)\n</code></pre> <p>Tell the Redis server to rewrite the AOF file from data in memory.</p> <p>For more information see https://redis.io/commands/bgrewriteaof</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.bgsave","title":"bgsave","text":"<pre><code>bgsave(\n    schedule: bool = True, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Tell the Redis server to save its data to disk.  Unlike save(), this method is asynchronous and returns immediately.</p> <p>For more information see https://redis.io/commands/bgsave</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.bitcount","title":"bitcount","text":"<pre><code>bitcount(\n    key: kvdb.types.generic.KeyT,\n    start: typing.Union[int, None] = None,\n    end: typing.Union[int, None] = None,\n    mode: typing.Optional[str] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the count of set bits in the value of <code>key</code>.  Optional <code>start</code> and <code>end</code> parameters indicate which bytes to consider</p> <p>For more information see https://redis.io/commands/bitcount</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.bitfield","title":"bitfield","text":"<pre><code>bitfield(\n    key: kvdb.types.generic.KeyT,\n    default_overflow: typing.Union[str, None] = None,\n) -&gt; redis.commands.core.BitFieldOperation\n</code></pre> <p>Return a BitFieldOperation instance to conveniently construct one or more bitfield operations on <code>key</code>.</p> <p>For more information see https://redis.io/commands/bitfield</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.bitfield_ro","title":"bitfield_ro","text":"<pre><code>bitfield_ro(\n    key: kvdb.types.generic.KeyT,\n    encoding: str,\n    offset: redis.typing.BitfieldOffsetT,\n    items: typing.Optional[list] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return an array of the specified bitfield values where the first value is found using <code>encoding</code> and <code>offset</code> parameters and remaining values are result of corresponding encoding/offset pairs in optional list <code>items</code> Read-only variant of the BITFIELD command.</p> <p>For more information see https://redis.io/commands/bitfield_ro</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.bitop","title":"bitop","text":"<pre><code>bitop(\n    operation: str,\n    dest: kvdb.types.generic.KeyT,\n    *keys: kvdb.types.generic.KeyT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Perform a bitwise operation using <code>operation</code> between <code>keys</code> and store the result in <code>dest</code>.</p> <p>For more information see https://redis.io/commands/bitop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.bitpos","title":"bitpos","text":"<pre><code>bitpos(\n    key: kvdb.types.generic.KeyT,\n    bit: int,\n    start: typing.Union[int, None] = None,\n    end: typing.Union[int, None] = None,\n    mode: typing.Optional[str] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the position of the first bit set to 1 or 0 in a string. <code>start</code> and <code>end</code> defines search range. The range is interpreted as a range of bytes and not a range of bits, so start=0 and end=2 means to look at the first three bytes.</p> <p>For more information see https://redis.io/commands/bitpos</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.blmove","title":"blmove","text":"<pre><code>blmove(\n    first_list: str,\n    second_list: str,\n    timeout: int,\n    src: str = \"LEFT\",\n    dest: str = \"RIGHT\",\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Blocking version of lmove.</p> <p>For more information see https://redis.io/commands/blmove</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.blmpop","title":"blmpop","text":"<pre><code>blmpop(\n    timeout: float,\n    numkeys: int,\n    *args: typing.List[str],\n    direction: str,\n    count: typing.Optional[int] = 1\n) -&gt; typing.Optional[list]\n</code></pre> <p>Pop <code>count</code> values (default 1) from first non-empty in the list of provided key names.</p> <p>When all lists are empty this command blocks the connection until another client pushes to it or until the timeout, timeout of 0 blocks indefinitely</p> <p>For more information see https://redis.io/commands/blmpop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.blpop","title":"blpop","text":"<pre><code>blpop(\n    keys: typing.List, timeout: typing.Optional[int] = 0\n) -&gt; typing.Union[typing.Awaitable[list], list]\n</code></pre> <p>LPOP a value off of the first non-empty list named in the <code>keys</code> list.</p> <p>If none of the lists in <code>keys</code> has a value to LPOP, then block for <code>timeout</code> seconds, or until a value gets pushed on to one of the lists.</p> <p>If timeout is 0, then block indefinitely.</p> <p>For more information see https://redis.io/commands/blpop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.brpop","title":"brpop","text":"<pre><code>brpop(\n    keys: typing.List, timeout: typing.Optional[int] = 0\n) -&gt; typing.Union[typing.Awaitable[list], list]\n</code></pre> <p>RPOP a value off of the first non-empty list named in the <code>keys</code> list.</p> <p>If none of the lists in <code>keys</code> has a value to RPOP, then block for <code>timeout</code> seconds, or until a value gets pushed on to one of the lists.</p> <p>If timeout is 0, then block indefinitely.</p> <p>For more information see https://redis.io/commands/brpop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.brpoplpush","title":"brpoplpush","text":"<pre><code>brpoplpush(\n    src: str, dst: str, timeout: typing.Optional[int] = 0\n) -&gt; typing.Union[\n    typing.Awaitable[typing.Optional[str]],\n    typing.Optional[str],\n]\n</code></pre> <p>Pop a value off the tail of <code>src</code>, push it on the head of <code>dst</code> and then return it.</p> <p>This command blocks until a value is in <code>src</code> or until <code>timeout</code> seconds elapse, whichever is first. A <code>timeout</code> value of 0 blocks forever.</p> <p>For more information see https://redis.io/commands/brpoplpush</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.bzmpop","title":"bzmpop","text":"<pre><code>bzmpop(\n    timeout: float,\n    numkeys: int,\n    keys: typing.List[str],\n    min: typing.Optional[bool] = False,\n    max: typing.Optional[bool] = False,\n    count: typing.Optional[int] = 1,\n) -&gt; typing.Optional[list]\n</code></pre> <p>Pop <code>count</code> values (default 1) off of the first non-empty sorted set named in the <code>keys</code> list.</p> <p>If none of the sorted sets in <code>keys</code> has a value to pop, then block for <code>timeout</code> seconds, or until a member gets added to one of the sorted sets.</p> <p>If timeout is 0, then block indefinitely.</p> <p>For more information see https://redis.io/commands/bzmpop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.bzpopmax","title":"bzpopmax","text":"<pre><code>bzpopmax(\n    keys: redis.typing.KeysT,\n    timeout: redis.typing.TimeoutSecT = 0,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>ZPOPMAX a value off of the first non-empty sorted set named in the <code>keys</code> list.</p> <p>If none of the sorted sets in <code>keys</code> has a value to ZPOPMAX, then block for <code>timeout</code> seconds, or until a member gets added to one of the sorted sets.</p> <p>If timeout is 0, then block indefinitely.</p> <p>For more information see https://redis.io/commands/bzpopmax</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.bzpopmin","title":"bzpopmin","text":"<pre><code>bzpopmin(\n    keys: redis.typing.KeysT,\n    timeout: redis.typing.TimeoutSecT = 0,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>ZPOPMIN a value off of the first non-empty sorted set named in the <code>keys</code> list.</p> <p>If none of the sorted sets in <code>keys</code> has a value to ZPOPMIN, then block for <code>timeout</code> seconds, or until a member gets added to one of the sorted sets.</p> <p>If timeout is 0, then block indefinitely.</p> <p>For more information see https://redis.io/commands/bzpopmin</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Clears the current database</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def clear(self):\n    \"\"\"\n    Clears the current database\n    \"\"\"\n    return self.client.flushdb()\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_getname","title":"client_getname","text":"<pre><code>client_getname(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the current connection name</p> <p>For more information see https://redis.io/commands/client-getname</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_getredir","title":"client_getredir","text":"<pre><code>client_getredir(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the ID (an integer) of the client to whom we are redirecting tracking notifications.</p> <p>see: https://redis.io/commands/client-getredir</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_id","title":"client_id","text":"<pre><code>client_id(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the current connection id</p> <p>For more information see https://redis.io/commands/client-id</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_info","title":"client_info","text":"<pre><code>client_info(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns information and statistics about the current client connection.</p> <p>For more information see https://redis.io/commands/client-info</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_kill","title":"client_kill","text":"<pre><code>client_kill(\n    address: str, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Disconnects the client at <code>address</code> (ip:port)</p> <p>For more information see https://redis.io/commands/client-kill</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_kill_filter","title":"client_kill_filter","text":"<pre><code>client_kill_filter(\n    _id: typing.Union[str, None] = None,\n    _type: typing.Union[str, None] = None,\n    addr: typing.Union[str, None] = None,\n    skipme: typing.Union[bool, None] = None,\n    laddr: typing.Union[bool, None] = None,\n    user: str = None,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Disconnects client(s) using a variety of filter options :param _id: Kills a client by its unique ID field :param _type: Kills a client by type where type is one of 'normal', 'master', 'slave' or 'pubsub' :param addr: Kills a client by its 'address:port' :param skipme: If True, then the client calling the command will not get killed even if it is identified by one of the filter options. If skipme is not provided, the server defaults to skipme=True :param laddr: Kills a client by its 'local (bind) address:port' :param user: Kills a client for a specific user name</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_list","title":"client_list","text":"<pre><code>client_list(\n    _type: typing.Union[str, None] = None,\n    client_id: typing.List[redis.typing.EncodableT] = [],\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a list of currently connected clients. If type of client specified, only that type will be returned.</p> <p>:param _type: optional. one of the client types (normal, master,  replica, pubsub) :param client_id: optional. a list of client ids</p> <p>For more information see https://redis.io/commands/client-list</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_no_evict","title":"client_no_evict","text":"<pre><code>client_no_evict(\n    mode: str,\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Sets the client eviction mode for the current connection.</p> <p>For more information see https://redis.io/commands/client-no-evict</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_no_touch","title":"client_no_touch","text":"<pre><code>client_no_touch(\n    mode: str,\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_no_touch--the-command-controls-whether-commands-sent-by-the-client-will-alter","title":"The command controls whether commands sent by the client will alter","text":""},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_no_touch--the-lrulfu-of-the-keys-they-access","title":"the LRU/LFU of the keys they access.","text":""},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_no_touch--when-turned-on-the-current-client-will-not-change-lfulru-stats","title":"When turned on, the current client will not change LFU/LRU stats,","text":""},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_no_touch--unless-it-sends-the-touch-command","title":"unless it sends the TOUCH command.","text":"<p>For more information see https://redis.io/commands/client-no-touch</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_pause","title":"client_pause","text":"<pre><code>client_pause(\n    timeout: int, all: bool = True, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Suspend all the Redis clients for the specified amount of time.</p> <p>For more information see https://redis.io/commands/client-pause</p> <p>:param timeout: milliseconds to pause clients :param all: If true (default) all client commands are blocked. otherwise, clients are only blocked if they attempt to execute a write command. For the WRITE mode, some commands have special behavior: EVAL/EVALSHA: Will block client for all scripts. PUBLISH: Will block client. PFCOUNT: Will block client. WAIT: Acknowledgments will be delayed, so this command will appear blocked.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_reply","title":"client_reply","text":"<pre><code>client_reply(\n    reply: typing.Union[\n        typing.Literal[\"ON\"],\n        typing.Literal[\"OFF\"],\n        typing.Literal[\"SKIP\"],\n    ],\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Enable and disable redis server replies.</p> <p><code>reply</code> Must be ON OFF or SKIP, ON - The default most with server replies to commands OFF - Disable server responses to commands SKIP - Skip the response of the immediately following command.</p> <p>Note: When setting OFF or SKIP replies, you will need a client object with a timeout specified in seconds, and will need to catch the TimeoutError. The test_client_reply unit test illustrates this, and conftest.py has a client with a timeout.</p> <p>See https://redis.io/commands/client-reply</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_setinfo","title":"client_setinfo","text":"<pre><code>client_setinfo(\n    attr: str, value: str, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Sets the current connection library name or version For mor information see https://redis.io/commands/client-setinfo</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_setname","title":"client_setname","text":"<pre><code>client_setname(\n    name: str, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Sets the current connection name</p> <p>For more information see https://redis.io/commands/client-setname</p> <p>.. note::    This method sets client name only for current connection.</p> <p>If you want to set a common name for all connections managed    by this client, use <code>client_name</code> constructor argument.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_tracking","title":"client_tracking","text":"<pre><code>client_tracking(\n    on: bool = True,\n    clientid: typing.Union[int, None] = None,\n    prefix: typing.Sequence[kvdb.types.generic.KeyT] = [],\n    bcast: bool = False,\n    optin: bool = False,\n    optout: bool = False,\n    noloop: bool = False,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Enables the tracking feature of the Redis server, that is used for server assisted client side caching.</p> <p><code>on</code> indicate for tracking on or tracking off. The dafualt is on.</p> <p><code>clientid</code> send invalidation messages to the connection with the specified ID.</p> <p><code>bcast</code> enable tracking in broadcasting mode. In this mode invalidation messages are reported for all the prefixes specified, regardless of the keys requested by the connection.</p> <p><code>optin</code>  when broadcasting is NOT active, normally don't track keys in read only commands, unless they are called immediately after a CLIENT CACHING yes command.</p> <p><code>optout</code> when broadcasting is NOT active, normally track keys in read only commands, unless they are called immediately after a CLIENT CACHING no command.</p> <p><code>noloop</code> don't send notifications about keys modified by this connection itself.</p> <p><code>prefix</code>  for broadcasting, register a given key prefix, so that notifications will be provided only for keys starting with this string.</p> <p>See https://redis.io/commands/client-tracking</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_tracking_off","title":"client_tracking_off","text":"<pre><code>client_tracking_off(\n    clientid: typing.Union[int, None] = None,\n    prefix: typing.Sequence[kvdb.types.generic.KeyT] = [],\n    bcast: bool = False,\n    optin: bool = False,\n    optout: bool = False,\n    noloop: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Turn off the tracking mode. For more information about the options look at client_tracking func.</p> <p>See https://redis.io/commands/client-tracking</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_tracking_on","title":"client_tracking_on","text":"<pre><code>client_tracking_on(\n    clientid: typing.Union[int, None] = None,\n    prefix: typing.Sequence[kvdb.types.generic.KeyT] = [],\n    bcast: bool = False,\n    optin: bool = False,\n    optout: bool = False,\n    noloop: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Turn on the tracking mode. For more information about the options look at client_tracking func.</p> <p>See https://redis.io/commands/client-tracking</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_trackinginfo","title":"client_trackinginfo","text":"<pre><code>client_trackinginfo(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the information about the current client connection's use of the server assisted client side cache.</p> <p>See https://redis.io/commands/client-trackinginfo</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_unblock","title":"client_unblock","text":"<pre><code>client_unblock(\n    client_id: int, error: bool = False, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Unblocks a connection by its client id. If <code>error</code> is True, unblocks the client with a special error message. If <code>error</code> is False (default), the client is unblocked using the regular timeout mechanism.</p> <p>For more information see https://redis.io/commands/client-unblock</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.client_unpause","title":"client_unpause","text":"<pre><code>client_unpause(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Unpause all redis clients</p> <p>For more information see https://redis.io/commands/client-unpause</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.close","title":"close","text":"<pre><code>close(\n    close_pool: bool = False,\n    force: typing.Optional[bool] = None,\n    raise_errors: bool = False,\n)\n</code></pre> <p>Close the session</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def close(self, close_pool: bool = False, force: Optional[bool] = None, raise_errors: bool = False):\n    \"\"\"\n    Close the session\n    \"\"\"\n    self.close_locks(force=force, raise_errors=raise_errors)\n    if self.state.pubsub is not None:\n        self.state.pubsub.close()\n        self.state.pubsub = None\n\n    if self.state.client is not None:\n        self.state.client.close()\n        if close_pool:\n            self.state.client.connection_pool.disconnect(raise_errors = raise_errors)\n        self.state.client = None\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.close_locks","title":"close_locks","text":"<pre><code>close_locks(\n    names: typing.Optional[\n        typing.Union[typing.List[str], str]\n    ] = None,\n    force: typing.Optional[bool] = False,\n    raise_errors: typing.Optional[bool] = False,\n)\n</code></pre> <p>Closes the locks that are currently managed by the session</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def close_locks(\n    self, \n    names: Optional[Union[List[str], str]] = None,\n    force: Optional[bool] = False,\n    raise_errors: Optional[bool] = False,\n):\n    \"\"\"\n    Closes the locks that are currently managed by the session\n    \"\"\"\n    if names is None: names = list(self.state.locks.keys())\n    if isinstance(names, str): names = [names]\n    for name in names:\n        if name in self.state.locks:\n            self.state.locks[name].release(force = force, raise_errors = raise_errors)\n            del self.state.locks[name]\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.command_docs","title":"command_docs","text":"<pre><code>command_docs(*args) -&gt; None\n</code></pre> <p>This function throws a NotImplementedError since it is intentionally not supported.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.command_getkeysandflags","title":"command_getkeysandflags","text":"<pre><code>command_getkeysandflags(\n    *args: typing.List[str],\n) -&gt; typing.List[typing.Union[str, typing.List[str]]]\n</code></pre> <p>Returns array of keys from a full Redis command and their usage flags.</p> <p>For more information see https://redis.io/commands/command-getkeysandflags</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.command_list","title":"command_list","text":"<pre><code>command_list(\n    module: typing.Optional[str] = None,\n    category: typing.Optional[str] = None,\n    pattern: typing.Optional[str] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return an array of the server's command names. You can use one of the following filters: <code>module</code>: get the commands that belong to the module <code>category</code>: get the commands in the ACL category <code>pattern</code>: get the commands that match the given pattern</p> <p>For more information see https://redis.io/commands/command-list/</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.config_get","title":"config_get","text":"<pre><code>config_get(\n    pattern: kvdb.types.generic.PatternT = \"*\",\n    *args: typing.List[kvdb.types.generic.PatternT],\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a dictionary of configuration based on the <code>pattern</code></p> <p>For more information see https://redis.io/commands/config-get</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.config_resetstat","title":"config_resetstat","text":"<pre><code>config_resetstat(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Reset runtime statistics</p> <p>For more information see https://redis.io/commands/config-resetstat</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.config_rewrite","title":"config_rewrite","text":"<pre><code>config_rewrite(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Rewrite config file with the minimal change to reflect running config.</p> <p>For more information see https://redis.io/commands/config-rewrite</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.config_set","title":"config_set","text":"<pre><code>config_set(\n    name: kvdb.types.generic.KeyT,\n    value: redis.typing.EncodableT,\n    *args: typing.List[\n        typing.Union[\n            kvdb.types.generic.KeyT, redis.typing.EncodableT\n        ]\n    ],\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set config item <code>name</code> with <code>value</code></p> <p>For more information see https://redis.io/commands/config-set</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.copy","title":"copy","text":"<pre><code>copy(\n    source: str,\n    destination: str,\n    destination_db: typing.Union[str, None] = None,\n    replace: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Copy the value stored in the <code>source</code> key to the <code>destination</code> key.</p> <p><code>destination_db</code> an alternative destination database. By default, the <code>destination</code> key is created in the source Redis database.</p> <p><code>replace</code> whether the <code>destination</code> key should be removed before copying the value to it. By default, the value is not copied if the <code>destination</code> key already exists.</p> <p>For more information see https://redis.io/commands/copy</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.create_persistence","title":"create_persistence","text":"<pre><code>create_persistence(\n    name: typing.Optional[str] = None,\n    base_key: typing.Optional[str] = None,\n    **kwargs\n) -&gt; lzl.io.persistence.PersistentDict\n</code></pre> <p>Create a new persistence instance</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def create_persistence(\n    self,\n    name: Optional[str] = None,\n    base_key: Optional[str] = None,\n    **kwargs,\n) -&gt; 'PersistentDict':\n    \"\"\"\n    Create a new persistence instance\n    \"\"\"\n    # name = name or self.name\n    # if name in self._persistence_ctx:\n    #     return self._persistence_ctx[name]\n\n    from .persistence import KVDBStatefulBackend\n    persistence_config = self.settings.persistence.model_dump(exclude_none = True)\n    persistence_kwargs = self.settings.persistence.extract_kwargs(_prefix = 'persistence_', _exclude_none = True, **self._kwargs)\n    if persistence_kwargs: persistence_config.update(persistence_kwargs)\n    if 'name' not in persistence_config: persistence_config['name'] = self.name\n    if base_key is not None: persistence_config['base_key'] = base_key\n    persistence_config.update(kwargs)\n    base_key = persistence_config.get('base_key')\n    if base_key in self._persistence_ctx:\n        return self._persistence_ctx[base_key]\n    p = KVDBStatefulBackend.as_persistent_dict(\n        session = self,\n        **persistence_config,\n    )\n    self._persistence_ctx[base_key] = p\n    return p\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.dbsize","title":"dbsize","text":"<pre><code>dbsize(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the number of keys in the current database</p> <p>For more information see https://redis.io/commands/dbsize</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.debug_object","title":"debug_object","text":"<pre><code>debug_object(\n    key: kvdb.types.generic.KeyT, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns version specific meta information about a given key</p> <p>For more information see https://redis.io/commands/debug-object</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.decrby","title":"decrby","text":"<pre><code>decrby(\n    name: kvdb.types.generic.KeyT, amount: int = 1\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Decrements the value of <code>key</code> by <code>amount</code>.  If no key exists, the value will be initialized as 0 - <code>amount</code></p> <p>For more information see https://redis.io/commands/decrby</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.delete","title":"delete","text":"<pre><code>delete(\n    *names: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Delete one or more keys specified by <code>names</code></p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.delitem","title":"delitem","text":"<pre><code>delitem(key: kvdb.types.generic.KeyT) -&gt; None\n</code></pre> <p>[Dict] Deletes the key</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def delitem(\n    self,\n    key: KeyT,\n) -&gt; None:\n    \"\"\"\n    [Dict] Deletes the key\n    \"\"\"\n    return self.persistence.delete(key)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.disable_serialization","title":"disable_serialization","text":"<pre><code>disable_serialization(\n    decode_responses: typing.Optional[bool] = None,\n)\n</code></pre> <p>Disable Serialization in the Encoder</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def disable_serialization(self, decode_responses: Optional[bool] = None):\n    \"\"\"\n    Disable Serialization in the Encoder\n    \"\"\"\n    self.encoder.disable_serialization(decode_responses=decode_responses)\n    self.pool.disable_serialization(decode_responses=decode_responses)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.dump","title":"dump","text":"<pre><code>dump(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a serialized version of the value stored at the specified key. If key does not exist a nil bulk reply is returned.</p> <p>For more information see https://redis.io/commands/dump</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.echo","title":"echo","text":"<pre><code>echo(\n    value: redis.typing.EncodableT, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Echo the string back from the server</p> <p>For more information see https://redis.io/commands/echo</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.enable_serialization","title":"enable_serialization","text":"<pre><code>enable_serialization(\n    serializer: typing.Optional[\n        kvdb.io.serializers.SerializerT\n    ] = None,\n    decode_responses: typing.Optional[bool] = None,\n)\n</code></pre> <p>Enable Serialization in the Encoder</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def enable_serialization(self, serializer: Optional['SerializerT'] = None, decode_responses: Optional[bool] = None):\n    \"\"\"\n    Enable Serialization in the Encoder\n    \"\"\"\n    if serializer and isinstance(serializer, str):\n        serializer = settings.client_config.get_serializer(serializer=serializer)\n\n    self.encoder.enable_serialization(serializer = serializer, decode_responses = decode_responses)\n    self.pool.enable_serialization(serializer = serializer, decode_responses = decode_responses)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.eval","title":"eval","text":"<pre><code>eval(\n    script: str, numkeys: int, *keys_and_args: list\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Execute the Lua <code>script</code>, specifying the <code>numkeys</code> the script will touch and the key names and argument values in <code>keys_and_args</code>. Returns the result of the script.</p> <p>In practice, use the object returned by <code>register_script</code>. This function exists purely for Redis API completion.</p> <p>For more information see  https://redis.io/commands/eval</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.eval_ro","title":"eval_ro","text":"<pre><code>eval_ro(\n    script: str, numkeys: int, *keys_and_args: list\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>The read-only variant of the EVAL command</p> <p>Execute the read-only Lua <code>script</code> specifying the <code>numkeys</code> the script will touch and the key names and argument values in <code>keys_and_args</code>. Returns the result of the script.</p> <p>For more information see  https://redis.io/commands/eval_ro</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.evalsha","title":"evalsha","text":"<pre><code>evalsha(\n    sha: str, numkeys: int, *keys_and_args: list\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Use the <code>sha</code> to execute a Lua script already registered via EVAL or SCRIPT LOAD. Specify the <code>numkeys</code> the script will touch and the key names and argument values in <code>keys_and_args</code>. Returns the result of the script.</p> <p>In practice, use the object returned by <code>register_script</code>. This function exists purely for Redis API completion.</p> <p>For more information see  https://redis.io/commands/evalsha</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.evalsha_ro","title":"evalsha_ro","text":"<pre><code>evalsha_ro(\n    sha: str, numkeys: int, *keys_and_args: list\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>The read-only variant of the EVALSHA command</p> <p>Use the <code>sha</code> to execute a read-only Lua script already registered via EVAL or SCRIPT LOAD. Specify the <code>numkeys</code> the script will touch and the key names and argument values in <code>keys_and_args</code>. Returns the result of the script.</p> <p>For more information see  https://redis.io/commands/evalsha_ro</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.execute_command","title":"execute_command","text":"<pre><code>execute_command(\n    *args: typing.Any, **options: typing.Any\n) -&gt; typing.Any\n</code></pre> <p>Execute a command and return a parsed response</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def execute_command(self, *args: Any, **options: Any) -&gt; Any:\n    \"\"\"\n    Execute a command and return a parsed response\n    \"\"\"\n    return self.client.execute_command(*args, **options)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.exists","title":"exists","text":"<pre><code>exists(\n    *names: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the number of <code>names</code> that exist</p> <p>For more information see https://redis.io/commands/exists</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.expire","title":"expire","text":"<pre><code>expire(\n    name: kvdb.types.generic.KeyT,\n    time: kvdb.types.generic.ExpiryT,\n    nx: bool = False,\n    xx: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set an expire flag on key <code>name</code> for <code>time</code> seconds with given <code>option</code>. <code>time</code> can be represented by an integer or a Python timedelta object.</p> Valid options are <p>NX -&gt; Set expiry only when the key has no expiry XX -&gt; Set expiry only when the key has an existing expiry GT -&gt; Set expiry only when the new expiry is greater than current one LT -&gt; Set expiry only when the new expiry is less than current one</p> <p>For more information see https://redis.io/commands/expire</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.expireat","title":"expireat","text":"<pre><code>expireat(\n    name: kvdb.types.generic.KeyT,\n    when: kvdb.types.generic.AbsExpiryT,\n    nx: bool = False,\n    xx: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set an expire flag on key <code>name</code> with given <code>option</code>. <code>when</code> can be represented as an integer indicating unix time or a Python datetime object.</p> Valid options are <p>-&gt; NX -- Set expiry only when the key has no expiry -&gt; XX -- Set expiry only when the key has an existing expiry -&gt; GT -- Set expiry only when the new expiry is greater than current one -&gt; LT -- Set expiry only when the new expiry is less than current one</p> <p>For more information see https://redis.io/commands/expireat</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.expiretime","title":"expiretime","text":"<pre><code>expiretime(key: str) -&gt; int\n</code></pre> <p>Returns the absolute Unix timestamp (since January 1, 1970) in seconds at which the given key will expire.</p> <p>For more information see https://redis.io/commands/expiretime</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.failover","title":"failover","text":"<pre><code>failover() -&gt; None\n</code></pre> <p>This function throws a NotImplementedError since it is intentionally not supported.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.fcall","title":"fcall","text":"<pre><code>fcall(\n    function,\n    numkeys: int,\n    *keys_and_args: typing.Optional[typing.List]\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Invoke a function.</p> <p>For more information see https://redis.io/commands/fcall</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.fcall_ro","title":"fcall_ro","text":"<pre><code>fcall_ro(\n    function,\n    numkeys: int,\n    *keys_and_args: typing.Optional[typing.List]\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>This is a read-only variant of the FCALL command that cannot execute commands that modify data.</p> <p>For more information see https://redis.io/commands/fcal_ro</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.flushall","title":"flushall","text":"<pre><code>flushall(\n    asynchronous: bool = False, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Delete all keys in all databases on the current host.</p> <p><code>asynchronous</code> indicates whether the operation is executed asynchronously by the server.</p> <p>For more information see https://redis.io/commands/flushall</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.flushdb","title":"flushdb","text":"<pre><code>flushdb(\n    asynchronous: bool = False, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Delete all keys in the current database.</p> <p><code>asynchronous</code> indicates whether the operation is executed asynchronously by the server.</p> <p>For more information see https://redis.io/commands/flushdb</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.function_delete","title":"function_delete","text":"<pre><code>function_delete(\n    library: str,\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Delete the library called <code>library</code> and all its functions.</p> <p>For more information see https://redis.io/commands/function-delete</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.function_dump","title":"function_dump","text":"<pre><code>function_dump() -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Return the serialized payload of loaded libraries.</p> <p>For more information see https://redis.io/commands/function-dump</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.function_flush","title":"function_flush","text":"<pre><code>function_flush(\n    mode: str = \"SYNC\",\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Deletes all the libraries.</p> <p>For more information see https://redis.io/commands/function-flush</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.function_kill","title":"function_kill","text":"<pre><code>function_kill() -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Kill a function that is currently executing.</p> <p>For more information see https://redis.io/commands/function-kill</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.function_list","title":"function_list","text":"<pre><code>function_list(\n    library: typing.Optional[str] = \"*\",\n    withcode: typing.Optional[bool] = False,\n) -&gt; typing.Union[\n    typing.Awaitable[typing.List], typing.List\n]\n</code></pre> <p>Return information about the functions and libraries. :param library: pecify a pattern for matching library names :param withcode: cause the server to include the libraries source  implementation in the reply</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.function_load","title":"function_load","text":"<pre><code>function_load(\n    code: str, replace: typing.Optional[bool] = False\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Load a library to Redis. :param code: the source code (must start with Shebang statement that provides a metadata about the library) :param replace: changes the behavior to overwrite the existing library with the new contents. Return the library name that was loaded.</p> <p>For more information see https://redis.io/commands/function-load</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.function_restore","title":"function_restore","text":"<pre><code>function_restore(\n    payload: str, policy: typing.Optional[str] = \"APPEND\"\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Restore libraries from the serialized <code>payload</code>. You can use the optional policy argument to provide a policy for handling existing libraries.</p> <p>For more information see https://redis.io/commands/function-restore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.function_stats","title":"function_stats","text":"<pre><code>function_stats() -&gt; (\n    typing.Union[typing.Awaitable[typing.List], typing.List]\n)\n</code></pre> <p>Return information about the function that's currently running and information about the available execution engines.</p> <p>For more information see https://redis.io/commands/function-stats</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.geoadd","title":"geoadd","text":"<pre><code>geoadd(\n    name: kvdb.types.generic.KeyT,\n    values: typing.Sequence[redis.typing.EncodableT],\n    nx: bool = False,\n    xx: bool = False,\n    ch: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Add the specified geospatial items to the specified key identified by the <code>name</code> argument. The Geospatial items are given as ordered members of the <code>values</code> argument, each item or place is formed by the triad longitude, latitude and name.</p> <p>Note: You can use ZREM to remove elements.</p> <p><code>nx</code> forces ZADD to only create new elements and not to update scores for elements that already exist.</p> <p><code>xx</code> forces ZADD to only update scores of elements that already exist. New elements will not be added.</p> <p><code>ch</code> modifies the return value to be the numbers of elements changed. Changed elements include new elements that were added and elements whose scores changed.</p> <p>For more information see https://redis.io/commands/geoadd</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.geodist","title":"geodist","text":"<pre><code>geodist(\n    name: kvdb.types.generic.KeyT,\n    place1: redis.typing.FieldT,\n    place2: redis.typing.FieldT,\n    unit: typing.Union[str, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the distance between <code>place1</code> and <code>place2</code> members of the <code>name</code> key. The units must be one of the following : m, km mi, ft. By default meters are used.</p> <p>For more information see https://redis.io/commands/geodist</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.geohash","title":"geohash","text":"<pre><code>geohash(\n    name: kvdb.types.generic.KeyT,\n    *values: redis.typing.FieldT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the geo hash string for each item of <code>values</code> members of the specified key identified by the <code>name</code> argument.</p> <p>For more information see https://redis.io/commands/geohash</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.geopos","title":"geopos","text":"<pre><code>geopos(\n    name: kvdb.types.generic.KeyT,\n    *values: redis.typing.FieldT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the positions of each item of <code>values</code> as members of the specified key identified by the <code>name</code> argument. Each position is represented by the pairs lon and lat.</p> <p>For more information see https://redis.io/commands/geopos</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.georadius","title":"georadius","text":"<pre><code>georadius(\n    name: kvdb.types.generic.KeyT,\n    longitude: float,\n    latitude: float,\n    radius: float,\n    unit: typing.Union[str, None] = None,\n    withdist: bool = False,\n    withcoord: bool = False,\n    withhash: bool = False,\n    count: typing.Union[int, None] = None,\n    sort: typing.Union[str, None] = None,\n    store: typing.Union[\n        kvdb.types.generic.KeyT, None\n    ] = None,\n    store_dist: typing.Union[\n        kvdb.types.generic.KeyT, None\n    ] = None,\n    any: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the members of the specified key identified by the <code>name</code> argument which are within the borders of the area specified with the <code>latitude</code> and <code>longitude</code> location and the maximum distance from the center specified by the <code>radius</code> value.</p> <p>The units must be one of the following : m, km mi, ft. By default</p> <p><code>withdist</code> indicates to return the distances of each place.</p> <p><code>withcoord</code> indicates to return the latitude and longitude of each place.</p> <p><code>withhash</code> indicates to return the geohash string of each place.</p> <p><code>count</code> indicates to return the number of elements up to N.</p> <p><code>sort</code> indicates to return the places in a sorted way, ASC for nearest to fairest and DESC for fairest to nearest.</p> <p><code>store</code> indicates to save the places names in a sorted set named with a specific key, each element of the destination sorted set is populated with the score got from the original geo sorted set.</p> <p><code>store_dist</code> indicates to save the places names in a sorted set named with a specific key, instead of <code>store</code> the sorted set destination score is set with the distance.</p> <p>For more information see https://redis.io/commands/georadius</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.georadiusbymember","title":"georadiusbymember","text":"<pre><code>georadiusbymember(\n    name: kvdb.types.generic.KeyT,\n    member: redis.typing.FieldT,\n    radius: float,\n    unit: typing.Union[str, None] = None,\n    withdist: bool = False,\n    withcoord: bool = False,\n    withhash: bool = False,\n    count: typing.Union[int, None] = None,\n    sort: typing.Union[str, None] = None,\n    store: typing.Union[\n        kvdb.types.generic.KeyT, None\n    ] = None,\n    store_dist: typing.Union[\n        kvdb.types.generic.KeyT, None\n    ] = None,\n    any: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>This command is exactly like <code>georadius</code> with the sole difference that instead of taking, as the center of the area to query, a longitude and latitude value, it takes the name of a member already existing inside the geospatial index represented by the sorted set.</p> <p>For more information see https://redis.io/commands/georadiusbymember</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.geosearch","title":"geosearch","text":"<pre><code>geosearch(\n    name: kvdb.types.generic.KeyT,\n    member: typing.Union[redis.typing.FieldT, None] = None,\n    longitude: typing.Union[float, None] = None,\n    latitude: typing.Union[float, None] = None,\n    unit: str = \"m\",\n    radius: typing.Union[float, None] = None,\n    width: typing.Union[float, None] = None,\n    height: typing.Union[float, None] = None,\n    sort: typing.Union[str, None] = None,\n    count: typing.Union[int, None] = None,\n    any: bool = False,\n    withcoord: bool = False,\n    withdist: bool = False,\n    withhash: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the members of specified key identified by the <code>name</code> argument, which are within the borders of the area specified by a given shape. This command extends the GEORADIUS command, so in addition to searching within circular areas, it supports searching within rectangular areas.</p> <p>This command should be used in place of the deprecated GEORADIUS and GEORADIUSBYMEMBER commands.</p> <p><code>member</code> Use the position of the given existing  member in the sorted set. Can't be given with <code>longitude</code>  and <code>latitude</code>.</p> <p><code>longitude</code> and <code>latitude</code> Use the position given by this coordinates. Can't be given with <code>member</code> <code>radius</code> Similar to GEORADIUS, search inside circular area according the given radius. Can't be given with <code>height</code> and <code>width</code>. <code>height</code> and <code>width</code> Search inside an axis-aligned rectangle, determined by the given height and width. Can't be given with <code>radius</code></p> <p><code>unit</code> must be one of the following : m, km, mi, ft. <code>m</code> for meters (the default value), <code>km</code> for kilometers, <code>mi</code> for miles and <code>ft</code> for feet.</p> <p><code>sort</code> indicates to return the places in a sorted way, ASC for nearest to furthest and DESC for furthest to nearest.</p> <p><code>count</code> limit the results to the first count matching items.</p> <p><code>any</code> is set to True, the command will return as soon as enough matches are found. Can't be provided without <code>count</code></p> <p><code>withdist</code> indicates to return the distances of each place. <code>withcoord</code> indicates to return the latitude and longitude of each place.</p> <p><code>withhash</code> indicates to return the geohash string of each place.</p> <p>For more information see https://redis.io/commands/geosearch</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.geosearchstore","title":"geosearchstore","text":"<pre><code>geosearchstore(\n    dest: kvdb.types.generic.KeyT,\n    name: kvdb.types.generic.KeyT,\n    member: typing.Union[redis.typing.FieldT, None] = None,\n    longitude: typing.Union[float, None] = None,\n    latitude: typing.Union[float, None] = None,\n    unit: str = \"m\",\n    radius: typing.Union[float, None] = None,\n    width: typing.Union[float, None] = None,\n    height: typing.Union[float, None] = None,\n    sort: typing.Union[str, None] = None,\n    count: typing.Union[int, None] = None,\n    any: bool = False,\n    storedist: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>This command is like GEOSEARCH, but stores the result in <code>dest</code>. By default, it stores the results in the destination sorted set with their geospatial information. if <code>store_dist</code> set to True, the command will stores the items in a sorted set populated with their distance from the center of the circle or box, as a floating-point number.</p> <p>For more information see https://redis.io/commands/geosearchstore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.get","title":"get","text":"<pre><code>get(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the value at key <code>name</code>, or None if the key doesn't exist</p> <p>For more information see https://redis.io/commands/get</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.get_dictkey","title":"get_dictkey","text":"<pre><code>get_dictkey(key: kvdb.types.generic.KeyT) -&gt; str\n</code></pre> <p>Returns the dict key</p> Source code in <code>kvdb/components/session.py</code> <pre><code>dict_method = kwargs.get('dict_method', 'hset'),\ndict_prefix = kwargs.get('dict_prefix', f'{self.name}.dict'),\ndict_serialize = kwargs.get('dict_serialize', True),\ndict_expiration = kwargs.get('dict_expiration'),\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.getbit","title":"getbit","text":"<pre><code>getbit(\n    name: kvdb.types.generic.KeyT, offset: int\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns an integer indicating the value of <code>offset</code> in <code>name</code></p> <p>For more information see https://redis.io/commands/getbit</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.getdel","title":"getdel","text":"<pre><code>getdel(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Get the value at key <code>name</code> and delete the key. This command is similar to GET, except for the fact that it also deletes the key on success (if and only if the key's value type is a string).</p> <p>For more information see https://redis.io/commands/getdel</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.getex","title":"getex","text":"<pre><code>getex(\n    name: kvdb.types.generic.KeyT,\n    ex: typing.Union[\n        kvdb.types.generic.ExpiryT, None\n    ] = None,\n    px: typing.Union[\n        kvdb.types.generic.ExpiryT, None\n    ] = None,\n    exat: typing.Union[\n        kvdb.types.generic.AbsExpiryT, None\n    ] = None,\n    pxat: typing.Union[\n        kvdb.types.generic.AbsExpiryT, None\n    ] = None,\n    persist: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Get the value of key and optionally set its expiration. GETEX is similar to GET, but is a write command with additional options. All time parameters can be given as datetime.timedelta or integers.</p> <p><code>ex</code> sets an expire flag on key <code>name</code> for <code>ex</code> seconds.</p> <p><code>px</code> sets an expire flag on key <code>name</code> for <code>px</code> milliseconds.</p> <p><code>exat</code> sets an expire flag on key <code>name</code> for <code>ex</code> seconds, specified in unix time.</p> <p><code>pxat</code> sets an expire flag on key <code>name</code> for <code>ex</code> milliseconds, specified in unix time.</p> <p><code>persist</code> remove the time to live associated with <code>name</code>.</p> <p>For more information see https://redis.io/commands/getex</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.getitem","title":"getitem","text":"<pre><code>getitem(\n    key: kvdb.types.generic.KeyT,\n    default: typing.Optional[typing.Any] = None,\n) -&gt; kvdb.components.session.ReturnT\n</code></pre> <p>[Dict] Returns the value for the given key</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def getitem(\n    self,\n    key: KeyT,\n    default: Optional[Any] = None,\n) -&gt; ResponseT:\n    \"\"\"\n    [Dict] Returns the value for the given key\n    \"\"\"\n    return self.persistence.get(key, default)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.getrange","title":"getrange","text":"<pre><code>getrange(\n    key: kvdb.types.generic.KeyT, start: int, end: int\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the substring of the string value stored at <code>key</code>, determined by the offsets <code>start</code> and <code>end</code> (both are inclusive)</p> <p>For more information see https://redis.io/commands/getrange</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.getset","title":"getset","text":"<pre><code>getset(\n    name: kvdb.types.generic.KeyT,\n    value: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Sets the value at key <code>name</code> to <code>value</code> and returns the old value at key <code>name</code> atomically.</p> <p>As per Redis 6.2, GETSET is considered deprecated. Please use SET with GET parameter in new code.</p> <p>For more information see https://redis.io/commands/getset</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hdel","title":"hdel","text":"<pre><code>hdel(\n    name: str, *keys: typing.List\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Delete <code>keys</code> from hash <code>name</code></p> <p>For more information see https://redis.io/commands/hdel</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hello","title":"hello","text":"<pre><code>hello() -&gt; None\n</code></pre> <p>This function throws a NotImplementedError since it is intentionally not supported.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hexists","title":"hexists","text":"<pre><code>hexists(\n    name: str, key: str\n) -&gt; typing.Union[typing.Awaitable[bool], bool]\n</code></pre> <p>Returns a boolean indicating if <code>key</code> exists within hash <code>name</code></p> <p>For more information see https://redis.io/commands/hexists</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hget","title":"hget","text":"<pre><code>hget(name: str, key: str) -&gt; typing.Union[\n    typing.Awaitable[typing.Optional[str]],\n    typing.Optional[str],\n]\n</code></pre> <p>Return the value of <code>key</code> within the hash <code>name</code></p> <p>For more information see https://redis.io/commands/hget</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hgetall","title":"hgetall","text":"<pre><code>hgetall(\n    name: str,\n) -&gt; typing.Union[typing.Awaitable[dict], dict]\n</code></pre> <p>Return a Python dict of the hash's name/value pairs</p> <p>For more information see https://redis.io/commands/hgetall</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hincrby","title":"hincrby","text":"<pre><code>hincrby(\n    name: str, key: str, amount: int = 1\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Increment the value of <code>key</code> in hash <code>name</code> by <code>amount</code></p> <p>For more information see https://redis.io/commands/hincrby</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hincrbyfloat","title":"hincrbyfloat","text":"<pre><code>hincrbyfloat(\n    name: str, key: str, amount: float = 1.0\n) -&gt; typing.Union[typing.Awaitable[float], float]\n</code></pre> <p>Increment the value of <code>key</code> in hash <code>name</code> by floating <code>amount</code></p> <p>For more information see https://redis.io/commands/hincrbyfloat</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hkeys","title":"hkeys","text":"<pre><code>hkeys(\n    name: str,\n) -&gt; typing.Union[\n    typing.Awaitable[typing.List], typing.List\n]\n</code></pre> <p>Return the list of keys within hash <code>name</code></p> <p>For more information see https://redis.io/commands/hkeys</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hlen","title":"hlen","text":"<pre><code>hlen(name: str) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Return the number of elements in hash <code>name</code></p> <p>For more information see https://redis.io/commands/hlen</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hmget","title":"hmget","text":"<pre><code>hmget(\n    name: str, keys: typing.List, *args: typing.List\n) -&gt; typing.Union[\n    typing.Awaitable[typing.List], typing.List\n]\n</code></pre> <p>Returns a list of values ordered identically to <code>keys</code></p> <p>For more information see https://redis.io/commands/hmget</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hmset","title":"hmset","text":"<pre><code>hmset(\n    name: str, mapping: dict\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Set key to value within hash <code>name</code> for each corresponding key and value from the <code>mapping</code> dict.</p> <p>For more information see https://redis.io/commands/hmset</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hrandfield","title":"hrandfield","text":"<pre><code>hrandfield(\n    key: str, count: int = None, withvalues: bool = False\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a random field from the hash value stored at key.</p> <p>count: if the argument is positive, return an array of distinct fields. If called with a negative count, the behavior changes and the command is allowed to return the same field multiple times. In this case, the number of returned fields is the absolute value of the specified count. withvalues: The optional WITHVALUES modifier changes the reply so it includes the respective values of the randomly selected hash fields.</p> <p>For more information see https://redis.io/commands/hrandfield</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hscan","title":"hscan","text":"<pre><code>hscan(\n    name: kvdb.types.generic.KeyT,\n    cursor: int = 0,\n    match: typing.Union[\n        kvdb.types.generic.PatternT, None\n    ] = None,\n    count: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Incrementally return key/value slices in a hash. Also return a cursor indicating the scan position.</p> <p><code>match</code> allows for filtering the keys by pattern</p> <p><code>count</code> allows for hint the minimum number of returns</p> <p>For more information see https://redis.io/commands/hscan</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hscan_iter","title":"hscan_iter","text":"<pre><code>hscan_iter(\n    name: str,\n    match: typing.Union[\n        kvdb.types.generic.PatternT, None\n    ] = None,\n    count: typing.Union[int, None] = None,\n) -&gt; typing.Iterator\n</code></pre> <p>Make an iterator using the HSCAN command so that the client doesn't need to remember the cursor position.</p> <p><code>match</code> allows for filtering the keys by pattern</p> <p><code>count</code> allows for hint the minimum number of returns</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hset","title":"hset","text":"<pre><code>hset(\n    name: str,\n    key: typing.Optional[str] = None,\n    value: typing.Optional[str] = None,\n    mapping: typing.Optional[dict] = None,\n    items: typing.Optional[list] = None,\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Set <code>key</code> to <code>value</code> within hash <code>name</code>, <code>mapping</code> accepts a dict of key/value pairs that will be added to hash <code>name</code>. <code>items</code> accepts a list of key/value pairs that will be added to hash <code>name</code>. Returns the number of fields that were added.</p> <p>For more information see https://redis.io/commands/hset</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hsetnx","title":"hsetnx","text":"<pre><code>hsetnx(\n    name: str, key: str, value: str\n) -&gt; typing.Union[typing.Awaitable[bool], bool]\n</code></pre> <p>Set <code>key</code> to <code>value</code> within hash <code>name</code> if <code>key</code> does not exist.  Returns 1 if HSETNX created a field, otherwise 0.</p> <p>For more information see https://redis.io/commands/hsetnx</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hstrlen","title":"hstrlen","text":"<pre><code>hstrlen(\n    name: str, key: str\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Return the number of bytes stored in the value of <code>key</code> within hash <code>name</code></p> <p>For more information see https://redis.io/commands/hstrlen</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.hvals","title":"hvals","text":"<pre><code>hvals(\n    name: str,\n) -&gt; typing.Union[\n    typing.Awaitable[typing.List], typing.List\n]\n</code></pre> <p>Return the list of values within hash <code>name</code></p> <p>For more information see https://redis.io/commands/hvals</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.incrby","title":"incrby","text":"<pre><code>incrby(\n    name: kvdb.types.generic.KeyT, amount: int = 1\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Increments the value of <code>key</code> by <code>amount</code>.  If no key exists, the value will be initialized as <code>amount</code></p> <p>For more information see https://redis.io/commands/incrby</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.incrbyfloat","title":"incrbyfloat","text":"<pre><code>incrbyfloat(\n    name: kvdb.types.generic.KeyT, amount: float = 1.0\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Increments the value at key <code>name</code> by floating <code>amount</code>. If no key exists, the value will be initialized as <code>amount</code></p> <p>For more information see https://redis.io/commands/incrbyfloat</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.info","title":"info","text":"<pre><code>info(\n    section: typing.Union[str, None] = None,\n    *args: typing.List[str],\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a dictionary containing information about the Redis server</p> <p>The <code>section</code> option can be used to select a specific section of information</p> <p>The section option is not supported by older versions of Redis Server, and will generate ResponseError</p> <p>For more information see https://redis.io/commands/info</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.init_cache_config","title":"init_cache_config","text":"<pre><code>init_cache_config(**kwargs: typing.Any) -&gt; None\n</code></pre> <p>Initializes the cache config</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def init_cache_config(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initializes the cache config\n    \"\"\"\n    _cache_config = settings.cache.extract_kwargs(_prefix = 'cache_', _exclude_none = True, **kwargs)\n    self.cache_config = settings.cache.model_copy(update = _cache_config, deep = True)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.init_encoder","title":"init_encoder","text":"<pre><code>init_encoder(\n    encoder: typing.Optional[\n        kvdb.io.encoder.Encoder\n    ] = None,\n    **kwargs: typing.Any\n) -&gt; None\n</code></pre> <p>Initializes the encoder</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def init_encoder(\n    self, \n    encoder: Optional['Encoder'] = None, \n    **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Initializes the encoder\n    \"\"\"\n    if encoder is None:\n        from kvdb.io.encoder import Encoder\n        serializer_disabled = kwargs.get(\n            'serializer_disabled', self.serializer is None\n        )\n        encoder = Encoder(\n            encoding = kwargs.get('encoding', 'utf-8'),\n            encoding_errors = kwargs.get('encoding_errors', 'strict'),\n            decode_responses = kwargs.get('decode_responses'),\n            serializer = None if serializer_disabled else self.serializer,\n        )\n    self.encoder = encoder\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.init_serializer","title":"init_serializer","text":"<pre><code>init_serializer(\n    serializer: typing.Optional[\n        typing.Union[kvdb.io.serializers.SerializerT, str]\n    ] = None,\n    **kwargs: typing.Any\n) -&gt; None\n</code></pre> <p>Initializes the serializer</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def init_serializer(\n    self, \n    serializer: Optional[Union['SerializerT', str]] = None, \n    **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Initializes the serializer\n    \"\"\"\n\n    if serializer is None or isinstance(serializer, str):\n        _serializer_kwargs = SerializerConfig.extract_kwargs(\n            _include = ('raise_errors'), \n            **kwargs\n        )\n\n        # self.settings.logger.info(f'Initializing serializer for {self.name}, {_serializer_kwargs}')\n        serializer = settings.client_config.get_serializer(\n            serializer = serializer,\n            **_serializer_kwargs,\n        )\n        if self.settings.debug:\n            self.settings.logger.info(f'Initialized serializer for {self.name}, {serializer.name if serializer else None} {_serializer_kwargs}')\n    self.serializer = serializer\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.init_state","title":"init_state","text":"<pre><code>init_state(**kwargs: typing.Any) -&gt; None\n</code></pre> <p>Initializes the session state</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def init_state(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initializes the session state\n    \"\"\"\n    self.state = SessionState(\n        cache_max_attempts = self.cache_config.max_attempts,\n        dict_method = kwargs.get('dict_method', 'hset'),\n        dict_prefix = kwargs.get('dict_prefix', f'{self.name}.dict'),\n        dict_serialize = kwargs.get('dict_serialize', True),\n        dict_expiration = kwargs.get('dict_expiration'),\n    )\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.initialize_class_functions","title":"initialize_class_functions  <code>classmethod</code>","text":"<pre><code>initialize_class_functions()\n</code></pre> <p>Initializes the class methods and sets them based on both the async and sync methods</p> Source code in <code>kvdb/components/session.py</code> <pre><code>@classmethod\ndef initialize_class_functions(cls):\n    \"\"\"\n    Initializes the class methods\n    and sets them based on both the async and sync methods\n    \"\"\"\n    import inspect\n    from makefun import create_function\n    from redis.commands import (\n        CoreCommands,\n        # RedisModuleCommands,\n        SentinelCommands,\n\n        AsyncCoreCommands, \n        # AsyncRedisModuleCommands,\n        AsyncSentinelCommands,\n    )\n\n    existing_methods = set(dir(cls))\n    added_methods = set()\n\n    # Sync Methods\n    for sync_module in {\n        CoreCommands,\n        # RedisModuleCommands,\n        SentinelCommands,\n    }:\n\n        for name in dir(sync_module):\n            if name.startswith('_'): continue\n            if name in existing_methods: continue\n            # if name in skip_methods: continue\n            existing_func = getattr(sync_module, name)\n            existing_sig = inspect.signature(existing_func)\n            new_func = create_function(\n                existing_sig,\n                functools.partial(cls._client_function, _function = name),\n                func_name = name,\n                module_name = cls.__module__,\n            )\n            setattr(cls, name, new_func)\n            existing_methods.add(name)\n            added_methods.add(name)\n\n    # Async Methods\n    for amodule in {\n        AsyncCoreCommands,\n        # AsyncRedisModuleCommands,\n        AsyncSentinelCommands,\n    }:\n        # Core Commands\n        for name in dir(amodule):\n            if name.startswith('_'): continue\n            aname = f'a{name}'\n            # if aname == 'async': aname = 'asyncronize'\n            if aname in {\n                'async', 'await'\n            }:\n                aname = f'{aname}_'\n            if aname in existing_methods: continue\n            # if name in skip_methods: continue\n            existing_func = getattr(amodule, name)\n            existing_sig = inspect.signature(existing_func)\n            try:\n                new_func = create_function(\n                    existing_sig,\n                    functools.partial(cls._aclient_function, _function = name),\n                    func_name = aname,\n                    module_name = cls.__module__,\n                )\n                setattr(cls, aname, new_func)\n                existing_methods.add(aname)\n                added_methods.add(aname)\n            except Exception as e:\n                print(f\"Error adding method: {name} -&gt; {aname}\")\n                raise e\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.keys","title":"keys","text":"<pre><code>keys(\n    pattern: kvdb.types.generic.PatternT = \"*\", **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a list of keys matching <code>pattern</code></p> <p>For more information see https://redis.io/commands/keys</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.lastsave","title":"lastsave","text":"<pre><code>lastsave(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a Python datetime object representing the last time the Redis database was saved to disk</p> <p>For more information see https://redis.io/commands/lastsave</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.latency_doctor","title":"latency_doctor","text":"<pre><code>latency_doctor() -&gt; None\n</code></pre> <p>Raise a NotImplementedError, as the client will not support LATENCY DOCTOR. This funcion is best used within the redis-cli.</p> <p>For more information see https://redis.io/commands/latency-doctor</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.latency_graph","title":"latency_graph","text":"<pre><code>latency_graph() -&gt; None\n</code></pre> <p>Raise a NotImplementedError, as the client will not support LATENCY GRAPH. This funcion is best used within the redis-cli.</p> <p>For more information see https://redis.io/commands/latency-graph.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.latency_histogram","title":"latency_histogram","text":"<pre><code>latency_histogram(*args) -&gt; None\n</code></pre> <p>This function throws a NotImplementedError since it is intentionally not supported.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.latency_history","title":"latency_history","text":"<pre><code>latency_history(\n    event: str,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the raw data of the <code>event</code>'s latency spikes time series.</p> <p>For more information see https://redis.io/commands/latency-history</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.latency_latest","title":"latency_latest","text":"<pre><code>latency_latest() -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Reports the latest latency events logged.</p> <p>For more information see https://redis.io/commands/latency-latest</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.latency_reset","title":"latency_reset","text":"<pre><code>latency_reset(\n    *events: str,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Resets the latency spikes time series of all, or only some, events.</p> <p>For more information see https://redis.io/commands/latency-reset</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.lcs","title":"lcs","text":"<pre><code>lcs(\n    key1: str,\n    key2: str,\n    len: typing.Optional[bool] = False,\n    idx: typing.Optional[bool] = False,\n    minmatchlen: typing.Optional[int] = 0,\n    withmatchlen: typing.Optional[bool] = False,\n) -&gt; typing.Union[str, int, list]\n</code></pre> <p>Find the longest common subsequence between <code>key1</code> and <code>key2</code>. If <code>len</code> is true the length of the match will will be returned. If <code>idx</code> is true the match position in each strings will be returned. <code>minmatchlen</code> restrict the list of matches to the ones of the given <code>minmatchlen</code>. If <code>withmatchlen</code> the length of the match also will be returned. For more information see https://redis.io/commands/lcs</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.lindex","title":"lindex","text":"<pre><code>lindex(name: str, index: int) -&gt; typing.Union[\n    typing.Awaitable[typing.Optional[str]],\n    typing.Optional[str],\n]\n</code></pre> <p>Return the item from list <code>name</code> at position <code>index</code></p> <p>Negative indexes are supported and will return an item at the end of the list</p> <p>For more information see https://redis.io/commands/lindex</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.linsert","title":"linsert","text":"<pre><code>linsert(\n    name: str, where: str, refvalue: str, value: str\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Insert <code>value</code> in list <code>name</code> either immediately before or after [<code>where</code>] <code>refvalue</code></p> <p>Returns the new length of the list on success or -1 if <code>refvalue</code> is not in the list.</p> <p>For more information see https://redis.io/commands/linsert</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.llen","title":"llen","text":"<pre><code>llen(name: str) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Return the length of the list <code>name</code></p> <p>For more information see https://redis.io/commands/llen</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.lmove","title":"lmove","text":"<pre><code>lmove(\n    first_list: str,\n    second_list: str,\n    src: str = \"LEFT\",\n    dest: str = \"RIGHT\",\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Atomically returns and removes the first/last element of a list, pushing it as the first/last element on the destination list. Returns the element being popped and pushed.</p> <p>For more information see https://redis.io/commands/lmove</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.lmpop","title":"lmpop","text":"<pre><code>lmpop(\n    num_keys: int,\n    *args: typing.List[str],\n    direction: str,\n    count: typing.Optional[int] = 1\n) -&gt; typing.Union[typing.Awaitable[list], list]\n</code></pre> <p>Pop <code>count</code> values (default 1) first non-empty list key from the list of args provided key names.</p> <p>For more information see https://redis.io/commands/lmpop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.lock","title":"lock","text":"<pre><code>lock(\n    name: str,\n    timeout: typing.Optional[\n        kvdb.types.generic.Number\n    ] = None,\n    sleep: typing.Optional[kvdb.types.generic.Number] = 0.1,\n    blocking: typing.Optional[bool] = True,\n    blocking_timeout: typing.Optional[\n        kvdb.types.generic.Number\n    ] = None,\n    thread_local: typing.Optional[bool] = True,\n    force_unlock: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; kvdb.components.lock.Lock\n</code></pre> <p>Create a new Lock instance named <code>name</code> using the Redis client supplied by <code>keydb</code>.</p> <p><code>timeout</code> indicates a maximum life for the lock in seconds. By default, it will remain locked until release() is called. <code>timeout</code> can be specified as a float or integer, both representing the number of seconds to wait.</p> <p><code>sleep</code> indicates the amount of time to sleep in seconds per loop iteration when the lock is in blocking mode and another client is currently holding the lock.</p> <p><code>blocking</code> indicates whether calling <code>acquire</code> should block until the lock has been acquired or to fail immediately, causing <code>acquire</code> to return False and the lock not being acquired. Defaults to True. Note this value can be overridden by passing a <code>blocking</code> argument to <code>acquire</code>.</p> <p><code>blocking_timeout</code> indicates the maximum amount of time in seconds to spend trying to acquire the lock. A value of <code>None</code> indicates continue trying forever. <code>blocking_timeout</code> can be specified as a float or integer, both representing the number of seconds to wait.</p> <p><code>thread_local</code> indicates whether the lock token is placed in thread-local storage. By default, the token is placed in thread local storage so that a thread only sees its token, not a token set by another thread.</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def lock(\n    self, \n    name: str, \n    timeout: Optional[Number] = None,\n    sleep: Optional[Number] = 0.1,\n    blocking: Optional[bool] = True,\n    blocking_timeout: Optional[Number] = None,\n    thread_local: Optional[bool] = True,\n    force_unlock: Optional[bool] = None,\n    **kwargs,\n) -&gt; Lock:\n    \"\"\"\n    Create a new Lock instance named ``name`` using the Redis client\n    supplied by ``keydb``.\n\n    ``timeout`` indicates a maximum life for the lock in seconds.\n    By default, it will remain locked until release() is called.\n    ``timeout`` can be specified as a float or integer, both representing\n    the number of seconds to wait.\n\n    ``sleep`` indicates the amount of time to sleep in seconds per loop\n    iteration when the lock is in blocking mode and another client is\n    currently holding the lock.\n\n    ``blocking`` indicates whether calling ``acquire`` should block until\n    the lock has been acquired or to fail immediately, causing ``acquire``\n    to return False and the lock not being acquired. Defaults to True.\n    Note this value can be overridden by passing a ``blocking``\n    argument to ``acquire``.\n\n    ``blocking_timeout`` indicates the maximum amount of time in seconds to\n    spend trying to acquire the lock. A value of ``None`` indicates\n    continue trying forever. ``blocking_timeout`` can be specified as a\n    float or integer, both representing the number of seconds to wait.\n\n    ``thread_local`` indicates whether the lock token is placed in\n    thread-local storage. By default, the token is placed in thread local\n    storage so that a thread only sees its token, not a token set by\n    another thread. \n    \"\"\"\n    if name not in self.state.locks:\n        self.state.locks[name] = Lock(\n            self.client, \n            name = name, \n            timeout = timeout, \n            sleep = sleep, \n            blocking = blocking, \n            blocking_timeout = blocking_timeout, \n            thread_local = thread_local,\n            force_unlock = force_unlock,\n        )\n    if self.state.lock is None: self.state.lock = self.state.locks[name]\n    return self.state.locks[name]\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.lolwut","title":"lolwut","text":"<pre><code>lolwut(\n    *version_numbers: typing.Union[str, float], **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Get the Redis version and a piece of generative computer art</p> <p>See: https://redis.io/commands/lolwut</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.lpop","title":"lpop","text":"<pre><code>lpop(\n    name: str, count: typing.Optional[int] = None\n) -&gt; typing.Union[\n    typing.Awaitable[typing.Union[str, typing.List, None]],\n    typing.Union[str, typing.List, None],\n]\n</code></pre> <p>Removes and returns the first elements of the list <code>name</code>.</p> <p>By default, the command pops a single element from the beginning of the list. When provided with the optional <code>count</code> argument, the reply will consist of up to count elements, depending on the list's length.</p> <p>For more information see https://redis.io/commands/lpop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.lpos","title":"lpos","text":"<pre><code>lpos(\n    name: str,\n    value: str,\n    rank: typing.Optional[int] = None,\n    count: typing.Optional[int] = None,\n    maxlen: typing.Optional[int] = None,\n) -&gt; typing.Union[str, typing.List, None]\n</code></pre> <p>Get position of <code>value</code> within the list <code>name</code></p> <p>If specified, <code>rank</code> indicates the \"rank\" of the first element to  return in case there are multiple copies of <code>value</code> in the list.  By default, LPOS returns the position of the first occurrence of  <code>value</code> in the list. When <code>rank</code> 2, LPOS returns the position of  the second <code>value</code> in the list. If <code>rank</code> is negative, LPOS  searches the list in reverse. For example, -1 would return the  position of the last occurrence of <code>value</code> and -2 would return the  position of the next to last occurrence of <code>value</code>.</p> <p>If specified, <code>count</code> indicates that LPOS should return a list of  up to <code>count</code> positions. A <code>count</code> of 2 would return a list of  up to 2 positions. A <code>count</code> of 0 returns a list of all positions  matching <code>value</code>. When <code>count</code> is specified and but <code>value</code>  does not exist in the list, an empty list is returned.</p> <p>If specified, <code>maxlen</code> indicates the maximum number of list  elements to scan. A <code>maxlen</code> of 1000 will only return the  position(s) of items within the first 1000 entries in the list.  A <code>maxlen</code> of 0 (the default) will scan the entire list.</p> <p>For more information see https://redis.io/commands/lpos</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.lpush","title":"lpush","text":"<pre><code>lpush(\n    name: str, *values: redis.typing.FieldT\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Push <code>values</code> onto the head of the list <code>name</code></p> <p>For more information see https://redis.io/commands/lpush</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.lpushx","title":"lpushx","text":"<pre><code>lpushx(\n    name: str, *values: redis.typing.FieldT\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Push <code>value</code> onto the head of the list <code>name</code> if <code>name</code> exists</p> <p>For more information see https://redis.io/commands/lpushx</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.lrange","title":"lrange","text":"<pre><code>lrange(\n    name: str, start: int, end: int\n) -&gt; typing.Union[typing.Awaitable[list], list]\n</code></pre> <p>Return a slice of the list <code>name</code> between position <code>start</code> and <code>end</code></p> <p><code>start</code> and <code>end</code> can be negative numbers just like Python slicing notation</p> <p>For more information see https://redis.io/commands/lrange</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.lrem","title":"lrem","text":"<pre><code>lrem(\n    name: str, count: int, value: str\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Remove the first <code>count</code> occurrences of elements equal to <code>value</code> from the list stored at <code>name</code>.</p> The count argument influences the operation in the following ways <p>count &gt; 0: Remove elements equal to value moving from head to tail. count &lt; 0: Remove elements equal to value moving from tail to head. count = 0: Remove all elements equal to value.</p> <p>For more information see https://redis.io/commands/lrem</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.lset","title":"lset","text":"<pre><code>lset(\n    name: str, index: int, value: str\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Set element at <code>index</code> of list <code>name</code> to <code>value</code></p> <p>For more information see https://redis.io/commands/lset</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ltrim","title":"ltrim","text":"<pre><code>ltrim(\n    name: str, start: int, end: int\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>Trim the list <code>name</code>, removing all values not within the slice between <code>start</code> and <code>end</code></p> <p><code>start</code> and <code>end</code> can be negative numbers just like Python slicing notation</p> <p>For more information see https://redis.io/commands/ltrim</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.memory_malloc_stats","title":"memory_malloc_stats","text":"<pre><code>memory_malloc_stats(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return an internal statistics report from the memory allocator.</p> <p>See: https://redis.io/commands/memory-malloc-stats</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.memory_purge","title":"memory_purge","text":"<pre><code>memory_purge(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Attempts to purge dirty pages for reclamation by allocator</p> <p>For more information see https://redis.io/commands/memory-purge</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.memory_stats","title":"memory_stats","text":"<pre><code>memory_stats(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a dictionary of memory stats</p> <p>For more information see https://redis.io/commands/memory-stats</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.memory_usage","title":"memory_usage","text":"<pre><code>memory_usage(\n    key: kvdb.types.generic.KeyT,\n    samples: typing.Union[int, None] = None,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the total memory usage for key, its value and associated administrative overheads.</p> <p>For nested data structures, <code>samples</code> is the number of elements to sample. If left unspecified, the server's default is 5. Use 0 to sample all elements.</p> <p>For more information see https://redis.io/commands/memory-usage</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.mget","title":"mget","text":"<pre><code>mget(\n    keys: redis.typing.KeysT, *args: redis.typing.EncodableT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a list of values ordered identically to <code>keys</code></p> <p>For more information see https://redis.io/commands/mget</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.migrate","title":"migrate","text":"<pre><code>migrate(\n    host: str,\n    port: int,\n    keys: redis.typing.KeysT,\n    destination_db: int,\n    timeout: int,\n    copy: bool = False,\n    replace: bool = False,\n    auth: typing.Union[str, None] = None,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Migrate 1 or more keys from the current Redis server to a different server specified by the <code>host</code>, <code>port</code> and <code>destination_db</code>.</p> <p>The <code>timeout</code>, specified in milliseconds, indicates the maximum time the connection between the two servers can be idle before the command is interrupted.</p> <p>If <code>copy</code> is True, the specified <code>keys</code> are NOT deleted from the source server.</p> <p>If <code>replace</code> is True, this operation will overwrite the keys on the destination server if they exist.</p> <p>If <code>auth</code> is specified, authenticate to the destination server with the password provided.</p> <p>For more information see https://redis.io/commands/migrate</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.module_list","title":"module_list","text":"<pre><code>module_list() -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a list of dictionaries containing the name and version of all loaded modules.</p> <p>For more information see https://redis.io/commands/module-list</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.module_load","title":"module_load","text":"<pre><code>module_load(\n    path, *args\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Loads the module from <code>path</code>. Passes all <code>*args</code> to the module, during loading. Raises <code>ModuleError</code> if a module is not found at <code>path</code>.</p> <p>For more information see https://redis.io/commands/module-load</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.module_loadex","title":"module_loadex","text":"<pre><code>module_loadex(\n    path: str,\n    options: typing.Optional[typing.List[str]] = None,\n    args: typing.Optional[typing.List[str]] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Loads a module from a dynamic library at runtime with configuration directives.</p> <p>For more information see https://redis.io/commands/module-loadex</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.module_unload","title":"module_unload","text":"<pre><code>module_unload(name) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Unloads the module <code>name</code>. Raises <code>ModuleError</code> if <code>name</code> is not in loaded modules.</p> <p>For more information see https://redis.io/commands/module-unload</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.move","title":"move","text":"<pre><code>move(\n    name: kvdb.types.generic.KeyT, db: int\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Moves the key <code>name</code> to a different Redis database <code>db</code></p> <p>For more information see https://redis.io/commands/move</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.mset","title":"mset","text":"<pre><code>mset(\n    mapping: typing.Mapping[\n        redis.typing.AnyKeyT, redis.typing.EncodableT\n    ],\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Sets key/values based on a mapping. Mapping is a dictionary of key/value pairs. Both keys and values should be strings or types that can be cast to a string via str().</p> <p>For more information see https://redis.io/commands/mset</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.msetnx","title":"msetnx","text":"<pre><code>msetnx(\n    mapping: typing.Mapping[\n        redis.typing.AnyKeyT, redis.typing.EncodableT\n    ],\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Sets key/values based on a mapping if none of the keys are already set. Mapping is a dictionary of key/value pairs. Both keys and values should be strings or types that can be cast to a string via str(). Returns a boolean indicating if the operation was successful.</p> <p>For more information see https://redis.io/commands/msetnx</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.object","title":"object","text":"<pre><code>object(\n    infotype: str, key: kvdb.types.generic.KeyT, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the encoding, idletime, or refcount about the key</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.overflow","title":"overflow","text":"<pre><code>overflow(overflow: str)\n</code></pre> <p>Update the overflow algorithm of successive INCRBY operations :param overflow: Overflow algorithm, one of WRAP, SAT, FAIL. See the     Redis docs for descriptions of these algorithmsself. :returns: a :py:class:<code>BitFieldOperation</code> instance.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.persist","title":"persist","text":"<pre><code>persist(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Removes an expiration on <code>name</code></p> <p>For more information see https://redis.io/commands/persist</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.pexpire","title":"pexpire","text":"<pre><code>pexpire(\n    name: kvdb.types.generic.KeyT,\n    time: kvdb.types.generic.ExpiryT,\n    nx: bool = False,\n    xx: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set an expire flag on key <code>name</code> for <code>time</code> milliseconds with given <code>option</code>. <code>time</code> can be represented by an integer or a Python timedelta object.</p> Valid options are <p>NX -&gt; Set expiry only when the key has no expiry XX -&gt; Set expiry only when the key has an existing expiry GT -&gt; Set expiry only when the new expiry is greater than current one LT -&gt; Set expiry only when the new expiry is less than current one</p> <p>For more information see https://redis.io/commands/pexpire</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.pexpireat","title":"pexpireat","text":"<pre><code>pexpireat(\n    name: kvdb.types.generic.KeyT,\n    when: kvdb.types.generic.AbsExpiryT,\n    nx: bool = False,\n    xx: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set an expire flag on key <code>name</code> with given <code>option</code>. <code>when</code> can be represented as an integer representing unix time in milliseconds (unix time * 1000) or a Python datetime object.</p> Valid options are <p>NX -&gt; Set expiry only when the key has no expiry XX -&gt; Set expiry only when the key has an existing expiry GT -&gt; Set expiry only when the new expiry is greater than current one LT -&gt; Set expiry only when the new expiry is less than current one</p> <p>For more information see https://redis.io/commands/pexpireat</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.pexpiretime","title":"pexpiretime","text":"<pre><code>pexpiretime(key: str) -&gt; int\n</code></pre> <p>Returns the absolute Unix timestamp (since January 1, 1970) in milliseconds at which the given key will expire.</p> <p>For more information see https://redis.io/commands/pexpiretime</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.pfadd","title":"pfadd","text":"<pre><code>pfadd(\n    name: kvdb.types.generic.KeyT,\n    *values: redis.typing.FieldT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Adds the specified elements to the specified HyperLogLog.</p> <p>For more information see https://redis.io/commands/pfadd</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.pfcount","title":"pfcount","text":"<pre><code>pfcount(\n    *sources: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the approximated cardinality of the set observed by the HyperLogLog at key(s).</p> <p>For more information see https://redis.io/commands/pfcount</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.pfmerge","title":"pfmerge","text":"<pre><code>pfmerge(\n    dest: kvdb.types.generic.KeyT,\n    *sources: kvdb.types.generic.KeyT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Merge N different HyperLogLogs into a single one.</p> <p>For more information see https://redis.io/commands/pfmerge</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ping","title":"ping","text":"<pre><code>ping(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Ping the Redis server</p> <p>For more information see https://redis.io/commands/ping</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.pipeline","title":"pipeline","text":"<pre><code>pipeline(\n    transaction: typing.Optional[bool] = True,\n    shard_hint: typing.Optional[str] = None,\n    retryable: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; kvdb.components.pipeline.PipelineT\n</code></pre> <p>Return a new pipeline object that can queue multiple commands for later execution. <code>transaction</code> indicates whether all commands should be executed atomically. Apart from making a group of operations atomic, pipelines are useful for reducing the back-and-forth overhead between the client and server.</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def pipeline(\n    self, \n    transaction: Optional[bool] = True, \n    shard_hint: Optional[str] = None, \n    retryable: Optional[bool] = None,\n    **kwargs\n) -&gt; PipelineT:\n    \"\"\"\n    Return a new pipeline object that can queue multiple commands for\n    later execution. ``transaction`` indicates whether all commands\n    should be executed atomically. Apart from making a group of operations\n    atomic, pipelines are useful for reducing the back-and-forth overhead\n    between the client and server.\n    \"\"\"\n    if retryable is None: retryable = self.settings.retry.pipeline_enabled\n    return self.client.pipeline(transaction = transaction, shard_hint = shard_hint, retryable = retryable)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.psetex","title":"psetex","text":"<pre><code>psetex(\n    name: kvdb.types.generic.KeyT,\n    time_ms: kvdb.types.generic.ExpiryT,\n    value: redis.typing.EncodableT,\n)\n</code></pre> <p>Set the value of key <code>name</code> to <code>value</code> that expires in <code>time_ms</code> milliseconds. <code>time_ms</code> can be represented by an integer or a Python timedelta object</p> <p>For more information see https://redis.io/commands/psetex</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.psync","title":"psync","text":"<pre><code>psync(replicationid: str, offset: int)\n</code></pre> <p>Initiates a replication stream from the master. Newer version for <code>sync</code>.</p> <p>For more information see https://redis.io/commands/sync</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.pttl","title":"pttl","text":"<pre><code>pttl(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the number of milliseconds until the key <code>name</code> will expire</p> <p>For more information see https://redis.io/commands/pttl</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.publish","title":"publish","text":"<pre><code>publish(\n    channel: redis.typing.ChannelT,\n    message: redis.typing.EncodableT,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Publish <code>message</code> on <code>channel</code>. Returns the number of subscribers the message was delivered to.</p> <p>For more information see https://redis.io/commands/publish</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.pubsub","title":"pubsub","text":"<pre><code>pubsub(\n    retryable: typing.Optional[bool] = None, **kwargs\n) -&gt; kvdb.components.pubsub.PubSubT\n</code></pre> <p>Return a Publish/Subscribe object. With this object, you can subscribe to channels and listen for messages that get published to</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def pubsub(\n    self, \n    retryable: Optional[bool] = None,\n    **kwargs\n) -&gt; PubSubT:\n    \"\"\"\n    Return a Publish/Subscribe object. With this object, you can\n    subscribe to channels and listen for messages that get published to\n    \"\"\"\n    if retryable is None: retryable = self.settings.retry.pubsub_enabled\n    return self.client.pubsub(retryable = retryable, **kwargs)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.pubsub_channels","title":"pubsub_channels","text":"<pre><code>pubsub_channels(\n    pattern: kvdb.types.generic.PatternT = \"*\", **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a list of channels that have at least one subscriber</p> <p>For more information see https://redis.io/commands/pubsub-channels</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.pubsub_numpat","title":"pubsub_numpat","text":"<pre><code>pubsub_numpat(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the number of subscriptions to patterns</p> <p>For more information see https://redis.io/commands/pubsub-numpat</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.pubsub_numsub","title":"pubsub_numsub","text":"<pre><code>pubsub_numsub(\n    *args: redis.typing.ChannelT, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a list of (channel, number of subscribers) tuples for each channel given in <code>*args</code></p> <p>For more information see https://redis.io/commands/pubsub-numsub</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.pubsub_shardchannels","title":"pubsub_shardchannels","text":"<pre><code>pubsub_shardchannels(\n    pattern: kvdb.types.generic.PatternT = \"*\", **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a list of shard_channels that have at least one subscriber</p> <p>For more information see https://redis.io/commands/pubsub-shardchannels</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.pubsub_shardnumsub","title":"pubsub_shardnumsub","text":"<pre><code>pubsub_shardnumsub(\n    *args: redis.typing.ChannelT, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a list of (shard_channel, number of subscribers) tuples for each channel given in <code>*args</code></p> <p>For more information see https://redis.io/commands/pubsub-shardnumsub</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.quit","title":"quit","text":"<pre><code>quit(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Ask the server to close the connection.</p> <p>For more information see https://redis.io/commands/quit</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.randomkey","title":"randomkey","text":"<pre><code>randomkey(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the name of a random key</p> <p>For more information see https://redis.io/commands/randomkey</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.readonly","title":"readonly","text":"<pre><code>readonly(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Enables read queries for a connection to a Redis Cluster replica node.</p> <p>For more information see https://redis.io/commands/readonly</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.readwrite","title":"readwrite","text":"<pre><code>readwrite(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Disables read queries for a connection to a Redis Cluster slave node.</p> <p>For more information see https://redis.io/commands/readwrite</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.register_script","title":"register_script","text":"<pre><code>register_script(\n    script: redis.typing.ScriptTextT,\n) -&gt; redis.commands.core.Script\n</code></pre> <p>Register a Lua <code>script</code> specifying the <code>keys</code> it will touch. Returns a Script object that is callable and hides the complexity of deal with scripts, keys, and shas. This is the preferred way to work with Lua scripts.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.rename","title":"rename","text":"<pre><code>rename(\n    src: kvdb.types.generic.KeyT,\n    dst: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Rename key <code>src</code> to <code>dst</code></p> <p>For more information see https://redis.io/commands/rename</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.renamenx","title":"renamenx","text":"<pre><code>renamenx(\n    src: kvdb.types.generic.KeyT,\n    dst: kvdb.types.generic.KeyT,\n)\n</code></pre> <p>Rename key <code>src</code> to <code>dst</code> if <code>dst</code> doesn't already exist</p> <p>For more information see https://redis.io/commands/renamenx</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.replicaof","title":"replicaof","text":"<pre><code>replicaof(\n    *args, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Update the replication settings of a redis replica, on the fly.</p> <p>Examples of valid arguments include:</p> <p>NO ONE (set no replication) host port (set to the host and port of a redis server)</p> <p>For more information see  https://redis.io/commands/replicaof</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the state of the instance to when it was constructed</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.restore","title":"restore","text":"<pre><code>restore(\n    name: kvdb.types.generic.KeyT,\n    ttl: float,\n    value: redis.typing.EncodableT,\n    replace: bool = False,\n    absttl: bool = False,\n    idletime: typing.Union[int, None] = None,\n    frequency: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Create a key using the provided serialized value, previously obtained using DUMP.</p> <p><code>replace</code> allows an existing key on <code>name</code> to be overridden. If it's not specified an error is raised on collision.</p> <p><code>absttl</code> if True, specified <code>ttl</code> should represent an absolute Unix timestamp in milliseconds in which the key will expire. (Redis 5.0 or greater).</p> <p><code>idletime</code> Used for eviction, this is the number of seconds the key must be idle, prior to execution.</p> <p><code>frequency</code> Used for eviction, this is the frequency counter of the object stored at the key, prior to execution.</p> <p>For more information see https://redis.io/commands/restore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.role","title":"role","text":"<pre><code>role() -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Provide information on the role of a Redis instance in the context of replication, by returning if the instance is currently a master, slave, or sentinel.</p> <p>For more information see https://redis.io/commands/role</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.rpop","title":"rpop","text":"<pre><code>rpop(\n    name: str, count: typing.Optional[int] = None\n) -&gt; typing.Union[\n    typing.Awaitable[typing.Union[str, typing.List, None]],\n    typing.Union[str, typing.List, None],\n]\n</code></pre> <p>Removes and returns the last elements of the list <code>name</code>.</p> <p>By default, the command pops a single element from the end of the list. When provided with the optional <code>count</code> argument, the reply will consist of up to count elements, depending on the list's length.</p> <p>For more information see https://redis.io/commands/rpop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.rpoplpush","title":"rpoplpush","text":"<pre><code>rpoplpush(\n    src: str, dst: str\n) -&gt; typing.Union[typing.Awaitable[str], str]\n</code></pre> <p>RPOP a value off of the <code>src</code> list and atomically LPUSH it on to the <code>dst</code> list.  Returns the value.</p> <p>For more information see https://redis.io/commands/rpoplpush</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.rpush","title":"rpush","text":"<pre><code>rpush(\n    name: str, *values: redis.typing.FieldT\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Push <code>values</code> onto the tail of the list <code>name</code></p> <p>For more information see https://redis.io/commands/rpush</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.rpushx","title":"rpushx","text":"<pre><code>rpushx(\n    name: str, *values: str\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Push <code>value</code> onto the tail of the list <code>name</code> if <code>name</code> exists</p> <p>For more information see https://redis.io/commands/rpushx</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.sadd","title":"sadd","text":"<pre><code>sadd(\n    name: str, *values: redis.typing.FieldT\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Add <code>value(s)</code> to set <code>name</code></p> <p>For more information see https://redis.io/commands/sadd</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.save","title":"save","text":"<pre><code>save(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Tell the Redis server to save its data to disk, blocking until the save is complete</p> <p>For more information see https://redis.io/commands/save</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.scan","title":"scan","text":"<pre><code>scan(\n    cursor: int = 0,\n    match: typing.Union[\n        kvdb.types.generic.PatternT, None\n    ] = None,\n    count: typing.Union[int, None] = None,\n    _type: typing.Union[str, None] = None,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Incrementally return lists of key names. Also return a cursor indicating the scan position.</p> <p><code>match</code> allows for filtering the keys by pattern</p> <p><code>count</code> provides a hint to Redis about the number of keys to     return per batch.</p> <p><code>_type</code> filters the returned values by a particular Redis type.     Stock Redis instances allow for the following types:     HASH, LIST, SET, STREAM, STRING, ZSET     Additionally, Redis modules can expose other types as well.</p> <p>For more information see https://redis.io/commands/scan</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.scan_iter","title":"scan_iter","text":"<pre><code>scan_iter(\n    match: typing.Union[\n        kvdb.types.generic.PatternT, None\n    ] = None,\n    count: typing.Union[int, None] = None,\n    _type: typing.Union[str, None] = None,\n    **kwargs\n) -&gt; typing.Iterator\n</code></pre> <p>Make an iterator using the SCAN command so that the client doesn't need to remember the cursor position.</p> <p><code>match</code> allows for filtering the keys by pattern</p> <p><code>count</code> provides a hint to Redis about the number of keys to     return per batch.</p> <p><code>_type</code> filters the returned values by a particular Redis type.     Stock Redis instances allow for the following types:     HASH, LIST, SET, STREAM, STRING, ZSET     Additionally, Redis modules can expose other types as well.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.scard","title":"scard","text":"<pre><code>scard(\n    name: str,\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Return the number of elements in set <code>name</code></p> <p>For more information see https://redis.io/commands/scard</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.script_exists","title":"script_exists","text":"<pre><code>script_exists(\n    *args: str,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Check if a script exists in the script cache by specifying the SHAs of each script as <code>args</code>. Returns a list of boolean values indicating if if each already script exists in the cache.</p> <p>For more information see  https://redis.io/commands/script-exists</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.script_flush","title":"script_flush","text":"<pre><code>script_flush(\n    sync_type: typing.Union[\n        typing.Literal[\"SYNC\"], typing.Literal[\"ASYNC\"]\n    ] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Flush all scripts from the script cache.</p> <p><code>sync_type</code> is by default SYNC (synchronous) but it can also be               ASYNC.</p> <p>For more information see  https://redis.io/commands/script-flush</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.script_kill","title":"script_kill","text":"<pre><code>script_kill() -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Kill the currently executing Lua script</p> <p>For more information see https://redis.io/commands/script-kill</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.script_load","title":"script_load","text":"<pre><code>script_load(\n    script: redis.typing.ScriptTextT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Load a Lua <code>script</code> into the script cache. Returns the SHA.</p> <p>For more information see https://redis.io/commands/script-load</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.sdiff","title":"sdiff","text":"<pre><code>sdiff(\n    keys: typing.List, *args: typing.List\n) -&gt; typing.Union[typing.Awaitable[list], list]\n</code></pre> <p>Return the difference of sets specified by <code>keys</code></p> <p>For more information see https://redis.io/commands/sdiff</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.sdiffstore","title":"sdiffstore","text":"<pre><code>sdiffstore(\n    dest: str, keys: typing.List, *args: typing.List\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Store the difference of sets specified by <code>keys</code> into a new set named <code>dest</code>.  Returns the number of keys in the new set.</p> <p>For more information see https://redis.io/commands/sdiffstore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.select","title":"select","text":"<pre><code>select(\n    index: int, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Select the Redis logical database at index.</p> <p>See: https://redis.io/commands/select</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.set","title":"set","text":"<pre><code>set(\n    name: kvdb.types.generic.KeyT,\n    value: redis.typing.EncodableT,\n    ex: typing.Union[\n        kvdb.types.generic.ExpiryT, None\n    ] = None,\n    px: typing.Union[\n        kvdb.types.generic.ExpiryT, None\n    ] = None,\n    nx: bool = False,\n    xx: bool = False,\n    keepttl: bool = False,\n    get: bool = False,\n    exat: typing.Union[\n        kvdb.types.generic.AbsExpiryT, None\n    ] = None,\n    pxat: typing.Union[\n        kvdb.types.generic.AbsExpiryT, None\n    ] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set the value at key <code>name</code> to <code>value</code></p> <p><code>ex</code> sets an expire flag on key <code>name</code> for <code>ex</code> seconds.</p> <p><code>px</code> sets an expire flag on key <code>name</code> for <code>px</code> milliseconds.</p> <p><code>nx</code> if set to True, set the value at key <code>name</code> to <code>value</code> only     if it does not exist.</p> <p><code>xx</code> if set to True, set the value at key <code>name</code> to <code>value</code> only     if it already exists.</p> <p><code>keepttl</code> if True, retain the time to live associated with the key.     (Available since Redis 6.0)</p> <p><code>get</code> if True, set the value at key <code>name</code> to <code>value</code> and return     the old value stored at key, or None if the key did not exist.     (Available since Redis 6.2)</p> <p><code>exat</code> sets an expire flag on key <code>name</code> for <code>ex</code> seconds,     specified in unix time.</p> <p><code>pxat</code> sets an expire flag on key <code>name</code> for <code>ex</code> milliseconds,     specified in unix time.</p> <p>For more information see https://redis.io/commands/set</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.setbit","title":"setbit","text":"<pre><code>setbit(\n    name: kvdb.types.generic.KeyT, offset: int, value: int\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Flag the <code>offset</code> in <code>name</code> as <code>value</code>. Returns an integer indicating the previous value of <code>offset</code>.</p> <p>For more information see https://redis.io/commands/setbit</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.setex","title":"setex","text":"<pre><code>setex(\n    name: kvdb.types.generic.KeyT,\n    time: kvdb.types.generic.ExpiryT,\n    value: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set the value of key <code>name</code> to <code>value</code> that expires in <code>time</code> seconds. <code>time</code> can be represented by an integer or a Python timedelta object.</p> <p>For more information see https://redis.io/commands/setex</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.setitem","title":"setitem","text":"<pre><code>setitem(\n    key: kvdb.types.generic.KeyT,\n    value: typing.Any,\n    ex: typing.Optional[kvdb.types.generic.ExpiryT] = None,\n    **kwargs: typing.Any\n) -&gt; None\n</code></pre> <p>[Dict] Sets the value for the given key</p> Source code in <code>kvdb/components/session.py</code> <pre><code>def setitem(\n    self,\n    key: KeyT,\n    value: Any,\n    ex: Optional[ExpiryT] = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    [Dict] Sets the value for the given key\n    \"\"\"\n    return self.persistence.set(key, value, ex = ex, **kwargs)\n</code></pre>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.setnx","title":"setnx","text":"<pre><code>setnx(\n    name: kvdb.types.generic.KeyT,\n    value: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set the value of key <code>name</code> to <code>value</code> if key doesn't exist</p> <p>For more information see https://redis.io/commands/setnx</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.setrange","title":"setrange","text":"<pre><code>setrange(\n    name: kvdb.types.generic.KeyT,\n    offset: int,\n    value: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Overwrite bytes in the value of <code>name</code> starting at <code>offset</code> with <code>value</code>. If <code>offset</code> plus the length of <code>value</code> exceeds the length of the original value, the new value will be larger than before. If <code>offset</code> exceeds the length of the original value, null bytes will be used to pad between the end of the previous value and the start of what's being injected.</p> <p>Returns the length of the new string.</p> <p>For more information see https://redis.io/commands/setrange</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.shutdown","title":"shutdown","text":"<pre><code>shutdown(\n    save: bool = False,\n    nosave: bool = False,\n    now: bool = False,\n    force: bool = False,\n    abort: bool = False,\n    **kwargs\n) -&gt; None\n</code></pre> <p>Shutdown the Redis server.  If Redis has persistence configured, data will be flushed before shutdown. It is possible to specify modifiers to alter the behavior of the command: <code>save</code> will force a DB saving operation even if no save points are configured. <code>nosave</code> will prevent a DB saving operation even if one or more save points are configured. <code>now</code> skips waiting for lagging replicas, i.e. it bypasses the first step in the shutdown sequence. <code>force</code> ignores any errors that would normally prevent the server from exiting <code>abort</code> cancels an ongoing shutdown and cannot be combined with other flags.</p> <p>For more information see https://redis.io/commands/shutdown</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.sinter","title":"sinter","text":"<pre><code>sinter(\n    keys: typing.List, *args: typing.List\n) -&gt; typing.Union[typing.Awaitable[list], list]\n</code></pre> <p>Return the intersection of sets specified by <code>keys</code></p> <p>For more information see https://redis.io/commands/sinter</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.sintercard","title":"sintercard","text":"<pre><code>sintercard(\n    numkeys: int, keys: typing.List[str], limit: int = 0\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Return the cardinality of the intersect of multiple sets specified by <code>`keys</code>.</p> <p>When LIMIT provided (defaults to 0 and means unlimited), if the intersection cardinality reaches limit partway through the computation, the algorithm will exit and yield limit as the cardinality</p> <p>For more information see https://redis.io/commands/sintercard</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.sinterstore","title":"sinterstore","text":"<pre><code>sinterstore(\n    dest: str, keys: typing.List, *args: typing.List\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Store the intersection of sets specified by <code>keys</code> into a new set named <code>dest</code>.  Returns the number of keys in the new set.</p> <p>For more information see https://redis.io/commands/sinterstore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.sismember","title":"sismember","text":"<pre><code>sismember(name: str, value: str) -&gt; typing.Union[\n    typing.Awaitable[\n        typing.Union[typing.Literal[0], typing.Literal[1]]\n    ],\n    typing.Union[typing.Literal[0], typing.Literal[1]],\n]\n</code></pre> <p>Return whether <code>value</code> is a member of set <code>name</code>: - 1 if the value is a member of the set. - 0 if the value is not a member of the set or if key does not exist.</p> <p>For more information see https://redis.io/commands/sismember</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.slaveof","title":"slaveof","text":"<pre><code>slaveof(\n    host: typing.Union[str, None] = None,\n    port: typing.Union[int, None] = None,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set the server to be a replicated slave of the instance identified by the <code>host</code> and <code>port</code>. If called without arguments, the instance is promoted to a master instead.</p> <p>For more information see https://redis.io/commands/slaveof</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.slowlog_get","title":"slowlog_get","text":"<pre><code>slowlog_get(\n    num: typing.Union[int, None] = None, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Get the entries from the slowlog. If <code>num</code> is specified, get the most recent <code>num</code> items.</p> <p>For more information see https://redis.io/commands/slowlog-get</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.slowlog_len","title":"slowlog_len","text":"<pre><code>slowlog_len(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Get the number of items in the slowlog</p> <p>For more information see https://redis.io/commands/slowlog-len</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.slowlog_reset","title":"slowlog_reset","text":"<pre><code>slowlog_reset(\n    **kwargs,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Remove all items in the slowlog</p> <p>For more information see https://redis.io/commands/slowlog-reset</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.smembers","title":"smembers","text":"<pre><code>smembers(\n    name: str,\n) -&gt; typing.Union[typing.Awaitable[typing.Set], typing.Set]\n</code></pre> <p>Return all members of the set <code>name</code></p> <p>For more information see https://redis.io/commands/smembers</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.smismember","title":"smismember","text":"<pre><code>smismember(\n    name: str, values: typing.List, *args: typing.List\n) -&gt; typing.Union[\n    typing.Awaitable[\n        typing.List[\n            typing.Union[\n                typing.Literal[0], typing.Literal[1]\n            ]\n        ]\n    ],\n    typing.List[\n        typing.Union[typing.Literal[0], typing.Literal[1]]\n    ],\n]\n</code></pre> <p>Return whether each value in <code>values</code> is a member of the set <code>name</code> as a list of <code>int</code> in the order of <code>values</code>: - 1 if the value is a member of the set. - 0 if the value is not a member of the set or if key does not exist.</p> <p>For more information see https://redis.io/commands/smismember</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.smove","title":"smove","text":"<pre><code>smove(\n    src: str, dst: str, value: str\n) -&gt; typing.Union[typing.Awaitable[bool], bool]\n</code></pre> <p>Move <code>value</code> from set <code>src</code> to set <code>dst</code> atomically</p> <p>For more information see https://redis.io/commands/smove</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.sort","title":"sort","text":"<pre><code>sort(\n    name: str,\n    start: typing.Optional[int] = None,\n    num: typing.Optional[int] = None,\n    by: typing.Optional[str] = None,\n    get: typing.Optional[typing.List[str]] = None,\n    desc: bool = False,\n    alpha: bool = False,\n    store: typing.Optional[str] = None,\n    groups: typing.Optional[bool] = False,\n) -&gt; typing.Union[typing.List, int]\n</code></pre> <p>Sort and return the list, set or sorted set at <code>name</code>.</p> <p><code>start</code> and <code>num</code> allow for paging through the sorted data</p> <p><code>by</code> allows using an external key to weight and sort the items.     Use an \"*\" to indicate where in the key the item value is located</p> <p><code>get</code> allows for returning items from external keys rather than the     sorted data itself.  Use an \"*\" to indicate where in the key     the item value is located</p> <p><code>desc</code> allows for reversing the sort</p> <p><code>alpha</code> allows for sorting lexicographically rather than numerically</p> <p><code>store</code> allows for storing the result of the sort into     the key <code>store</code></p> <p><code>groups</code> if set to True and if <code>get</code> contains at least two     elements, sort will return a list of tuples, each containing the     values fetched from the arguments to <code>get</code>.</p> <p>For more information see https://redis.io/commands/sort</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.sort_ro","title":"sort_ro","text":"<pre><code>sort_ro(\n    key: str,\n    start: typing.Optional[int] = None,\n    num: typing.Optional[int] = None,\n    by: typing.Optional[str] = None,\n    get: typing.Optional[typing.List[str]] = None,\n    desc: bool = False,\n    alpha: bool = False,\n) -&gt; list\n</code></pre> <p>Returns the elements contained in the list, set or sorted set at key. (read-only variant of the SORT command)</p> <p><code>start</code> and <code>num</code> allow for paging through the sorted data</p> <p><code>by</code> allows using an external key to weight and sort the items.     Use an \"*\" to indicate where in the key the item value is located</p> <p><code>get</code> allows for returning items from external keys rather than the     sorted data itself.  Use an \"*\" to indicate where in the key     the item value is located</p> <p><code>desc</code> allows for reversing the sort</p> <p><code>alpha</code> allows for sorting lexicographically rather than numerically</p> <p>For more information see https://redis.io/commands/sort_ro</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.spop","title":"spop","text":"<pre><code>spop(\n    name: str, count: typing.Optional[int] = None\n) -&gt; typing.Union[str, typing.List, None]\n</code></pre> <p>Remove and return a random member of set <code>name</code></p> <p>For more information see https://redis.io/commands/spop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.spublish","title":"spublish","text":"<pre><code>spublish(\n    shard_channel: redis.typing.ChannelT,\n    message: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Posts a message to the given shard channel. Returns the number of clients that received the message</p> <p>For more information see https://redis.io/commands/spublish</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.srandmember","title":"srandmember","text":"<pre><code>srandmember(\n    name: str, number: typing.Optional[int] = None\n) -&gt; typing.Union[str, typing.List, None]\n</code></pre> <p>If <code>number</code> is None, returns a random member of set <code>name</code>.</p> <p>If <code>number</code> is supplied, returns a list of <code>number</code> random members of set <code>name</code>. Note this is only available when running Redis 2.6+.</p> <p>For more information see https://redis.io/commands/srandmember</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.srem","title":"srem","text":"<pre><code>srem(\n    name: str, *values: redis.typing.FieldT\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Remove <code>values</code> from set <code>name</code></p> <p>For more information see https://redis.io/commands/srem</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.sscan","title":"sscan","text":"<pre><code>sscan(\n    name: kvdb.types.generic.KeyT,\n    cursor: int = 0,\n    match: typing.Union[\n        kvdb.types.generic.PatternT, None\n    ] = None,\n    count: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Incrementally return lists of elements in a set. Also return a cursor indicating the scan position.</p> <p><code>match</code> allows for filtering the keys by pattern</p> <p><code>count</code> allows for hint the minimum number of returns</p> <p>For more information see https://redis.io/commands/sscan</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.sscan_iter","title":"sscan_iter","text":"<pre><code>sscan_iter(\n    name: kvdb.types.generic.KeyT,\n    match: typing.Union[\n        kvdb.types.generic.PatternT, None\n    ] = None,\n    count: typing.Union[int, None] = None,\n) -&gt; typing.Iterator\n</code></pre> <p>Make an iterator using the SSCAN command so that the client doesn't need to remember the cursor position.</p> <p><code>match</code> allows for filtering the keys by pattern</p> <p><code>count</code> allows for hint the minimum number of returns</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.stralgo","title":"stralgo","text":"<pre><code>stralgo(\n    algo: typing.Literal[\"LCS\"],\n    value1: kvdb.types.generic.KeyT,\n    value2: kvdb.types.generic.KeyT,\n    specific_argument: typing.Union[\n        typing.Literal[\"strings\"], typing.Literal[\"keys\"]\n    ] = \"strings\",\n    len: bool = False,\n    idx: bool = False,\n    minmatchlen: typing.Union[int, None] = None,\n    withmatchlen: bool = False,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Implements complex algorithms that operate on strings. Right now the only algorithm implemented is the LCS algorithm (longest common substring). However new algorithms could be implemented in the future.</p> <p><code>algo</code> Right now must be LCS <code>value1</code> and <code>value2</code> Can be two strings or two keys <code>specific_argument</code> Specifying if the arguments to the algorithm will be keys or strings. strings is the default. <code>len</code> Returns just the len of the match. <code>idx</code> Returns the match positions in each string. <code>minmatchlen</code> Restrict the list of matches to the ones of a given minimal length. Can be provided only when <code>idx</code> set to True. <code>withmatchlen</code> Returns the matches with the len of the match. Can be provided only when <code>idx</code> set to True.</p> <p>For more information see https://redis.io/commands/stralgo</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.strlen","title":"strlen","text":"<pre><code>strlen(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the number of bytes stored in the value of <code>name</code></p> <p>For more information see https://redis.io/commands/strlen</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.substr","title":"substr","text":"<pre><code>substr(\n    name: kvdb.types.generic.KeyT, start: int, end: int = -1\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a substring of the string at key <code>name</code>. <code>start</code> and <code>end</code> are 0-based integers specifying the portion of the string to return.</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.sunion","title":"sunion","text":"<pre><code>sunion(\n    keys: typing.List, *args: typing.List\n) -&gt; typing.Union[\n    typing.Awaitable[typing.List], typing.List\n]\n</code></pre> <p>Return the union of sets specified by <code>keys</code></p> <p>For more information see https://redis.io/commands/sunion</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.sunionstore","title":"sunionstore","text":"<pre><code>sunionstore(\n    dest: str, keys: typing.List, *args: typing.List\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Store the union of sets specified by <code>keys</code> into a new set named <code>dest</code>.  Returns the number of keys in the new set.</p> <p>For more information see https://redis.io/commands/sunionstore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.swapdb","title":"swapdb","text":"<pre><code>swapdb(\n    first: int, second: int, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Swap two databases</p> <p>For more information see https://redis.io/commands/swapdb</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.sync","title":"sync","text":"<pre><code>sync() -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Initiates a replication stream from the master.</p> <p>For more information see https://redis.io/commands/sync</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.tfcall","title":"tfcall","text":"<pre><code>tfcall(\n    lib_name: str,\n    func_name: str,\n    keys: redis.typing.KeysT = None,\n    *args: typing.List\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Invoke a function.</p> <p><code>lib_name</code> - the library name contains the function. <code>func_name</code> - the function name to run. <code>keys</code> - the keys that will be touched by the function. <code>args</code> - Additional argument to pass to the function.</p> <p>For more information see https://redis.io/commands/tfcall/</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.tfcall_async","title":"tfcall_async","text":"<pre><code>tfcall_async(\n    lib_name: str,\n    func_name: str,\n    keys: redis.typing.KeysT = None,\n    *args: typing.List\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Invoke an async function (coroutine).</p> <p><code>lib_name</code> - the library name contains the function. <code>func_name</code> - the function name to run. <code>keys</code> - the keys that will be touched by the function. <code>args</code> - Additional argument to pass to the function.</p> <p>For more information see https://redis.io/commands/tfcall/</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.tfunction_delete","title":"tfunction_delete","text":"<pre><code>tfunction_delete(\n    lib_name: str,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Delete a library from RedisGears.</p> <p><code>lib_name</code> the library name to delete.</p> <p>For more information see https://redis.io/commands/tfunction-delete/</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.tfunction_list","title":"tfunction_list","text":"<pre><code>tfunction_list(\n    with_code: bool = False,\n    verbose: int = 0,\n    lib_name: typing.Union[str, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>List the functions with additional information about each function.</p> <p><code>with_code</code> Show libraries code. <code>verbose</code> output verbosity level, higher number will increase verbosity level <code>lib_name</code> specifying a library name (can be used multiple times to show multiple libraries in a single command) # noqa</p> <p>For more information see https://redis.io/commands/tfunction-list/</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.tfunction_load","title":"tfunction_load","text":"<pre><code>tfunction_load(\n    lib_code: str,\n    replace: bool = False,\n    config: typing.Union[str, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Load a new library to RedisGears.</p> <p><code>lib_code</code> - the library code. <code>config</code> - a string representation of a JSON object that will be provided to the library on load time, for more information refer to https://github.com/RedisGears/RedisGears/blob/master/docs/function_advance_topics.md#library-configuration <code>replace</code> - an optional argument, instructs RedisGears to replace the function if its already exists</p> <p>For more information see https://redis.io/commands/tfunction-load/</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.time","title":"time","text":"<pre><code>time(**kwargs) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the server time as a 2-item tuple of ints: (seconds since epoch, microseconds into this second).</p> <p>For more information see https://redis.io/commands/time</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.touch","title":"touch","text":"<pre><code>touch(\n    *args: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Alters the last access time of a key(s) <code>*args</code>. A key is ignored if it does not exist.</p> <p>For more information see https://redis.io/commands/touch</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.ttl","title":"ttl","text":"<pre><code>ttl(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the number of seconds until the key <code>name</code> will expire</p> <p>For more information see https://redis.io/commands/ttl</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.type","title":"type","text":"<pre><code>type(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the type of key <code>name</code></p> <p>For more information see https://redis.io/commands/type</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.unlink","title":"unlink","text":"<pre><code>unlink(\n    *names: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Unlink one or more keys specified by <code>names</code></p> <p>For more information see https://redis.io/commands/unlink</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.unwatch","title":"unwatch","text":"<pre><code>unwatch() -&gt; None\n</code></pre> <p>Unwatches the value at key <code>name</code>, or None of the key doesn't exist</p> <p>For more information see https://redis.io/commands/unwatch</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.wait","title":"wait","text":"<pre><code>wait(\n    num_replicas: int, timeout: int, **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Redis synchronous replication That returns the number of replicas that processed the query when we finally have at least <code>num_replicas</code>, or when the <code>timeout</code> was reached.</p> <p>For more information see https://redis.io/commands/wait</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.waitaof","title":"waitaof","text":"<pre><code>waitaof(\n    num_local: int,\n    num_replicas: int,\n    timeout: int,\n    **kwargs\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>This command blocks the current client until all previous write commands by that client are acknowledged as having been fsynced to the AOF of the local Redis and/or at least the specified number of replicas.</p> <p>For more information see https://redis.io/commands/waitaof</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.watch","title":"watch","text":"<pre><code>watch(*names: kvdb.types.generic.KeyT) -&gt; None\n</code></pre> <p>Watches the values at keys <code>names</code>, or None if the key doesn't exist</p> <p>For more information see https://redis.io/commands/watch</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xack","title":"xack","text":"<pre><code>xack(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n    *ids: redis.typing.StreamIdT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Acknowledges the successful processing of one or more messages. name: name of the stream. groupname: name of the consumer group. *ids: message ids to acknowledge.</p> <p>For more information see https://redis.io/commands/xack</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xadd","title":"xadd","text":"<pre><code>xadd(\n    name: kvdb.types.generic.KeyT,\n    fields: typing.Dict[\n        redis.typing.FieldT, redis.typing.EncodableT\n    ],\n    id: redis.typing.StreamIdT = \"*\",\n    maxlen: typing.Union[int, None] = None,\n    approximate: bool = True,\n    nomkstream: bool = False,\n    minid: typing.Union[\n        redis.typing.StreamIdT, None\n    ] = None,\n    limit: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Add to a stream. name: name of the stream fields: dict of field/value pairs to insert into the stream id: Location to insert this record. By default it is appended. maxlen: truncate old stream members beyond this size. Can't be specified with minid. approximate: actual stream length may be slightly more than maxlen nomkstream: When set to true, do not make a stream minid: the minimum id in the stream to query. Can't be specified with maxlen. limit: specifies the maximum number of entries to retrieve</p> <p>For more information see https://redis.io/commands/xadd</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xautoclaim","title":"xautoclaim","text":"<pre><code>xautoclaim(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n    consumername: redis.typing.ConsumerT,\n    min_idle_time: int,\n    start_id: redis.typing.StreamIdT = \"0-0\",\n    count: typing.Union[int, None] = None,\n    justid: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Transfers ownership of pending stream entries that match the specified criteria. Conceptually, equivalent to calling XPENDING and then XCLAIM, but provides a more straightforward way to deal with message delivery failures via SCAN-like semantics. name: name of the stream. groupname: name of the consumer group. consumername: name of a consumer that claims the message. min_idle_time: filter messages that were idle less than this amount of milliseconds. start_id: filter messages with equal or greater ID. count: optional integer, upper limit of the number of entries that the command attempts to claim. Set to 100 by default. justid: optional boolean, false by default. Return just an array of IDs of messages successfully claimed, without returning the actual message</p> <p>For more information see https://redis.io/commands/xautoclaim</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xclaim","title":"xclaim","text":"<pre><code>xclaim(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n    consumername: redis.typing.ConsumerT,\n    min_idle_time: int,\n    message_ids: typing.Union[\n        typing.List[redis.typing.StreamIdT],\n        typing.Tuple[redis.typing.StreamIdT],\n    ],\n    idle: typing.Union[int, None] = None,\n    time: typing.Union[int, None] = None,\n    retrycount: typing.Union[int, None] = None,\n    force: bool = False,\n    justid: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Changes the ownership of a pending message.</p> <p>name: name of the stream.</p> <p>groupname: name of the consumer group.</p> <p>consumername: name of a consumer that claims the message.</p> <p>min_idle_time: filter messages that were idle less than this amount of milliseconds</p> <p>message_ids: non-empty list or tuple of message IDs to claim</p> <p>idle: optional. Set the idle time (last time it was delivered) of the message in ms</p> <p>time: optional integer. This is the same as idle but instead of a relative amount of milliseconds, it sets the idle time to a specific Unix time (in milliseconds).</p> <p>retrycount: optional integer. set the retry counter to the specified value. This counter is incremented every time a message is delivered again.</p> <p>force: optional boolean, false by default. Creates the pending message entry in the PEL even if certain specified IDs are not already in the PEL assigned to a different client.</p> <p>justid: optional boolean, false by default. Return just an array of IDs of messages successfully claimed, without returning the actual message</p> <p>For more information see https://redis.io/commands/xclaim</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xdel","title":"xdel","text":"<pre><code>xdel(\n    name: kvdb.types.generic.KeyT,\n    *ids: redis.typing.StreamIdT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Deletes one or more messages from a stream. name: name of the stream. *ids: message ids to delete.</p> <p>For more information see https://redis.io/commands/xdel</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xgroup_create","title":"xgroup_create","text":"<pre><code>xgroup_create(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n    id: redis.typing.StreamIdT = \"$\",\n    mkstream: bool = False,\n    entries_read: typing.Optional[int] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Create a new consumer group associated with a stream. name: name of the stream. groupname: name of the consumer group. id: ID of the last item in the stream to consider already delivered.</p> <p>For more information see https://redis.io/commands/xgroup-create</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xgroup_createconsumer","title":"xgroup_createconsumer","text":"<pre><code>xgroup_createconsumer(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n    consumername: redis.typing.ConsumerT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Consumers in a consumer group are auto-created every time a new consumer name is mentioned by some command. They can be explicitly created by using this command. name: name of the stream. groupname: name of the consumer group. consumername: name of consumer to create.</p> <p>See: https://redis.io/commands/xgroup-createconsumer</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xgroup_delconsumer","title":"xgroup_delconsumer","text":"<pre><code>xgroup_delconsumer(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n    consumername: redis.typing.ConsumerT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Remove a specific consumer from a consumer group. Returns the number of pending messages that the consumer had before it was deleted. name: name of the stream. groupname: name of the consumer group. consumername: name of consumer to delete</p> <p>For more information see https://redis.io/commands/xgroup-delconsumer</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xgroup_destroy","title":"xgroup_destroy","text":"<pre><code>xgroup_destroy(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Destroy a consumer group. name: name of the stream. groupname: name of the consumer group.</p> <p>For more information see https://redis.io/commands/xgroup-destroy</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xgroup_setid","title":"xgroup_setid","text":"<pre><code>xgroup_setid(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n    id: redis.typing.StreamIdT,\n    entries_read: typing.Optional[int] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set the consumer group last delivered ID to something else. name: name of the stream. groupname: name of the consumer group. id: ID of the last item in the stream to consider already delivered.</p> <p>For more information see https://redis.io/commands/xgroup-setid</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xinfo_consumers","title":"xinfo_consumers","text":"<pre><code>xinfo_consumers(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns general information about the consumers in the group. name: name of the stream. groupname: name of the consumer group.</p> <p>For more information see https://redis.io/commands/xinfo-consumers</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xinfo_groups","title":"xinfo_groups","text":"<pre><code>xinfo_groups(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns general information about the consumer groups of the stream. name: name of the stream.</p> <p>For more information see https://redis.io/commands/xinfo-groups</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xinfo_stream","title":"xinfo_stream","text":"<pre><code>xinfo_stream(\n    name: kvdb.types.generic.KeyT, full: bool = False\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns general information about the stream. name: name of the stream. full: optional boolean, false by default. Return full summary</p> <p>For more information see https://redis.io/commands/xinfo-stream</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xlen","title":"xlen","text":"<pre><code>xlen(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the number of elements in a given stream.</p> <p>For more information see https://redis.io/commands/xlen</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xpending","title":"xpending","text":"<pre><code>xpending(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns information about pending messages of a group. name: name of the stream. groupname: name of the consumer group.</p> <p>For more information see https://redis.io/commands/xpending</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xpending_range","title":"xpending_range","text":"<pre><code>xpending_range(\n    name: kvdb.types.generic.KeyT,\n    groupname: redis.typing.GroupT,\n    min: redis.typing.StreamIdT,\n    max: redis.typing.StreamIdT,\n    count: int,\n    consumername: typing.Union[\n        redis.typing.ConsumerT, None\n    ] = None,\n    idle: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns information about pending messages, in a range.</p> <p>name: name of the stream. groupname: name of the consumer group. idle: available from  version 6.2. filter entries by their idle-time, given in milliseconds (optional). min: minimum stream ID. max: maximum stream ID. count: number of messages to return consumername: name of a consumer to filter by (optional).</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xrange","title":"xrange","text":"<pre><code>xrange(\n    name: kvdb.types.generic.KeyT,\n    min: redis.typing.StreamIdT = \"-\",\n    max: redis.typing.StreamIdT = \"+\",\n    count: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Read stream values within an interval.</p> <p>name: name of the stream.</p> first stream ID. defaults to '-', <p>meaning the earliest available.</p> last stream ID. defaults to '+', <p>meaning the latest available.</p> if set, only return this many items, beginning with the <p>earliest available.</p> <p>For more information see https://redis.io/commands/xrange</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xread","title":"xread","text":"<pre><code>xread(\n    streams: typing.Dict[\n        kvdb.types.generic.KeyT, redis.typing.StreamIdT\n    ],\n    count: typing.Union[int, None] = None,\n    block: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Block and monitor multiple streams for new data.</p> a dict of stream names to stream IDs, where <p>IDs indicate the last ID already seen.</p> if set, only return this many items, beginning with the <p>earliest available.</p> <p>block: number of milliseconds to wait, if nothing already present.</p> <p>For more information see https://redis.io/commands/xread</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xreadgroup","title":"xreadgroup","text":"<pre><code>xreadgroup(\n    groupname: str,\n    consumername: str,\n    streams: typing.Dict[\n        kvdb.types.generic.KeyT, redis.typing.StreamIdT\n    ],\n    count: typing.Union[int, None] = None,\n    block: typing.Union[int, None] = None,\n    noack: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Read from a stream via a consumer group.</p> <p>groupname: name of the consumer group.</p> <p>consumername: name of the requesting consumer.</p> a dict of stream names to stream IDs, where <p>IDs indicate the last ID already seen.</p> if set, only return this many items, beginning with the <p>earliest available.</p> <p>block: number of milliseconds to wait, if nothing already present. noack: do not add messages to the PEL</p> <p>For more information see https://redis.io/commands/xreadgroup</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xrevrange","title":"xrevrange","text":"<pre><code>xrevrange(\n    name: kvdb.types.generic.KeyT,\n    max: redis.typing.StreamIdT = \"+\",\n    min: redis.typing.StreamIdT = \"-\",\n    count: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Read stream values within an interval, in reverse order.</p> <p>name: name of the stream</p> first stream ID. defaults to '+', <p>meaning the latest available.</p> last stream ID. defaults to '-', <p>meaning the earliest available.</p> if set, only return this many items, beginning with the <p>latest available.</p> <p>For more information see https://redis.io/commands/xrevrange</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.xtrim","title":"xtrim","text":"<pre><code>xtrim(\n    name: kvdb.types.generic.KeyT,\n    maxlen: typing.Union[int, None] = None,\n    approximate: bool = True,\n    minid: typing.Union[\n        redis.typing.StreamIdT, None\n    ] = None,\n    limit: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Trims old messages from a stream. name: name of the stream. maxlen: truncate old stream messages beyond this size Can't be specified with minid. approximate: actual stream length may be slightly more than maxlen minid: the minimum id in the stream to query Can't be specified with maxlen. limit: specifies the maximum number of entries to retrieve</p> <p>For more information see https://redis.io/commands/xtrim</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zadd","title":"zadd","text":"<pre><code>zadd(\n    name: kvdb.types.generic.KeyT,\n    mapping: typing.Mapping[\n        redis.typing.AnyKeyT, redis.typing.EncodableT\n    ],\n    nx: bool = False,\n    xx: bool = False,\n    ch: bool = False,\n    incr: bool = False,\n    gt: bool = False,\n    lt: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Set any number of element-name, score pairs to the key <code>name</code>. Pairs are specified as a dict of element-names keys to score values.</p> <p><code>nx</code> forces ZADD to only create new elements and not to update scores for elements that already exist.</p> <p><code>xx</code> forces ZADD to only update scores of elements that already exist. New elements will not be added.</p> <p><code>ch</code> modifies the return value to be the numbers of elements changed. Changed elements include new elements that were added and elements whose scores changed.</p> <p><code>incr</code> modifies ZADD to behave like ZINCRBY. In this mode only a single element/score pair can be specified and the score is the amount the existing score will be incremented by. When using this mode the return value of ZADD will be the new score of the element.</p> <p><code>LT</code> Only update existing elements if the new score is less than the current score. This flag doesn't prevent adding new elements.</p> <p><code>GT</code> Only update existing elements if the new score is greater than the current score. This flag doesn't prevent adding new elements.</p> <p>The return value of ZADD varies based on the mode specified. With no options, ZADD returns the number of new elements added to the sorted set.</p> <p><code>NX</code>, <code>LT</code>, and <code>GT</code> are mutually exclusive options.</p> <p>See: https://redis.io/commands/ZADD</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zcard","title":"zcard","text":"<pre><code>zcard(\n    name: kvdb.types.generic.KeyT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the number of elements in the sorted set <code>name</code></p> <p>For more information see https://redis.io/commands/zcard</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zcount","title":"zcount","text":"<pre><code>zcount(\n    name: kvdb.types.generic.KeyT,\n    min: redis.typing.ZScoreBoundT,\n    max: redis.typing.ZScoreBoundT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the number of elements in the sorted set at key <code>name</code> with a score between <code>min</code> and <code>max</code>.</p> <p>For more information see https://redis.io/commands/zcount</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zdiff","title":"zdiff","text":"<pre><code>zdiff(\n    keys: redis.typing.KeysT, withscores: bool = False\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the difference between the first and all successive input sorted sets provided in <code>keys</code>.</p> <p>For more information see https://redis.io/commands/zdiff</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zdiffstore","title":"zdiffstore","text":"<pre><code>zdiffstore(\n    dest: kvdb.types.generic.KeyT, keys: redis.typing.KeysT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Computes the difference between the first and all successive input sorted sets provided in <code>keys</code> and stores the result in <code>dest</code>.</p> <p>For more information see https://redis.io/commands/zdiffstore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zincrby","title":"zincrby","text":"<pre><code>zincrby(\n    name: kvdb.types.generic.KeyT,\n    amount: float,\n    value: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Increment the score of <code>value</code> in sorted set <code>name</code> by <code>amount</code></p> <p>For more information see https://redis.io/commands/zincrby</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zinter","title":"zinter","text":"<pre><code>zinter(\n    keys: redis.typing.KeysT,\n    aggregate: typing.Union[str, None] = None,\n    withscores: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the intersect of multiple sorted sets specified by <code>keys</code>. With the <code>aggregate</code> option, it is possible to specify how the results of the union are aggregated. This option defaults to SUM, where the score of an element is summed across the inputs where it exists. When this option is set to either MIN or MAX, the resulting set will contain the minimum or maximum score of an element across the inputs where it exists.</p> <p>For more information see https://redis.io/commands/zinter</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zintercard","title":"zintercard","text":"<pre><code>zintercard(\n    numkeys: int, keys: typing.List[str], limit: int = 0\n) -&gt; typing.Union[typing.Awaitable[int], int]\n</code></pre> <p>Return the cardinality of the intersect of multiple sorted sets specified by <code>`keys</code>. When LIMIT provided (defaults to 0 and means unlimited), if the intersection cardinality reaches limit partway through the computation, the algorithm will exit and yield limit as the cardinality</p> <p>For more information see https://redis.io/commands/zintercard</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zinterstore","title":"zinterstore","text":"<pre><code>zinterstore(\n    dest: kvdb.types.generic.KeyT,\n    keys: typing.Union[\n        typing.Sequence[kvdb.types.generic.KeyT],\n        typing.Mapping[redis.typing.AnyKeyT, float],\n    ],\n    aggregate: typing.Union[str, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Intersect multiple sorted sets specified by <code>keys</code> into a new sorted set, <code>dest</code>. Scores in the destination will be aggregated based on the <code>aggregate</code>. This option defaults to SUM, where the score of an element is summed across the inputs where it exists. When this option is set to either MIN or MAX, the resulting set will contain the minimum or maximum score of an element across the inputs where it exists.</p> <p>For more information see https://redis.io/commands/zinterstore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zlexcount","title":"zlexcount","text":"<pre><code>zlexcount(name, min, max)\n</code></pre> <p>Return the number of items in the sorted set <code>name</code> between the lexicographical range <code>min</code> and <code>max</code>.</p> <p>For more information see https://redis.io/commands/zlexcount</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zmpop","title":"zmpop","text":"<pre><code>zmpop(\n    num_keys: int,\n    keys: typing.List[str],\n    min: typing.Optional[bool] = False,\n    max: typing.Optional[bool] = False,\n    count: typing.Optional[int] = 1,\n) -&gt; typing.Union[typing.Awaitable[list], list]\n</code></pre> <p>Pop <code>count</code> values (default 1) off of the first non-empty sorted set named in the <code>keys</code> list. For more information see https://redis.io/commands/zmpop</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zmscore","title":"zmscore","text":"<pre><code>zmscore(\n    key: kvdb.types.generic.KeyT, members: typing.List[str]\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns the scores associated with the specified members in the sorted set stored at key. <code>members</code> should be a list of the member name. Return type is a list of score. If the member does not exist, a None will be returned in corresponding position.</p> <p>For more information see https://redis.io/commands/zmscore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zpopmax","title":"zpopmax","text":"<pre><code>zpopmax(\n    name: kvdb.types.generic.KeyT,\n    count: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Remove and return up to <code>count</code> members with the highest scores from the sorted set <code>name</code>.</p> <p>For more information see https://redis.io/commands/zpopmax</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zpopmin","title":"zpopmin","text":"<pre><code>zpopmin(\n    name: kvdb.types.generic.KeyT,\n    count: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Remove and return up to <code>count</code> members with the lowest scores from the sorted set <code>name</code>.</p> <p>For more information see https://redis.io/commands/zpopmin</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zrandmember","title":"zrandmember","text":"<pre><code>zrandmember(\n    key: kvdb.types.generic.KeyT,\n    count: int = None,\n    withscores: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a random element from the sorted set value stored at key.</p> <p><code>count</code> if the argument is positive, return an array of distinct fields. If called with a negative count, the behavior changes and the command is allowed to return the same field multiple times. In this case, the number of returned fields is the absolute value of the specified count.</p> <p><code>withscores</code> The optional WITHSCORES modifier changes the reply so it includes the respective scores of the randomly selected elements from the sorted set.</p> <p>For more information see https://redis.io/commands/zrandmember</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zrange","title":"zrange","text":"<pre><code>zrange(\n    name: kvdb.types.generic.KeyT,\n    start: int,\n    end: int,\n    desc: bool = False,\n    withscores: bool = False,\n    score_cast_func: typing.Union[\n        kvdb.components.session.KVDBSession.type,\n        typing.Callable,\n    ] = ...,\n    byscore: bool = False,\n    bylex: bool = False,\n    offset: int = None,\n    num: int = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a range of values from sorted set <code>name</code> between <code>start</code> and <code>end</code> sorted in ascending order.</p> <p><code>start</code> and <code>end</code> can be negative, indicating the end of the range.</p> <p><code>desc</code> a boolean indicating whether to sort the results in reversed order.</p> <p><code>withscores</code> indicates to return the scores along with the values. The return type is a list of (value, score) pairs.</p> <p><code>score_cast_func</code> a callable used to cast the score return value.</p> <p><code>byscore</code> when set to True, returns the range of elements from the sorted set having scores equal or between <code>start</code> and <code>end</code>.</p> <p><code>bylex</code> when set to True, returns the range of elements from the sorted set between the <code>start</code> and <code>end</code> lexicographical closed range intervals. Valid <code>start</code> and <code>end</code> must start with ( or [, in order to specify whether the range interval is exclusive or inclusive, respectively.</p> <p><code>offset</code> and <code>num</code> are specified, then return a slice of the range. Can't be provided when using <code>bylex</code>.</p> <p>For more information see https://redis.io/commands/zrange</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zrangebylex","title":"zrangebylex","text":"<pre><code>zrangebylex(\n    name: kvdb.types.generic.KeyT,\n    min: redis.typing.EncodableT,\n    max: redis.typing.EncodableT,\n    start: typing.Union[int, None] = None,\n    num: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the lexicographical range of values from sorted set <code>name</code> between <code>min</code> and <code>max</code>.</p> <p>If <code>start</code> and <code>num</code> are specified, then return a slice of the range.</p> <p>For more information see https://redis.io/commands/zrangebylex</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zrangebyscore","title":"zrangebyscore","text":"<pre><code>zrangebyscore(\n    name: kvdb.types.generic.KeyT,\n    min: redis.typing.ZScoreBoundT,\n    max: redis.typing.ZScoreBoundT,\n    start: typing.Union[int, None] = None,\n    num: typing.Union[int, None] = None,\n    withscores: bool = False,\n    score_cast_func: typing.Union[\n        kvdb.components.session.KVDBSession.type,\n        typing.Callable,\n    ] = ...,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a range of values from the sorted set <code>name</code> with scores between <code>min</code> and <code>max</code>.</p> <p>If <code>start</code> and <code>num</code> are specified, then return a slice of the range.</p> <p><code>withscores</code> indicates to return the scores along with the values. The return type is a list of (value, score) pairs</p> <p>`score_cast_func`` a callable used to cast the score return value</p> <p>For more information see https://redis.io/commands/zrangebyscore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zrangestore","title":"zrangestore","text":"<pre><code>zrangestore(\n    dest: kvdb.types.generic.KeyT,\n    name: kvdb.types.generic.KeyT,\n    start: int,\n    end: int,\n    byscore: bool = False,\n    bylex: bool = False,\n    desc: bool = False,\n    offset: typing.Union[int, None] = None,\n    num: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Stores in <code>dest</code> the result of a range of values from sorted set <code>name</code> between <code>start</code> and <code>end</code> sorted in ascending order.</p> <p><code>start</code> and <code>end</code> can be negative, indicating the end of the range.</p> <p><code>byscore</code> when set to True, returns the range of elements from the sorted set having scores equal or between <code>start</code> and <code>end</code>.</p> <p><code>bylex</code> when set to True, returns the range of elements from the sorted set between the <code>start</code> and <code>end</code> lexicographical closed range intervals. Valid <code>start</code> and <code>end</code> must start with ( or [, in order to specify whether the range interval is exclusive or inclusive, respectively.</p> <p><code>desc</code> a boolean indicating whether to sort the results in reversed order.</p> <p><code>offset</code> and <code>num</code> are specified, then return a slice of the range. Can't be provided when using <code>bylex</code>.</p> <p>For more information see https://redis.io/commands/zrangestore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zrank","title":"zrank","text":"<pre><code>zrank(\n    name: kvdb.types.generic.KeyT,\n    value: redis.typing.EncodableT,\n    withscore: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a 0-based value indicating the rank of <code>value</code> in sorted set <code>name</code>. The optional WITHSCORE argument supplements the command's reply with the score of the element returned.</p> <p>For more information see https://redis.io/commands/zrank</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zrem","title":"zrem","text":"<pre><code>zrem(\n    name: kvdb.types.generic.KeyT,\n    *values: redis.typing.FieldT\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Remove member <code>values</code> from sorted set <code>name</code></p> <p>For more information see https://redis.io/commands/zrem</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zremrangebylex","title":"zremrangebylex","text":"<pre><code>zremrangebylex(\n    name: kvdb.types.generic.KeyT,\n    min: redis.typing.EncodableT,\n    max: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Remove all elements in the sorted set <code>name</code> between the lexicographical range specified by <code>min</code> and <code>max</code>.</p> <p>Returns the number of elements removed.</p> <p>For more information see https://redis.io/commands/zremrangebylex</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zremrangebyrank","title":"zremrangebyrank","text":"<pre><code>zremrangebyrank(\n    name: kvdb.types.generic.KeyT, min: int, max: int\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Remove all elements in the sorted set <code>name</code> with ranks between <code>min</code> and <code>max</code>. Values are 0-based, ordered from smallest score to largest. Values can be negative indicating the highest scores. Returns the number of elements removed</p> <p>For more information see https://redis.io/commands/zremrangebyrank</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zremrangebyscore","title":"zremrangebyscore","text":"<pre><code>zremrangebyscore(\n    name: kvdb.types.generic.KeyT,\n    min: redis.typing.ZScoreBoundT,\n    max: redis.typing.ZScoreBoundT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Remove all elements in the sorted set <code>name</code> with scores between <code>min</code> and <code>max</code>. Returns the number of elements removed.</p> <p>For more information see https://redis.io/commands/zremrangebyscore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zrevrange","title":"zrevrange","text":"<pre><code>zrevrange(\n    name: kvdb.types.generic.KeyT,\n    start: int,\n    end: int,\n    withscores: bool = False,\n    score_cast_func: typing.Union[\n        kvdb.components.session.KVDBSession.type,\n        typing.Callable,\n    ] = ...,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return a range of values from sorted set <code>name</code> between <code>start</code> and <code>end</code> sorted in descending order.</p> <p><code>start</code> and <code>end</code> can be negative, indicating the end of the range.</p> <p><code>withscores</code> indicates to return the scores along with the values The return type is a list of (value, score) pairs</p> <p><code>score_cast_func</code> a callable used to cast the score return value</p> <p>For more information see https://redis.io/commands/zrevrange</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zrevrangebylex","title":"zrevrangebylex","text":"<pre><code>zrevrangebylex(\n    name: kvdb.types.generic.KeyT,\n    max: redis.typing.EncodableT,\n    min: redis.typing.EncodableT,\n    start: typing.Union[int, None] = None,\n    num: typing.Union[int, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the reversed lexicographical range of values from sorted set <code>name</code> between <code>max</code> and <code>min</code>.</p> <p>If <code>start</code> and <code>num</code> are specified, then return a slice of the range.</p> <p>For more information see https://redis.io/commands/zrevrangebylex</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zrevrangebyscore","title":"zrevrangebyscore","text":"<pre><code>zrevrangebyscore(\n    name: kvdb.types.generic.KeyT,\n    max: redis.typing.ZScoreBoundT,\n    min: redis.typing.ZScoreBoundT,\n    start: typing.Union[int, None] = None,\n    num: typing.Union[int, None] = None,\n    withscores: bool = False,\n    score_cast_func: typing.Union[\n        kvdb.components.session.KVDBSession.type,\n        typing.Callable,\n    ] = ...,\n)\n</code></pre> <p>Return a range of values from the sorted set <code>name</code> with scores between <code>min</code> and <code>max</code> in descending order.</p> <p>If <code>start</code> and <code>num</code> are specified, then return a slice of the range.</p> <p><code>withscores</code> indicates to return the scores along with the values. The return type is a list of (value, score) pairs</p> <p><code>score_cast_func</code> a callable used to cast the score return value</p> <p>For more information see https://redis.io/commands/zrevrangebyscore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zrevrank","title":"zrevrank","text":"<pre><code>zrevrank(\n    name: kvdb.types.generic.KeyT,\n    value: redis.typing.EncodableT,\n    withscore: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Returns a 0-based value indicating the descending rank of <code>value</code> in sorted set <code>name</code>. The optional <code>withscore</code> argument supplements the command's reply with the score of the element returned.</p> <p>For more information see https://redis.io/commands/zrevrank</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zscan","title":"zscan","text":"<pre><code>zscan(\n    name: kvdb.types.generic.KeyT,\n    cursor: int = 0,\n    match: typing.Union[\n        kvdb.types.generic.PatternT, None\n    ] = None,\n    count: typing.Union[int, None] = None,\n    score_cast_func: typing.Union[\n        kvdb.components.session.KVDBSession.type,\n        typing.Callable,\n    ] = ...,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Incrementally return lists of elements in a sorted set. Also return a cursor indicating the scan position.</p> <p><code>match</code> allows for filtering the keys by pattern</p> <p><code>count</code> allows for hint the minimum number of returns</p> <p><code>score_cast_func</code> a callable used to cast the score return value</p> <p>For more information see https://redis.io/commands/zscan</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zscan_iter","title":"zscan_iter","text":"<pre><code>zscan_iter(\n    name: kvdb.types.generic.KeyT,\n    match: typing.Union[\n        kvdb.types.generic.PatternT, None\n    ] = None,\n    count: typing.Union[int, None] = None,\n    score_cast_func: typing.Union[\n        kvdb.components.session.KVDBSession.type,\n        typing.Callable,\n    ] = ...,\n) -&gt; typing.Iterator\n</code></pre> <p>Make an iterator using the ZSCAN command so that the client doesn't need to remember the cursor position.</p> <p><code>match</code> allows for filtering the keys by pattern</p> <p><code>count</code> allows for hint the minimum number of returns</p> <p><code>score_cast_func</code> a callable used to cast the score return value</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zscore","title":"zscore","text":"<pre><code>zscore(\n    name: kvdb.types.generic.KeyT,\n    value: redis.typing.EncodableT,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the score of element <code>value</code> in sorted set <code>name</code></p> <p>For more information see https://redis.io/commands/zscore</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zunion","title":"zunion","text":"<pre><code>zunion(\n    keys: typing.Union[\n        typing.Sequence[kvdb.types.generic.KeyT],\n        typing.Mapping[redis.typing.AnyKeyT, float],\n    ],\n    aggregate: typing.Union[str, None] = None,\n    withscores: bool = False,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Return the union of multiple sorted sets specified by <code>keys</code>. <code>keys</code> can be provided as dictionary of keys and their weights. Scores will be aggregated based on the <code>aggregate</code>, or SUM if none is provided.</p> <p>For more information see https://redis.io/commands/zunion</p>"},{"location":"api/sessions/api/#kvdb.components.session.KVDBSession.zunionstore","title":"zunionstore","text":"<pre><code>zunionstore(\n    dest: kvdb.types.generic.KeyT,\n    keys: typing.Union[\n        typing.Sequence[kvdb.types.generic.KeyT],\n        typing.Mapping[redis.typing.AnyKeyT, float],\n    ],\n    aggregate: typing.Union[str, None] = None,\n) -&gt; kvdb.components.session.ResponseT\n</code></pre> <p>Union multiple sorted sets specified by <code>keys</code> into a new sorted set, <code>dest</code>. Scores in the destination will be aggregated based on the <code>aggregate</code>, or SUM if none is provided.</p> <p>For more information see https://redis.io/commands/zunionstore</p>"},{"location":"topics/cachify/","title":"Overview","text":"<p>Create and Manage Caching with KVDB.</p> <p>Cachify is a simple caching class that provides a context manager interface for caching objects, functions with flexibility in how you encode, decode, serialize, and compress your data.</p> <ul> <li>Context Manager</li> <li>Cachify Context</li> <li>Cachify Object</li> <li>API Reference</li> </ul>"},{"location":"topics/cachify/#basic-usage","title":"Basic Usage","text":"<p>The following module provides an aliased interface to the KVDB <code>Cachify</code> classes.</p> basic.py<pre><code>\"\"\"\nA Very basic demonstration of how to use cachify\n\nWithout any arguments, cachify will use the default settings and initialize\na default session.\n\n\nRun this example:\n\n    # cwd: examples/caching\n    $ python basic.py\n\"\"\"\n\nimport time\nimport asyncio\nfrom lazyops.utils.times import Timer\nfrom kvdb.io import cachify\nfrom kvdb.utils.logs import logger\n\nDEBUG_ENABLED = False\n\n@cachify.register(ttl = 10, verbosity = 2 if DEBUG_ENABLED else None, cache_max_size = 15)\nasync def async_fibonacci(number: int):\n    if number == 0: return 0\n    elif number == 1: return 1\n    return await async_fibonacci(number - 1) + await async_fibonacci(number - 2)\n\n@cachify.register(ttl = 10, verbosity = 2 if DEBUG_ENABLED else None)\ndef fibonacci(number: int):\n    if number == 0: return 0\n    elif number == 1: return 1\n    return fibonacci(number - 1) + fibonacci(number - 2)\n\n# No Cache Versions\nasync def async_fibonacci_nc(number: int):\n    if number == 0: return 0\n    elif number == 1: return 1\n    return await async_fibonacci_nc(number - 1) + await async_fibonacci_nc(number - 2)\n\ndef fibonacci_nc(number: int):\n    if number == 0: return 0\n    elif number == 1: return 1\n    return fibonacci_nc(number - 1) + fibonacci_nc(number - 2)\n\n\nasync def run_tests(\n    start_n: int = 1,\n    runs: int = 10,\n    print_every: int = 5,\n):\n\n    \"\"\"\n    Test that both results are the same.\n    \"\"\"\n\n    t = Timer(format_ms=True)\n\n    # Test Sync\n    st = Timer(format_ms=True)\n    for i in range(runs):\n        r = fibonacci(start_n+i)\n        d = st.duration_s\n        if i % print_every == 0:\n            logger.info(f'[Sync - {i}/{runs}] Result: {r} | Time: {d}')\n    logger.info(f'[Sync] Cache Average Time: {st.total_average_s(runs)} | Total Time: {st.total_s}')\n    logger.info(fibonacci.cache_info(), prefix = '[Sync] Cache Info')\n\n    # Test Async\n    at = Timer(format_ms=True)\n    for i in range(runs):\n        r = await async_fibonacci(start_n+i)\n        d = at.duration_s\n        if i % print_every == 0:\n            logger.info(f'[Async - {i}/{runs}] Result: {r} | Time: {d}')\n    logger.info(f'[Async] Cache Average Time: {at.total_average_s(runs)} | Total Time: {at.total_s}')\n    logger.info(await async_fibonacci.cache_info(), prefix = '[Async] Cache Info')\n    logger.info(t.total_s, prefix = 'Total Time')\n\n    # Clear the Cache\n    # You can explictly call the function's internally wrapped\n    # methods to clear the cache.\n    fibonacci.clear()\n    logger.info(fibonacci.cache_info(), prefix = '[Sync] Cache Info')\n\n    await async_fibonacci.clear()\n    logger.info(await async_fibonacci.cache_info(), prefix = '[Async] Cache Info')\n\n    logger.info('Testing Non-Cached Functions')\n    t = Timer(format_ms=True)\n\n    # Test Sync\n    st = Timer(format_ms=True)\n    for i in range(runs):\n        r = fibonacci_nc(start_n+i)\n        d = st.duration_s\n        if i % print_every == 0:\n            logger.info(f'[Sync - {i}/{runs}] Result: {r} | Time: {d}')\n    logger.info(f'[Sync] Cache Average Time: {st.total_average_s(runs)} | Total Time: {st.total_s}')\n\n    # Test Async\n    at = Timer(format_ms=True)\n    for i in range(runs):\n        r = await async_fibonacci_nc(start_n+i)\n        d = at.duration_s\n        if i % print_every == 0:\n            logger.info(f'[Async - {i}/{runs}] Result: {r} | Time: {d}')\n    logger.info(f'[Async] Cache Average Time: {at.total_average_s(runs)} | Total Time: {at.total_s}')\n    logger.info(t.total_s, prefix = 'Total Time')\n\n\n\nif __name__ == '__main__':\n    asyncio.run(run_tests(\n        start_n = 5,\n        runs = 10,\n        print_every = 5,\n    ))\n</code></pre>"},{"location":"topics/serialization/","title":"Overview","text":"<p>Serialization plays an important role in the <code>KVDB</code> library. It allows you to store almost any type of object when using any <code>set/get</code> methods without having to worry about serializing and deserializing prior. </p> <p>The <code>kvdb</code> library provides several default serializers and compression algorithms to choose from, and provides extensibility to add custom serializers and compression algorithms.</p> <p>Default Supported Serializers:</p> <ul> <li>JSON</li> <li>MessagePack</li> <li>Pickle</li> </ul> <p>A session can be configured to use a serializer when serializing and deserializing data in-flight. This allows you to store almost any type of object when using any <code>set/get</code> methods without having to worry about serializing and deserializing prior.</p> <p>Even with <code>json</code>, almost all data types and objects can be serialized by utilizing an intelligent deterministic storing of the object's metadata on serialization and then reconstructing the object on deserialization. This is done by storing the object's type and any additional metadata required to reconstruct the object. </p> <p>Serialization has first-class support for <code>pydantic</code> models and <code>dataclasses</code>.</p> <p>This can be done by passing a serializer to the <code>get_session()</code> method.  It is currently not recommended to mix serialization with sub-dependent libraries that may do encoding and decoding prior to passing the data to KV Store, as it can lead to serialization errors.</p> <p>The following is a list of the arguments that can be passed to the <code>get_session()</code> method:</p> <ul> <li> <p><code>serializer</code>: The serializer to use when serializing and deserializing data. Defaults to <code>None</code>. Set to <code>auto</code>, which defaults to <code>json</code> to automatically use a serializer based on the data type. Each type supports sub-libraries which will be used if they are installed. Additionally, you can pass a custom kwarg to try to import the serializer.   Supported serializers (and sub-libraries based on priority):</p> <ul> <li><code>json</code>: The JSON serializer.   Kwarg: <code>jsonlib</code></li> <li>[x] <code>simdjson</code></li> <li>[x] <code>orjson</code></li> <li>[x] <code>ujson</code></li> <li>[x] <code>json</code></li> <li><code>msgpack</code>: The MessagePack serializer.</li> <li><code>pickle</code>: The pickle serializer.   Kwarg: <code>picklelib</code><ul> <li>[x] <code>cloudpickle</code></li> <li>[x] <code>dill</code></li> <li>[x] <code>pickle</code></li> </ul> </li> </ul> </li> <li> <p><code>serializer_kwargs</code>: The keyword arguments to pass to the serializer when serializing and deserializing data. Defaults to <code>None</code>.</p> </li> <li><code>compression</code>: The compression algorithm to use when compressing and decompressing data. Defaults to <code>None</code>.    Supported compression algorithms:<ul> <li><code>zstd</code></li> <li><code>lz4</code></li> <li><code>gzip</code></li> <li><code>zlib</code></li> </ul> </li> <li><code>compression_level</code>: The compression level to use when compressing data. Defaults to <code>None</code>, which will use the default compression level for the compression algorithm.</li> <li><code>compression_enabled</code>: Whether or not compression should be enabled. Defaults to <code>None</code>. If <code>True</code> and <code>compression</code> is <code>None</code>, then it will be determined based on which compression algorithms are available. If <code>False</code>, then compression will be disabled.</li> </ul>"},{"location":"topics/serialization/#serialization-classes","title":"Serialization Classes","text":"<p>The following is the base class that serializers from:</p> <p>               Bases: <code>abc.ABC</code></p> <p>The Base Serializer Class</p> <p>Initializes the serializer</p> METHOD DESCRIPTION <code>adecode</code> <p>Decodes the value asynchronously</p> <code>adumps</code> <p>Dumps the value asynchronously</p> <code>aencode</code> <p>Encodes the value asynchronously</p> <code>aloads</code> <p>Loads the value asynchronously</p> <code>compress_value</code> <p>Compresses the value</p> <code>copy</code> <p>Copies the serializer</p> <code>create_hash</code> <p>Creates a hash for the object</p> <code>decode</code> <p>Decodes the value</p> <code>decode_value</code> <p>Decodes the value</p> <code>decompress_value</code> <p>Decompresses the value</p> <code>deprecated_decompress_value</code> <p>Attempts to decompress the value using the deprecated compressor</p> <code>dumps</code> <p>Dumps the value</p> <code>encode</code> <p>Encodes the value</p> <code>encode_value</code> <p>Encodes the value</p> <code>fetch_object_classname</code> <p>Fetches the object classname</p> <code>loads</code> <p>Loads the value</p> <code>set_default_lib</code> <p>Sets the default library</p> ATTRIBUTE DESCRIPTION <code>compression_enabled</code> <p>Returns if compression is enabled</p> <p> TYPE: <code>bool</code> </p> <code>compression_level</code> <p>Returns the compression level</p> <p> TYPE: <code>typing.Optional[int]</code> </p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def __init__(\n    self,\n    compression: Optional[str] = None,\n    compression_level: Optional[int] = None,\n    encoding: Optional[str] = None,\n    raise_errors: bool = False,\n    enable_deprecation_support: bool = True,\n    is_encoder: Optional[bool] = None,\n    **kwargs,\n):\n    \"\"\"\n    Initializes the serializer\n    \"\"\"\n    # Add support for copying serializers\n    if 'compressor' in kwargs: \n        self.compressor = kwargs.pop('compressor')\n        if 'previous_compressor' in kwargs: \n            self.previous_compressor = kwargs.pop('previous_compressor')\n    elif compression is not None or compression_level is not None:\n        from ..compression import get_compression\n        compression_kwargs = kwargs.pop(\"compression_kwargs\", None)\n        decompression_kwargs = kwargs.pop(\"decompression_kwargs\", None)\n        deprecated_compression = kwargs.pop(\"deprecated_compression\", None)\n        self.compressor = get_compression(\n            compression, \n            compression_level = compression_level, \n            compression_kwargs = compression_kwargs, \n            decompression_kwargs = decompression_kwargs,\n        )\n        if deprecated_compression is not None and deprecated_compression != compression:\n            self.previous_compressor = get_compression(deprecated_compression)\n    if encoding is not None: self.encoding = encoding\n    # logger.info(f\"Initializing Serializer: {self.name}: {self.compressor}\")\n    self.raise_errors = raise_errors\n    self.enable_deprecation_support = enable_deprecation_support\n    self.is_encoder = is_encoder\n    self._kwargs = kwargs\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.compression_enabled","title":"compression_enabled  <code>property</code>","text":"<pre><code>compression_enabled: bool\n</code></pre> <p>Returns if compression is enabled</p>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.compression_level","title":"compression_level  <code>property</code>","text":"<pre><code>compression_level: typing.Optional[int]\n</code></pre> <p>Returns the compression level</p>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.adecode","title":"adecode  <code>async</code>","text":"<pre><code>adecode(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Decodes the value asynchronously</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>async def adecode(self, value: Union[str, bytes], **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Decodes the value asynchronously\n    \"\"\"\n    return await Pooler.arun(self.decode, value, **kwargs)\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.adumps","title":"adumps  <code>async</code>","text":"<pre><code>adumps(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Dumps the value asynchronously</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>async def adumps(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Dumps the value asynchronously\n    \"\"\"\n    return await Pooler.arun(self.dumps, value, **kwargs)\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.aencode","title":"aencode  <code>async</code>","text":"<pre><code>aencode(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Encodes the value asynchronously</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>async def aencode(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Encodes the value asynchronously\n    \"\"\"\n    return await Pooler.arun(self.encode, value, **kwargs)\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.aloads","title":"aloads  <code>async</code>","text":"<pre><code>aloads(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Loads the value asynchronously</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>async def aloads(self, value: Union[str, bytes], **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Loads the value asynchronously\n    \"\"\"\n    return await Pooler.arun(self.loads, value, **kwargs)\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.compress_value","title":"compress_value","text":"<pre><code>compress_value(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Compresses the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def compress_value(self, value: Union[str, bytes], **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Compresses the value\n    \"\"\"\n    if self.compression_enabled:\n        if isinstance(value, str): value = value.encode(self.encoding)\n        return self.compressor.compress(value)\n    return value\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.copy","title":"copy","text":"<pre><code>copy(**kwargs) -&gt; kvdb.io.serializers.base.BaseSerializer\n</code></pre> <p>Copies the serializer</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def copy(self, **kwargs) -&gt; BaseSerializer:\n    \"\"\"\n    Copies the serializer\n    \"\"\"\n    new = deepcopy(self)\n    for k, v in kwargs.items():\n        if hasattr(new, k):\n            setattr(new, k, v)\n        else:\n            new._kwargs[k] = v\n        # setattr(new, k, v)\n    return new\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.create_hash","title":"create_hash","text":"<pre><code>create_hash(\n    obj: kvdb.io.serializers.base.ObjectValue,\n) -&gt; str\n</code></pre> <p>Creates a hash for the object</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def create_hash(self, obj: ObjectValue) -&gt; str:\n    \"\"\"\n    Creates a hash for the object\n    \"\"\"\n    return create_obj_hash(obj)\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.decode","title":"decode","text":"<pre><code>decode(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Decodes the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def decode(self, value: Union[str, bytes], **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Decodes the value\n    \"\"\"\n    try:\n        decompressed_value = self.decompress_value(value, **kwargs)\n        if decompressed_value is not None:\n            value = decompressed_value\n    except Exception as e:\n        if self.raise_errors: raise DataError(f\"[{self.name}] Error in Decompression: {str(value)[:100]}\") from e\n        # return self.decode_value(value, **kwargs)\n    return self.decode_value(value, **kwargs)\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.decode_value","title":"decode_value","text":"<pre><code>decode_value(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Decodes the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def decode_value(self, value: Union[str, bytes], **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Decodes the value\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.decompress_value","title":"decompress_value","text":"<pre><code>decompress_value(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Decompresses the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def decompress_value(self, value: Union[str, bytes], **kwargs) -&gt; Union[str, bytes]:\n    # sourcery skip: extract-duplicate-method\n    \"\"\"\n    Decompresses the value\n    \"\"\"\n    if not self.compression_enabled: return value\n    try:\n        value = self.compressor.decompress(value, **kwargs)\n    except Exception as e:\n        if self.enable_deprecation_support or self.previous_compressor is not None:\n            value = self.deprecated_decompress_value(value, **kwargs)\n    if value is not None and not self.binary: value = value.decode(self.encoding)\n    return value\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.deprecated_decompress_value","title":"deprecated_decompress_value","text":"<pre><code>deprecated_decompress_value(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; typing.Optional[typing.Union[str, bytes]]\n</code></pre> <p>Attempts to decompress the value using the deprecated compressor</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def deprecated_decompress_value(self, value: Union[str, bytes], **kwargs) -&gt; Optional[Union[str, bytes]]:\n    \"\"\"\n    Attempts to decompress the value using the deprecated compressor\n    \"\"\"\n    e = None\n    attempt_msg = f\"{self.name}\"\n    if self.previous_compressor is not None:\n        try:\n            return self.previous_compressor.decompress(value)\n        except Exception as e:\n            attempt_msg += f\"-&gt; {self.previous_compressor.name}\"\n    try:\n        return zlib.decompress(value)\n    except Exception as e:\n        attempt_msg += \" -&gt; ZLib\"\n        if self.raise_errors: raise DataError(f\"[{attempt_msg}] Error in Decompression: {str(value)[:100]}\") from e\n        return None\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.dumps","title":"dumps","text":"<pre><code>dumps(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Dumps the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def dumps(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    # sourcery skip: class-extract-method\n    \"\"\"\n    Dumps the value\n    \"\"\"\n    try:\n        return self.encode(value, **kwargs)\n    except Exception as e:\n        if self.raise_errors: raise DataError(f\"[{self.name}] Error in Encoding: {str(value)[:500]}\") from e\n        return None\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.encode","title":"encode","text":"<pre><code>encode(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Encodes the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def encode(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Encodes the value\n    \"\"\"\n    return self.compress_value(self.encode_value(value, **kwargs))\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.encode_value","title":"encode_value","text":"<pre><code>encode_value(\n    value: kvdb.io.serializers.base.ObjectValue, **kwargs\n) -&gt; typing.Union[str, bytes]\n</code></pre> <p>Encodes the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def encode_value(self, value: ObjectValue, **kwargs) -&gt; Union[str, bytes]:\n    \"\"\"\n    Encodes the value\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.fetch_object_classname","title":"fetch_object_classname","text":"<pre><code>fetch_object_classname(\n    obj: kvdb.io.serializers.base.ObjectValue,\n) -&gt; str\n</code></pre> <p>Fetches the object classname</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def fetch_object_classname(self, obj: ObjectValue) -&gt; str:\n    \"\"\"\n    Fetches the object classname\n    \"\"\"\n    return f\"{obj.__class__.__module__}.{obj.__class__.__name__}\"\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.loads","title":"loads","text":"<pre><code>loads(\n    value: typing.Union[str, bytes], **kwargs\n) -&gt; kvdb.io.serializers.base.ObjectValue\n</code></pre> <p>Loads the value</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>def loads(self, value: Union[str, bytes], **kwargs) -&gt; ObjectValue:\n    \"\"\"\n    Loads the value\n    \"\"\"\n    try:\n        return self.decode(value, **kwargs)\n    except Exception as e:\n        if not self.is_encoder: logger.trace(f'[{self.name}] Error in Decoding: {str(value)[:500]}', e)\n        if self.raise_errors: raise DataError(f\"[{self.name}] Error in Decoding: {str(value)[:500]}\") from e\n        return None\n</code></pre>"},{"location":"topics/serialization/#kvdb.io.serializers.base.BaseSerializer.set_default_lib","title":"set_default_lib  <code>classmethod</code>","text":"<pre><code>set_default_lib(\n    lib: typing.Union[str, types.ModuleType],\n) -&gt; None\n</code></pre> <p>Sets the default library</p> Source code in <code>kvdb/io/serializers/base.py</code> <pre><code>@classmethod\ndef set_default_lib(cls, lib: Union[str, ModuleType]) -&gt; None:\n    \"\"\"\n    Sets the default library\n    \"\"\"\n    pass\n</code></pre>"},{"location":"topics/session-manager/","title":"Overview","text":"<p>The <code>KVDBSessionManager</code> (accessed as <code>kvdb.KVDBClient</code>) class provides a context manager interface for managing sessions with the KVDB server. It keeps track and registration of all active sessions and provides a simple interface for managing session operations. It inherits from a <code>ProxyObject</code> Singleton to lazily initialize and prevent multiple instances of the session manager.</p> <ul> <li>Sessions</li> <li>API Reference</li> </ul>"},{"location":"topics/session-manager/#basic-usage","title":"Basic Usage","text":"<pre><code>import kvdb\nfrom pydantic import BaseModel\n\n# Explicitly define the config. Otherwise it will use the defaults, which are determined via environment variables.\n# session = KVDBClient.get_session(name=\"default\", url=os.environ.get(\"REDIS_URL|KVDB_URL|KEYDB_URL|MEMCACHED_URL\"))\n\n# Alternative methods that achieve the same result\n# session = kvdb.from_url(name=\"default\", url=\"redis://localhost:6379/0\", serializer='json')\n# session = kvdb.get_session(name=\"default\", url=\"redis://localhost:6379/0\", serializer='json')\n\nsession = kvdb.KVDBClient.get_session(name=\"default\", url=\"redis://localhost:6379/0\", serializer='json')\n\nclass MyModel(BaseModel):\n    name: str\n    age: int\n\n# This demonstrates how the pydantic model is automatically serialized and deserialized\nnew_model = MyModel(name='John', age=30)\nsession.set(new_model.name, new_model)\nsrc_model = session.get('John')\n\nassert src_model == new_model\n\n# Without explicitly defining the serailizer, the same would fail.\n\nsession2 = kvdb.KVDBClient.get_session(name=\"test-1\")\n# This will fail because the serializer is not defined\nsession2.set(new_model.name, new_model)\n</code></pre>"},{"location":"topics/sessions/","title":"Overview","text":"<p>Sessions are the underlying object that contains the state of a single <code>KVDB</code> connection to a server. This session contains both asynchronous and synchronous methods for interacting with the server, as well as methods for managing the session itself.</p> <p>The underlying connection pools are managed by the <code>KVDBClient</code> class, which is a singleton that manages all sessions. This allows you to create multiple sessions with different configurations, but still share the same underlying connection pool, unless there is any configuration differences that would require a new connection pool.</p> <ul> <li>Session Manager</li> <li>API Reference</li> </ul>"},{"location":"topics/sessions/#creating-a-session","title":"Creating a Session","text":"<p>A session can be created by calling the <code>KVDBClient.get_session()</code> method. This method takes a number of arguments that can be used to configure the session. The following is a list of the arguments that can be passed to the <code>get_session()</code> method:</p> <ul> <li><code>name</code>: The name of the session. Defaults to <code>default</code>. This should be a unique name for each session. If a session with the same name already exists, then the existing session will be returned.</li> <li><code>url</code>: The URL to connect to. Defaults to <code>redis://localhost:6379/0</code>.</li> <li><code>host</code>: The host to connect to. Defaults to <code>None</code>.</li> <li><code>port</code>: The port to connect to. Defaults to <code>None</code>.</li> <li><code>db_id</code>: The database to connect to. Defaults to <code>None</code>.</li> <li><code>password</code>: The password to use when connecting. Defaults to <code>None</code>.</li> <li><code>username</code>: The username to use when connecting. Defaults to <code>None</code>.</li> </ul>"},{"location":"topics/sessions/#connection-management","title":"Connection Management","text":"<p><code>kvdb-py</code> is designed for high-concurrency environments.</p> <ul> <li>Async Interface: By default, <code>KVDBClient</code> uses the <code>OptimizedAsyncConnectionPool</code>. This pool employs a hybrid blocking strategy: it serves connections immediately when available but gracefully waits (blocks) when the pool hits its <code>max_connections</code> limit, preventing <code>ConnectionError</code> under load. It also uses <code>uvloop</code> if installed.</li> <li>Sync Interface: Uses a thread-safe <code>BlockingConnectionPool</code> to ensure safe concurrent access across threads.</li> </ul>"},{"location":"topics/sessions/#session-serialization","title":"Session Serialization","text":"<p>A session can be configured to use a serializer when serializing and deserializing data in-flight. This allows you to store almost any type of object when using any <code>set/get</code> methods without having to worry about serializing and deserializing prior.</p> <p>Even with <code>json</code>, almost all data types and objects can be serialized by utilizing an intelligent deterministic storing of the object's metadata on serialization and then reconstructing the object on deserialization. This is done by storing the object's type and any additional metadata required to reconstruct the object. </p> <p>Serialization has first-class support for <code>pydantic</code> models and <code>dataclasses</code>.</p> <p>This can be done by passing a serializer to the <code>get_session()</code> method.  It is currently not recommended to mix serialization with sub-dependent libraries that may do encoding and decoding prior to passing the data to KV Store, as it can lead to serialization errors.</p> <p>The following is a list of the arguments that can be passed to the <code>get_session()</code> method:</p> <ul> <li> <p><code>serializer</code>: The serializer to use when serializing and deserializing data. Defaults to <code>None</code>. Set to <code>auto</code>, which defaults to <code>json</code> to automatically use a serializer based on the data type. Each type supports sub-libraries which will be used if they are installed. Additionally, you can pass a custom kwarg to try to import the serializer.   Supported serializers (and sub-libraries based on priority):</p> <ul> <li><code>json</code>: The JSON serializer.   Kwarg: <code>jsonlib</code></li> <li>[x] <code>simdjson</code></li> <li>[x] <code>orjson</code></li> <li>[x] <code>ujson</code></li> <li>[x] <code>json</code></li> <li><code>msgpack</code>: The MessagePack serializer.</li> <li><code>pickle</code>: The pickle serializer.   Kwarg: <code>picklelib</code><ul> <li>[x] <code>cloudpickle</code></li> <li>[x] <code>dill</code></li> <li>[x] <code>pickle</code></li> </ul> </li> </ul> </li> <li> <p><code>serializer_kwargs</code>: The keyword arguments to pass to the serializer when serializing and deserializing data. Defaults to <code>None</code>.</p> </li> <li><code>compression</code>: The compression algorithm to use when compressing and decompressing data. Defaults to <code>None</code>.    Supported compression algorithms:<ul> <li><code>zstd</code></li> <li><code>lz4</code></li> <li><code>gzip</code></li> <li><code>zlib</code></li> </ul> </li> <li><code>compression_level</code>: The compression level to use when compressing data. Defaults to <code>None</code>, which will use the default compression level for the compression algorithm.</li> <li><code>compression_enabled</code>: Whether or not compression should be enabled. Defaults to <code>None</code>. If <code>True</code> and <code>compression</code> is <code>None</code>, then it will be determined based on which compression algorithms are available. If <code>False</code>, then compression will be disabled.</li> </ul>"},{"location":"topics/sessions/#example","title":"Example","text":"<p>The following is an example of creating a session:</p> <pre><code>from kvdb import KVDBClient\nfrom pydantic import BaseModel\n\nclass MyModel(BaseModel):\n    name: str\n    age: int\n\nsession_1 = KVDBClient.get_session(\n    name='my-session',\n    url='redis://:password@localhost:6379/0',\n)\n\nsession_1.set('key', 'value')\n\n# See how the value is automatically serialized and deserialized\nsession_2 = KVDBClient.get_session(\n    name='my-session',\n    url='redis://:password@127.0.0.1:6379/0',\n    serializer='json',\n)\n\n# This demonstrates how the pydantic model is automatically serialized and deserialized\nnew_model = MyModel(name='John', age=30)\nsession_2.set(new_model.name, new_model)\nsrc_model = session_2.get('John')\n\nassert src_model == new_model\n</code></pre>"},{"location":"topics/tasks/","title":"<code>KVDB Tasks</code>","text":"<p>Create and Manage Tasks with KVDB.</p> <p>The following module provides an aliased interface to the KVDB <code>TaskQueue</code> and <code>Task</code> classes.</p>"},{"location":"topics/tasks/#references","title":"References","text":""},{"location":"topics/tasks/#api-reference","title":"API Reference","text":"MODULE DESCRIPTION <code>abstract</code> <code>cli</code> <code>debug</code> <code>main</code> <code>queue</code> <code>spawn</code> <code>tasks</code> <code>types</code> <code>utils</code> <code>worker</code> <code>wraps</code> FUNCTION DESCRIPTION <code>aget_task_worker</code> <p>Gets the task worker</p> <code>apply</code> <p>Enqueue a job and wait for its result.</p> <code>as_jobs_complete</code> <p>Generator that yields results as they complete</p> <code>broadcast</code> <p>Broadcast a job to all nodes and collect all of their results.</p> <code>create_context</code> <p>Creates a context</p> <code>enqueue</code> <p>Enqueue a job by instance or string.</p> <code>get_task_queue</code> <p>Gets a task queue</p> <code>get_task_worker</code> <p>Gets the task worker</p> <code>map</code> <p>Enqueue multiple jobs and collect all of their results.</p> <code>register</code> <p>Registers a function to the queue_name</p> <code>register_abc</code> <p>Registers an abstract class or function to the task queue</p> <code>register_abstract</code> <p>Registers a function that is part of an abstract class</p> <code>register_object</code> <p>Registers a module to the queue_name</p> <code>set_default_global_queue_name</code> <p>Updates the default global queue name</p> <code>spawn_new_task_worker</code> <p>Spawns a new task worker</p> <code>start_task_workers</code> <p>Starts multiple task workers using either multiprocessing or asyncio.tasks</p> <code>wait_for_job</code> <p>Waits for job to finish</p> <code>wait_for_jobs</code> <p>Waits for jobs to finish</p>"},{"location":"topics/tasks/#kvdb.tasks.aget_task_worker","title":"aget_task_worker  <code>async</code>","text":"<pre><code>aget_task_worker(\n    worker_name: typing.Optional[str] = None,\n    queues: typing.Union[\n        typing.List[\"TaskQueue\", str], \"TaskQueue\", str\n    ] = None,\n    task_worker_class: typing.Optional[\n        typing.Type[\"TaskWorker\"]\n    ] = None,\n    functions: typing.Optional[\n        typing.List[\"TaskFunction\"]\n    ] = None,\n    cron_jobs: typing.Optional[\n        typing.List[\"CronJob\"]\n    ] = None,\n    startup: typing.Optional[\n        typing.Union[\n            typing.List[typing.Callable], typing.Callable\n        ]\n    ] = None,\n    shutdown: typing.Optional[\n        typing.Union[\n            typing.List[typing.Callable], typing.Callable\n        ]\n    ] = None,\n    before_process: typing.Optional[typing.Callable] = None,\n    after_process: typing.Optional[typing.Callable] = None,\n    worker_attributes: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    timers: typing.Optional[\n        typing.Union[\n            typing.Dict[str, int], \"WorkerTimerConfig\"\n        ]\n    ] = None,\n    max_concurrency: typing.Optional[int] = None,\n    max_broadcast_concurrency: typing.Optional[int] = None,\n    task_queue_class: typing.Optional[\n        typing.Type[\"TaskQueue\"]\n    ] = None,\n    **kwargs\n) -&gt; \"TaskWorker\"\n</code></pre> <pre><code>aget_task_worker(\n    worker_name: typing.Optional[str] = None,\n    queues: typing.Union[\n        typing.List[\"TaskQueue\", str], \"TaskQueue\", str\n    ] = None,\n    task_worker_class: typing.Optional[\n        typing.Type[\"TaskWorker\"]\n    ] = None,\n    **kwargs\n) -&gt; \"TaskWorker\"\n</code></pre> <p>Gets the task worker</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>async def aget_task_worker(\n    worker_name: Optional[str] = None,\n    queues: Union[List['TaskQueue', str], 'TaskQueue', str] = None,\n    task_worker_class: Optional[Type['TaskWorker']] = None,\n    **kwargs\n) -&gt; 'TaskWorker':\n    \"\"\"\n    Gets the task worker\n    \"\"\"\n    from .main import TaskManager\n    return await TaskManager.aget_task_worker(worker_name = worker_name, queues = queues, task_worker_class = task_worker_class, **kwargs)\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.apply","title":"apply  <code>async</code>","text":"<pre><code>apply(\n    job_or_func: typing.Union[\"Job\", str, typing.Callable],\n    key: typing.Optional[str] = None,\n    timeout: typing.Optional[int] = None,\n    retries: typing.Optional[int] = None,\n    ttl: typing.Optional[int] = None,\n    retry_delay: typing.Optional[int] = None,\n    retry_backoff: typing.Optional[int] = None,\n    worker_id: typing.Optional[str] = None,\n    worker_name: typing.Optional[str] = None,\n    job_callback: typing.Optional[typing.Callable] = None,\n    job_callback_kwargs: typing.Optional[\n        typing.Dict\n    ] = None,\n    queue_name: typing.Optional[str] = None,\n    broadcast: typing.Optional[bool] = None,\n    worker_names: typing.Optional[typing.List[str]] = None,\n    worker_selector: typing.Optional[\n        typing.Callable\n    ] = None,\n    worker_selector_args: typing.Optional[\n        typing.List\n    ] = None,\n    worker_selector_kwargs: typing.Optional[\n        typing.Dict\n    ] = None,\n    workers_selected: typing.Optional[\n        typing.List[typing.Dict[str, str]]\n    ] = None,\n    return_all_results: typing.Optional[bool] = False,\n    **kwargs\n) -&gt; typing.Optional[typing.Any]\n</code></pre> <pre><code>apply(\n    job_or_func: typing.Union[\"Job\", str, typing.Callable],\n    queue_name: typing.Optional[str] = None,\n    **kwargs\n) -&gt; typing.Optional[typing.Any]\n</code></pre> <p>Enqueue a job and wait for its result.</p> <p>If the job is successful, this returns its result. If the job is unsuccessful, this raises a JobError.</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>async def apply(\n    job_or_func: Union['Job', str, Callable],\n    queue_name: Optional[str] = None,\n    **kwargs\n) -&gt; Optional[Any]:\n    \"\"\"\n    Enqueue a job and wait for its result.\n\n    If the job is successful, this returns its result.\n    If the job is unsuccessful, this raises a JobError.\n    \"\"\"\n    from .main import TaskManager\n    return await TaskManager.apply(job_or_func, queue_name = queue_name, **kwargs)\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.as_jobs_complete","title":"as_jobs_complete","text":"<pre><code>as_jobs_complete(\n    jobs: typing.List[\"Job\"],\n    source_job: typing.Optional[\"Job\"] = None,\n    queue_name: typing.Optional[str] = None,\n    verbose: typing.Optional[bool] = False,\n    raise_exceptions: typing.Optional[bool] = False,\n    refresh_interval: typing.Optional[float] = 0.5,\n    return_results: typing.Optional[bool] = True,\n    cancel_func: typing.Optional[typing.Callable] = None,\n    **kwargs\n) -&gt; typing.AsyncGenerator[typing.Any, None]\n</code></pre> <pre><code>as_jobs_complete(\n    jobs: typing.List[\"Job\"],\n    source_job: typing.Optional[\"Job\"] = None,\n    queue_name: typing.Optional[str] = None,\n    verbose: typing.Optional[bool] = False,\n    raise_exceptions: typing.Optional[bool] = False,\n    refresh_interval: typing.Optional[float] = 0.5,\n    return_results: typing.Optional[bool] = True,\n    cancel_func: typing.Optional[typing.Callable] = None,\n    **kwargs\n) -&gt; typing.AsyncGenerator[typing.Any, None]\n</code></pre> <p>Generator that yields results as they complete</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>def as_jobs_complete(\n    jobs: List['Job'],\n    source_job: Optional['Job'] = None,\n    queue_name: Optional[str] = None,\n    verbose: Optional[bool] = False,\n    raise_exceptions: Optional[bool] = False,\n    refresh_interval: Optional[float] = 0.5,\n    return_results: Optional[bool] = True,\n    cancel_func: Optional[Callable] = None,\n    **kwargs,\n) -&gt; AsyncGenerator[Any, None]:\n    \"\"\"\n    Generator that yields results as they complete\n    \"\"\"\n    from .main import TaskManager\n    return TaskManager.as_jobs_complete(jobs, source_job = source_job, queue_name  = queue_name, verbose = verbose, raise_exceptions = raise_exceptions, refresh_interval = refresh_interval, return_results = return_results, cancel_func = cancel_func, **kwargs)\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.broadcast","title":"broadcast  <code>async</code>","text":"<pre><code>broadcast(\n    job_or_func: typing.Union[\"Job\", str],\n    enqueue: typing.Optional[bool] = True,\n    queue_name: typing.Optional[str] = None,\n    worker_names: typing.Optional[typing.List[str]] = None,\n    worker_selector: typing.Optional[\n        typing.Callable\n    ] = None,\n    worker_selector_args: typing.Optional[\n        typing.List\n    ] = None,\n    worker_selector_kwargs: typing.Optional[\n        typing.Dict\n    ] = None,\n    workers_selected: typing.Optional[\n        typing.List[typing.Dict[str, str]]\n    ] = None,\n    **kwargs\n) -&gt; typing.List[\"Job\"]\n</code></pre> <pre><code>broadcast(\n    job_or_func: typing.Union[\"Job\", str],\n    queue_name: typing.Optional[str] = None,\n    **kwargs\n) -&gt; typing.List[\"Job\"]\n</code></pre> <p>Broadcast a job to all nodes and collect all of their results.</p> <p>job_or_func: Same as Queue.enqueue kwargs: Same as Queue.enqueue timeout: How long to wait for the job to complete before raising a TimeoutError worker_names: List of worker names to run the job on. If provided, will run on these specified workers. worker_selector: Function that takes in a list of workers and returns a list of workers to run the job on. If provided, worker_names will be ignored.</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>async def broadcast(\n    job_or_func: Union['Job', str],\n    queue_name: Optional[str] = None,\n    **kwargs\n) -&gt; List['Job']:\n    \"\"\"\n    Broadcast a job to all nodes and collect all of their results.\n\n    job_or_func: Same as Queue.enqueue\n    kwargs: Same as Queue.enqueue\n    timeout: How long to wait for the job to complete before raising a TimeoutError\n    worker_names: List of worker names to run the job on. If provided, will run on these specified workers.\n    worker_selector: Function that takes in a list of workers and returns a list of workers to run the job on. If provided, worker_names will be ignored.\n    \"\"\"\n    from .main import TaskManager\n    return await TaskManager.broadcast(job_or_func, queue_name = queue_name, **kwargs)\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.create_context","title":"create_context","text":"<pre><code>create_context(\n    queue_name: typing.Optional[str] = None,\n    name: typing.Optional[str] = None,\n    phase: typing.Optional[\n        kvdb.tasks.main.TaskPhase\n    ] = None,\n    silenced: typing.Optional[bool] = None,\n    silenced_stages: typing.Optional[\n        typing.List[str]\n    ] = None,\n    default_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    cronjob: typing.Optional[bool] = None,\n    disable_patch: typing.Optional[bool] = None,\n    disable_ctx_in_patch: typing.Optional[bool] = None,\n    worker_attributes: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    attribute_match_type: typing.Optional[\n        \"AttributeMatchType\"\n    ] = None,\n    fallback_enabled: typing.Optional[bool] = None,\n    on_failure_callback: typing.Optional[\n        typing.Union[typing.Callable, str]\n    ] = None,\n    context: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    **kwargs\n) -&gt; \"QueueTasks\"\n</code></pre> <pre><code>create_context(\n    queue_name: typing.Optional[str] = None,\n    context: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    **kwargs\n) -&gt; \"QueueTasks\"\n</code></pre> <p>Creates a context</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>def create_context(\n    queue_name: Optional[str] = None,\n    context: Optional[Dict[str, Any]] = None,\n    **kwargs,\n) -&gt; 'QueueTasks':\n    \"\"\"\n    Creates a context\n    \"\"\"\n    from .main import TaskManager\n    return TaskManager.create_context(queue_name = queue_name, context = context, **kwargs)\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.enqueue","title":"enqueue  <code>async</code>","text":"<pre><code>enqueue(\n    job_or_func: typing.Union[\"Job\", str, typing.Callable],\n    *args,\n    queue_name: typing.Optional[str] = None,\n    key: typing.Optional[str] = None,\n    timeout: typing.Optional[int] = None,\n    retries: typing.Optional[int] = None,\n    ttl: typing.Optional[int] = None,\n    retry_delay: typing.Optional[int] = None,\n    retry_backoff: typing.Optional[int] = None,\n    worker_id: typing.Optional[str] = None,\n    worker_name: typing.Optional[str] = None,\n    job_callback: typing.Optional[typing.Callable] = None,\n    job_callback_kwargs: typing.Optional[\n        typing.Dict\n    ] = None,\n    return_existing_job: bool = False,\n    **kwargs\n) -&gt; typing.Optional[\"Job\"]\n</code></pre> <pre><code>enqueue(\n    job_or_func: typing.Union[\"Job\", str, typing.Callable],\n    *args,\n    queue_name: typing.Optional[str] = None,\n    **kwargs\n) -&gt; typing.Optional[\"Job\"]\n</code></pre> <p>Enqueue a job by instance or string.</p> <p>Kwargs can be arguments of the function or properties of the job. If a job instance is passed in, it's properties are overriden.</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>async def enqueue(\n    job_or_func: Union['Job', str, Callable],\n    *args,\n    queue_name: Optional[str] = None,\n    **kwargs\n) -&gt; Optional['Job']:\n    \"\"\"\n    Enqueue a job by instance or string.\n\n    Kwargs can be arguments of the function or properties of the job.\n    If a job instance is passed in, it's properties are overriden.\n    \"\"\"\n    from .main import TaskManager\n    return await TaskManager.enqueue(job_or_func, *args, queue_name = queue_name, **kwargs)\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.get_task_queue","title":"get_task_queue","text":"<pre><code>get_task_queue(\n    queue_name: typing.Optional[str] = \"global\",\n    task_queue_class: typing.Optional[\n        typing.Type[\"TaskQueue\"]\n    ] = None,\n    queue_prefix: typing.Optional[str] = \"_kvq_\",\n    queue_db_id: typing.Optional[int] = 3,\n    serializer: typing.Optional[str] = \"json\",\n    serializer_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    compression: typing.Optional[str] = None,\n    compression_level: typing.Optional[int] = None,\n    max_concurrency: typing.Optional[int] = None,\n    max_broadcast_concurrency: typing.Optional[int] = None,\n    truncate_logs: typing.Optional[\n        typing.Union[bool, int]\n    ] = None,\n    debug_enabled: typing.Optional[bool] = None,\n    push_to_queue_enabled: typing.Optional[bool] = None,\n    push_to_queue_key: typing.Optional[str] = None,\n    push_to_queue_ttl: typing.Optional[int] = None,\n    **kwargs\n) -&gt; \"TaskQueue\"\n</code></pre> <pre><code>get_task_queue(\n    queue_name: typing.Optional[str] = None,\n    task_queue_class: typing.Optional[\n        typing.Type[\"TaskQueue\"]\n    ] = None,\n    **kwargs\n) -&gt; \"TaskQueue\"\n</code></pre> <p>Gets a task queue</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>def get_task_queue(\n    queue_name: Optional[str] = None,\n    task_queue_class: Optional[Type['TaskQueue']] = None,\n    **kwargs\n) -&gt; 'TaskQueue':\n    \"\"\"\n    Gets a task queue\n    \"\"\"\n    from .main import TaskManager\n    return TaskManager.get_task_queue(queue_name = queue_name, task_queue_class = task_queue_class, **kwargs)\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.get_task_worker","title":"get_task_worker","text":"<pre><code>get_task_worker(\n    worker_name: typing.Optional[str] = None,\n    queues: typing.Union[\n        typing.List[\"TaskQueue\", str], \"TaskQueue\", str\n    ] = None,\n    task_worker_class: typing.Optional[\n        typing.Type[\"TaskWorker\"]\n    ] = None,\n    functions: typing.Optional[\n        typing.List[\"TaskFunction\"]\n    ] = None,\n    cron_jobs: typing.Optional[\n        typing.List[\"CronJob\"]\n    ] = None,\n    startup: typing.Optional[\n        typing.Union[\n            typing.List[typing.Callable], typing.Callable\n        ]\n    ] = None,\n    shutdown: typing.Optional[\n        typing.Union[\n            typing.List[typing.Callable], typing.Callable\n        ]\n    ] = None,\n    before_process: typing.Optional[typing.Callable] = None,\n    after_process: typing.Optional[typing.Callable] = None,\n    worker_attributes: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    timers: typing.Optional[\n        typing.Union[\n            typing.Dict[str, int], \"WorkerTimerConfig\"\n        ]\n    ] = None,\n    max_concurrency: typing.Optional[int] = None,\n    max_broadcast_concurrency: typing.Optional[int] = None,\n    task_queue_class: typing.Optional[\n        typing.Type[\"TaskQueue\"]\n    ] = None,\n    **kwargs\n) -&gt; \"TaskWorker\"\n</code></pre> <pre><code>get_task_worker(\n    worker_name: typing.Optional[str] = None,\n    queues: typing.Union[\n        typing.List[\"TaskQueue\", str], \"TaskQueue\", str\n    ] = None,\n    task_worker_class: typing.Optional[\n        typing.Type[\"TaskWorker\"]\n    ] = None,\n    **kwargs\n) -&gt; \"TaskWorker\"\n</code></pre> <p>Gets the task worker</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>def get_task_worker(\n    worker_name: Optional[str] = None,\n    queues: Union[List['TaskQueue', str], 'TaskQueue', str] = None,\n    task_worker_class: Optional[Type['TaskWorker']] = None,\n    **kwargs\n) -&gt; 'TaskWorker':\n    \"\"\"\n    Gets the task worker\n    \"\"\"\n    from .main import TaskManager\n    return TaskManager.get_task_worker(worker_name = worker_name, queues = queues, task_worker_class = task_worker_class, **kwargs)\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.map","title":"map  <code>async</code>","text":"<pre><code>map(\n    job_or_func: typing.Union[\"Job\", str],\n    iter_kwargs: typing.Iterable[typing.Dict],\n    return_exceptions: bool = False,\n    broadcast: typing.Optional[bool] = False,\n    queue_name: typing.Optional[str] = None,\n    worker_names: typing.Optional[typing.List[str]] = None,\n    worker_selector: typing.Optional[\n        typing.Callable\n    ] = None,\n    worker_selector_args: typing.Optional[\n        typing.List\n    ] = None,\n    worker_selector_kwargs: typing.Optional[\n        typing.Dict\n    ] = None,\n    workers_selected: typing.Optional[\n        typing.List[typing.Dict[str, str]]\n    ] = None,\n    **kwargs\n) -&gt; typing.List[kvdb.tasks.main.TaskResult]\n</code></pre> <pre><code>map(\n    job_or_func: typing.Union[\"Job\", str],\n    iter_kwargs: typing.Iterable[typing.Dict],\n    queue_name: typing.Optional[str] = None,\n    **kwargs\n) -&gt; typing.List[kvdb.tasks.main.TaskResult]\n</code></pre> <p>Enqueue multiple jobs and collect all of their results.</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>async def map(\n    job_or_func: Union['Job', str],\n    iter_kwargs: Iterable[Dict], \n    queue_name: Optional[str] = None,\n    **kwargs\n) -&gt; List[TaskResult]:\n    \"\"\"\n    Enqueue multiple jobs and collect all of their results.\n    \"\"\"\n    from .main import TaskManager\n    return await TaskManager.map(job_or_func, iter_kwargs, queue_name = queue_name, **kwargs)\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.register","title":"register","text":"<pre><code>register(\n    name: typing.Optional[str] = None,\n    function: typing.Optional[\"FunctionT\"] = None,\n    phase: typing.Optional[\"TaskPhase\"] = None,\n    silenced: typing.Optional[bool] = None,\n    silenced_stages: typing.Optional[\n        typing.List[str]\n    ] = None,\n    default_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    cronjob: typing.Optional[bool] = None,\n    queue_name: typing.Optional[str] = None,\n    disable_patch: typing.Optional[bool] = None,\n    disable_ctx_in_patch: typing.Optional[bool] = None,\n    worker_attributes: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    attribute_match_type: typing.Optional[\n        \"AttributeMatchType\"\n    ] = None,\n    fallback_enabled: typing.Optional[bool] = None,\n    on_failure_callback: typing.Optional[\n        typing.Union[typing.Callable, str]\n    ] = None,\n    task_abc: typing.Optional[bool] = None,\n    **kwargs\n) -&gt; typing.Callable[[\"FunctionT\"], \"FunctionT\"]\n</code></pre> <pre><code>register(\n    queue_name: typing.Optional[str] = None, **kwargs\n) -&gt; typing.Callable[[\"FunctionT\"], \"FunctionT\"]\n</code></pre> <p>Registers a function to the queue_name</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>def register(\n    queue_name: Optional[str] = None,\n    **kwargs\n) -&gt; Callable[['FunctionT'], 'FunctionT']:\n    \"\"\"\n    Registers a function to the queue_name\n    \"\"\"\n    from .main import TaskManager\n    return TaskManager.register(queue_name = queue_name, **kwargs)\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.register_abc","title":"register_abc","text":"<pre><code>register_abc(\n    cls_or_func: typing.Callable[\n        kvdb.tasks.P, kvdb.tasks.RT\n    ] = None,\n) -&gt; typing.Callable[\n    kvdb.tasks.P,\n    typing.Union[\n        kvdb.tasks.RT, typing.Awaitable[kvdb.tasks.RT]\n    ],\n]\n</code></pre><pre><code>register_abc(\n    cls_or_func: typing.Optional[\n        typing.Union[\n            typing.Type[\"TaskABC\"],\n            kvdb.tasks.main.FunctionT,\n            typing.Callable[\n                ..., kvdb.tasks.main.ReturnValue\n            ],\n        ]\n    ] = None,\n    phase: typing.Optional[\n        kvdb.tasks.main.TaskPhase\n    ] = None,\n    silenced: typing.Optional[bool] = None,\n    silenced_stages: typing.Optional[\n        typing.List[str]\n    ] = None,\n    default_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    cronjob: typing.Optional[bool] = None,\n    queue_name: typing.Optional[str] = None,\n    disable_patch: typing.Optional[bool] = None,\n    disable_ctx_in_patch: typing.Optional[bool] = None,\n    worker_attributes: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    attribute_match_type: typing.Optional[\n        kvdb.tasks.types.AttributeMatchType\n    ] = None,\n    fallback_enabled: typing.Optional[bool] = None,\n    on_failure_callback: typing.Optional[\n        typing.Union[typing.Callable, str]\n    ] = None,\n    exclude_retry_exceptions: typing.Optional[\n        typing.Union[\n            bool,\n            typing.List[typing.Type[Exception]],\n            typing.Set[typing.Type[Exception]],\n        ]\n    ] = None,\n    **kwargs\n) -&gt; typing.Callable[..., \"ReturnValue\"]\n</code></pre><pre><code>register_abc(\n    cls_or_func: typing.Optional[\n        typing.Union[\n            typing.Type[\"TaskABC\"],\n            kvdb.tasks.main.FunctionT,\n            typing.Callable[\n                ..., kvdb.tasks.main.ReturnValue\n            ],\n        ]\n    ] = None,\n    phase: typing.Optional[\n        kvdb.tasks.main.TaskPhase\n    ] = None,\n    silenced: typing.Optional[bool] = None,\n    silenced_stages: typing.Optional[\n        typing.List[str]\n    ] = None,\n    default_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    cronjob: typing.Optional[bool] = None,\n    queue_name: typing.Optional[str] = None,\n    disable_patch: typing.Optional[bool] = False,\n    disable_ctx_in_patch: typing.Optional[bool] = None,\n    worker_attributes: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    attribute_match_type: typing.Optional[\n        kvdb.tasks.types.AttributeMatchType\n    ] = None,\n    fallback_enabled: typing.Optional[bool] = None,\n    on_failure_callback: typing.Optional[\n        typing.Union[typing.Callable, str]\n    ] = None,\n    exclude_retry_exceptions: typing.Optional[\n        typing.Union[\n            bool,\n            typing.List[Exception],\n            typing.Set[Exception],\n        ]\n    ] = None,\n    **kwargs\n) -&gt; typing.Callable[[\"Job\"], \"Job\"]\n</code></pre><pre><code>register_abc(\n    name: typing.Optional[str] = None,\n    cls_or_func: typing.Optional[\n        typing.Union[\n            typing.Type[\"TaskABC\"],\n            kvdb.tasks.main.FunctionT,\n            typing.Callable[\n                ..., kvdb.tasks.main.ReturnValue\n            ],\n        ]\n    ] = None,\n    phase: typing.Optional[\n        kvdb.tasks.main.TaskPhase\n    ] = None,\n    silenced: typing.Optional[bool] = None,\n    silenced_stages: typing.Optional[\n        typing.List[str]\n    ] = None,\n    default_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    cronjob: typing.Optional[bool] = None,\n    queue_name: typing.Optional[str] = None,\n    disable_patch: typing.Optional[bool] = None,\n    disable_ctx_in_patch: typing.Optional[bool] = None,\n    worker_attributes: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    attribute_match_type: typing.Optional[\n        kvdb.tasks.types.AttributeMatchType\n    ] = None,\n    fallback_enabled: typing.Optional[bool] = None,\n    on_failure_callback: typing.Optional[\n        typing.Union[typing.Callable, str]\n    ] = None,\n    exclude_retry_exceptions: typing.Optional[\n        typing.Union[\n            bool,\n            typing.List[typing.Type[Exception]],\n            typing.Set[typing.Type[Exception]],\n        ]\n    ] = None,\n    **kwargs\n) -&gt; typing.Callable[..., \"ReturnValue\"]\n</code></pre><pre><code>register_abc(\n    phase: typing.Optional[\n        kvdb.tasks.main.TaskPhase\n    ] = None,\n    silenced: typing.Optional[bool] = None,\n    silenced_stages: typing.Optional[\n        typing.List[str]\n    ] = None,\n    default_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    cronjob: typing.Optional[bool] = None,\n    queue_name: typing.Optional[str] = None,\n    disable_patch: typing.Optional[bool] = None,\n    disable_ctx_in_patch: typing.Optional[bool] = None,\n    worker_attributes: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    attribute_match_type: typing.Optional[\n        kvdb.tasks.types.AttributeMatchType\n    ] = None,\n    fallback_enabled: typing.Optional[bool] = None,\n    on_failure_callback: typing.Optional[\n        typing.Union[typing.Callable, str]\n    ] = None,\n    exclude_retry_exceptions: typing.Optional[\n        typing.Union[\n            bool,\n            typing.List[typing.Type[Exception]],\n            typing.Set[typing.Type[Exception]],\n        ]\n    ] = None,\n    **kwargs\n) -&gt; typing.Callable[[\"RT\"], \"RT\"]\n</code></pre> <pre><code>register_abc(\n    cls_or_func: typing.Optional[\n        typing.Union[\n            typing.Type[\"TaskABC\"],\n            kvdb.tasks.main.FunctionT,\n        ]\n    ] = None,\n    **kwargs\n) -&gt; typing.Callable[[\"FunctionT\"], \"FunctionT\"]\n</code></pre> <p>Registers an abstract class or function to the task queue</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>def register_abc(\n    cls_or_func: Optional[Union[Type['TaskABC'], FunctionT]] = None,\n    **kwargs\n) -&gt; Callable[['FunctionT'], 'FunctionT']:\n    \"\"\"\n    Registers an abstract class or function to the task queue\n    \"\"\"\n    from .main import TaskManager\n    return TaskManager.register_abc(cls_or_func = cls_or_func, **kwargs)\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.register_abstract","title":"register_abstract","text":"<pre><code>register_abstract(\n    func: kvdb.tasks.main.FunctionT,\n) -&gt; typing.Callable[\n    [kvdb.tasks.main.FunctionT], kvdb.tasks.main.FunctionT\n]\n</code></pre> <p>Registers a function that is part of an abstract class that is not yet initialized</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>def register_abstract(\n    func: FunctionT,\n) -&gt; Callable[[FunctionT], FunctionT]:\n    \"\"\"\n    Registers a function that is part of an abstract class\n    that is not yet initialized\n    \"\"\"\n    from .main import TaskManager\n    return TaskManager.register_abstract(func)\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.register_object","title":"register_object","text":"<pre><code>register_object(\n    queue_name: typing.Optional[str] = None,\n    name: typing.Optional[str] = None,\n    phase: typing.Optional[\n        kvdb.tasks.main.TaskPhase\n    ] = None,\n    silenced: typing.Optional[bool] = None,\n    silenced_stages: typing.Optional[\n        typing.List[str]\n    ] = None,\n    default_kwargs: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    cronjob: typing.Optional[bool] = None,\n    disable_patch: typing.Optional[bool] = None,\n    disable_ctx_in_patch: typing.Optional[bool] = None,\n    worker_attributes: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    attribute_match_type: typing.Optional[\n        \"AttributeMatchType\"\n    ] = None,\n    fallback_enabled: typing.Optional[bool] = None,\n    on_failure_callback: typing.Optional[\n        typing.Union[typing.Callable, str]\n    ] = None,\n    context: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    is_unset: typing.Optional[bool] = False,\n    **kwargs\n) -&gt; \"ModuleType\"\n</code></pre> <pre><code>register_object(\n    queue_name: typing.Optional[str] = None,\n    is_unset: typing.Optional[bool] = False,\n    **kwargs\n) -&gt; \"ModuleType\"\n</code></pre> <p>Registers a module to the queue_name</p> <p>Additional kwargs are passed as the partial function arguments that are subsequently overridden by present values when @register is called</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>def register_object(\n    queue_name: Optional[str] = None,\n    is_unset: Optional[bool] = False,\n    **kwargs,\n) -&gt; 'ModuleType':\n    \"\"\"\n    Registers a module to the queue_name\n\n    Additional kwargs are passed as the partial function arguments\n    that are subsequently overridden by present values when @register\n    is called\n    \"\"\"\n    from .main import TaskManager\n    return TaskManager.register_object(queue_name = queue_name, is_unset = is_unset, **kwargs)\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.set_default_global_queue_name","title":"set_default_global_queue_name","text":"<pre><code>set_default_global_queue_name(name: str)\n</code></pre> <p>Updates the default global queue name</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>def set_default_global_queue_name(name: str):\n    \"\"\"\n    Updates the default global queue name\n    \"\"\"\n    from .main import TaskManager\n    TaskManager.default_queue_name = name\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.spawn_new_task_worker","title":"spawn_new_task_worker","text":"<pre><code>spawn_new_task_worker(\n    worker_name: typing.Optional[str] = None,\n    worker_imports: typing.Optional[\n        typing.Union[str, typing.List[str]]\n    ] = None,\n    worker_cls: typing.Optional[str] = None,\n    worker_class: typing.Optional[\n        typing.Type[\"TaskWorker\"]\n    ] = None,\n    worker_config: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    worker_queues: typing.Optional[\n        typing.Union[str, typing.List[str]]\n    ] = None,\n    worker_functions: typing.Optional[\n        typing.List[\"TaskFunction\"]\n    ] = None,\n    worker_cron_jobs: typing.Optional[\n        typing.List[\"CronJob\"]\n    ] = None,\n    worker_startup: typing.Optional[\n        typing.Union[\n            typing.List[typing.Callable], typing.Callable\n        ]\n    ] = None,\n    worker_shutdown: typing.Optional[\n        typing.Union[\n            typing.List[typing.Callable], typing.Callable\n        ]\n    ] = None,\n    worker_before_process: typing.Optional[\n        typing.Callable\n    ] = None,\n    worker_after_process: typing.Optional[\n        typing.Callable\n    ] = None,\n    worker_attributes: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    queue_names: typing.Optional[\n        typing.Union[str, typing.List[str]]\n    ] = None,\n    queue_config: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    queue_class: typing.Optional[\n        typing.Type[\"TaskQueue\"]\n    ] = None,\n    max_concurrency: typing.Optional[int] = None,\n    max_broadcast_concurrency: typing.Optional[int] = None,\n    debug_enabled: typing.Optional[bool] = False,\n    use_new_event_loop: typing.Optional[bool] = None,\n    use_asyncio_task: typing.Optional[bool] = False,\n    disable_worker_start: typing.Optional[bool] = False,\n    **kwargs\n) -&gt; \"TaskWorker\"\n</code></pre> <pre><code>spawn_new_task_worker(**kwargs) -&gt; 'TaskWorker'\n</code></pre> <p>Spawns a new task worker</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>def spawn_new_task_worker(\n    **kwargs,\n) -&gt; 'TaskWorker':  # sourcery skip: low-code-quality\n    \"\"\"\n    Spawns a new task worker\n    \"\"\"\n    from .spawn import spawn_new_task_worker\n    return spawn_new_task_worker(**kwargs)\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.start_task_workers","title":"start_task_workers","text":"<pre><code>start_task_workers(\n    num_workers: typing.Optional[int] = 1,\n    start_index: typing.Optional[int] = None,\n    worker_name: typing.Optional[str] = \"global\",\n    worker_name_sep: typing.Optional[str] = \"-\",\n    worker_imports: typing.Optional[\n        typing.Union[str, typing.List[str]]\n    ] = None,\n    worker_cls: typing.Optional[str] = None,\n    worker_class: typing.Optional[\n        typing.Type[\"TaskWorker\"]\n    ] = None,\n    worker_config: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    worker_queues: typing.Optional[\n        typing.Union[str, typing.List[str]]\n    ] = None,\n    worker_functions: typing.Optional[\n        typing.List[\"TaskFunction\"]\n    ] = None,\n    worker_cron_jobs: typing.Optional[\n        typing.List[\"CronJob\"]\n    ] = None,\n    worker_startup: typing.Optional[\n        typing.Union[\n            typing.List[typing.Callable], typing.Callable\n        ]\n    ] = None,\n    worker_shutdown: typing.Optional[\n        typing.Union[\n            typing.List[typing.Callable], typing.Callable\n        ]\n    ] = None,\n    worker_before_process: typing.Optional[\n        typing.Callable\n    ] = None,\n    worker_after_process: typing.Optional[\n        typing.Callable\n    ] = None,\n    worker_attributes: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    queue_names: typing.Optional[\n        typing.Union[str, typing.List[str]]\n    ] = None,\n    queue_config: typing.Optional[\n        typing.Dict[str, typing.Any]\n    ] = None,\n    queue_class: typing.Optional[\n        typing.Type[\"TaskQueue\"]\n    ] = None,\n    max_concurrency: typing.Optional[int] = None,\n    max_broadcast_concurrency: typing.Optional[int] = None,\n    debug_enabled: typing.Optional[bool] = False,\n    disable_env_name: typing.Optional[bool] = False,\n    method: typing.Optional[str] = \"mp\",\n    use_new_event_loop: typing.Optional[bool] = None,\n    disable_worker_start: typing.Optional[bool] = False,\n    terminate_timeout: typing.Optional[float] = 5.0,\n    **kwargs\n) -&gt; typing.Union[\n    typing.Dict[\n        str,\n        typing.Dict[\n            str,\n            typing.Union[\n                multiprocessing.Process,\n                asyncio.Task,\n                \"TaskWorker\",\n            ],\n        ],\n    ],\n    typing.List[\"TaskWorker\"],\n]\n</code></pre> <pre><code>start_task_workers(\n    **kwargs,\n) -&gt; typing.Union[\n    typing.Dict[\n        str,\n        typing.Dict[\n            str,\n            typing.Union[\n                multiprocessing.Process,\n                asyncio.Task,\n                \"TaskWorker\",\n            ],\n        ],\n    ],\n    typing.List[\"TaskWorker\"],\n]\n</code></pre> <p>Starts multiple task workers using either multiprocessing or asyncio.tasks</p> <p>Method can be either <code>Multiprocessing</code> (<code>mp</code>, <code>process</code>) or <code>asyncio.Task</code> (<code>tasks</code>, <code>asyncio</code>)</p> <p>If <code>disable_worker_start</code> is True, then the workers are initialized but not started and  the worker objects are returned</p> <p>This method allows initialization of multiple task workers with new processes through various mechanisms.</p> <ul> <li><code>num_workers</code> specifies the number of workers to start</li> <li><code>start_index</code> specifies the starting index for the worker names</li> <li><code>worker_name</code> specifies the worker name prefix</li> <li><code>worker_name_sep</code> specifies the worker name separator</li> </ul> <p>If <code>worker_cls</code> is specified, then the worker class is imported and instantiated   - If the <code>worker_cls</code> is a Type[TaskWorker], then it is instantiated directly   - If the <code>worker_cls</code> is an initialized TaskWorker, then it is used directly and configured</p> <p>If <code>worker_imports</code> is specified, then the provided functions/modules are imported to initialize any registrations of tasks/cron jobs     Example: worker_imports = ['my_module.tasks', 'my_module.tasks.init_function']</p> <p><code>queue_names</code> are initialized prior to <code>worker_queues</code> to ensure that all tasks are registered before the worker starts</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>def start_task_workers(\n    **kwargs\n) -&gt; Union[Dict[str, Dict[str, Union[mp.Process, asyncio.Task, 'TaskWorker']]], List['TaskWorker']]:\n    \"\"\"\n    Starts multiple task workers using either multiprocessing or asyncio.tasks\n\n    Method can be either `Multiprocessing` (`mp`, `process`) or `asyncio.Task` (`tasks`, `asyncio`)\n\n    If `disable_worker_start` is True, then the workers are initialized but not started and \n    the worker objects are returned\n\n    This method allows initialization of multiple task workers with new processes through\n    various mechanisms.\n\n    - `num_workers` specifies the number of workers to start\n    - `start_index` specifies the starting index for the worker names\n    - `worker_name` specifies the worker name prefix\n    - `worker_name_sep` specifies the worker name separator\n\n    If `worker_cls` is specified, then the worker class is imported and instantiated\n      - If the `worker_cls` is a Type[TaskWorker], then it is instantiated directly\n      - If the `worker_cls` is an initialized TaskWorker, then it is used directly and configured\n\n    If `worker_imports` is specified, then the provided functions/modules are imported to\n    initialize any registrations of tasks/cron jobs\n        Example: worker_imports = ['my_module.tasks', 'my_module.tasks.init_function']\n\n    `queue_names` are initialized prior to `worker_queues` to ensure that\n    all tasks are registered before the worker starts\n    \"\"\"\n    from .spawn import start_task_workers\n    return start_task_workers(**kwargs)\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.wait_for_job","title":"wait_for_job  <code>async</code>","text":"<pre><code>wait_for_job(\n    job: \"Job\",\n    source_job: typing.Optional[\"Job\"] = None,\n    queue_name: typing.Optional[str] = None,\n    verbose: typing.Optional[bool] = False,\n    raise_exceptions: typing.Optional[bool] = False,\n    refresh_interval: typing.Optional[float] = 0.5,\n    **kwargs\n) -&gt; typing.Any\n</code></pre> <pre><code>wait_for_job(\n    job: \"Job\",\n    source_job: typing.Optional[\"Job\"] = None,\n    queue_name: typing.Optional[str] = None,\n    verbose: typing.Optional[bool] = False,\n    raise_exceptions: typing.Optional[bool] = False,\n    refresh_interval: typing.Optional[float] = 0.5,\n    **kwargs\n) -&gt; typing.Any\n</code></pre> <p>Waits for job to finish</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>async def wait_for_job(\n    job: 'Job',\n    source_job: Optional['Job'] = None,\n    queue_name: Optional[str] = None,\n    verbose: Optional[bool] = False,\n    raise_exceptions: Optional[bool] = False,\n    refresh_interval: Optional[float] = 0.5,\n    **kwargs,\n) -&gt; Any:  # sourcery skip: low-code-quality\n    \"\"\"\n    Waits for job to finish\n    \"\"\"\n    from .main import TaskManager\n    return await TaskManager.wait_for_job(job, source_job = source_job, queue_name = queue_name, verbose = verbose, raise_exceptions = raise_exceptions, refresh_interval = refresh_interval, **kwargs)\n</code></pre>"},{"location":"topics/tasks/#kvdb.tasks.wait_for_jobs","title":"wait_for_jobs  <code>async</code>","text":"<pre><code>wait_for_jobs(\n    jobs: typing.List[\"Job\"],\n    source_job: typing.Optional[\"Job\"] = None,\n    queue_name: typing.Optional[str] = None,\n    verbose: typing.Optional[bool] = False,\n    raise_exceptions: typing.Optional[bool] = False,\n    refresh_interval: typing.Optional[float] = 0.5,\n    **kwargs\n) -&gt; typing.List[typing.Any]\n</code></pre> <pre><code>wait_for_jobs(\n    jobs: typing.List[\"Job\"],\n    source_job: typing.Optional[\"Job\"] = None,\n    queue_name: typing.Optional[str] = None,\n    verbose: typing.Optional[bool] = False,\n    raise_exceptions: typing.Optional[bool] = False,\n    refresh_interval: typing.Optional[float] = 0.5,\n    **kwargs\n) -&gt; typing.List[typing.Any]\n</code></pre> <p>Waits for jobs to finish</p> Source code in <code>kvdb/tasks/__init__.py</code> <pre><code>async def wait_for_jobs(\n    jobs: List['Job'],\n    source_job: Optional['Job'] = None,\n    queue_name: Optional[str] = None,\n    verbose: Optional[bool] = False,\n    raise_exceptions: Optional[bool] = False,\n    refresh_interval: Optional[float] = 0.5,\n    **kwargs,\n) -&gt; List[Any]:  # sourcery skip: low-code-quality\n    \"\"\"\n    Waits for jobs to finish\n    \"\"\"\n    from .main import TaskManager\n    return await TaskManager.wait_for_jobs(jobs, source_job = source_job, queue_name = queue_name, verbose = verbose, raise_exceptions = raise_exceptions, refresh_interval = refresh_interval, **kwargs)\n</code></pre>"}]}